[1,["b439fSLR5KOLDDCq2ahWco@b4e6b","9evfxzaBtEIps5YPxH9elM","379bcb6E9Obb5TE009NtAU@4b8b9","06jv4/wTJLgr69dwPb2G9U@b4e6b","f6SJZOjTJB/JrJeh5xTdF7","33AyVsZZ9OxLOEMIfezo+u@f9941","15ffRJBOFPAZ6JHXiW83tO@f9941","54TknWPwVPqJqeCR+Y/Czo@f9941","e3AVGkugBEoKClzhfNDGF7@f9941","06jv4/wTJLgr69dwPb2G9U@7d6ab","06jv4/wTJLgr69dwPb2G9U@ae517","06jv4/wTJLgr69dwPb2G9U@f7f2b","06jv4/wTJLgr69dwPb2G9U@7a2b6","06jv4/wTJLgr69dwPb2G9U@65ad2","06jv4/wTJLgr69dwPb2G9U@20fc1","06jv4/wTJLgr69dwPb2G9U@8bccd","06jv4/wTJLgr69dwPb2G9U@5efe2","06jv4/wTJLgr69dwPb2G9U@a8010","06jv4/wTJLgr69dwPb2G9U@444de","06jv4/wTJLgr69dwPb2G9U@85741","15ffRJBOFPAZ6JHXiW83tO@6c48a","239ovTmkdI0YHNRg9fKy12@6c48a","33AyVsZZ9OxLOEMIfezo+u@6c48a","379bcb6E9Obb5TE009NtAU@b4e6b","379bcb6E9Obb5TE009NtAU@a4587","379bcb6E9Obb5TE009NtAU@7d6ab","57gKKtNKJD/KczNLHr5bJF@6c48a","c89m0XNRpI2qEsAhLShXXE","402eiwKoNCp6FxIdd2o9YW@6c48a","54TknWPwVPqJqeCR+Y/Czo@6c48a","57UgcWSMhKGYrPQcn4d3+w@6c48a","85n7Ra+WxAmLOnOMcwty0E@6c48a","a4Hd20ZQBP24kF75KtAFWG@6c48a","b439fSLR5KOLDDCq2ahWco@2e9a4","b439fSLR5KOLDDCq2ahWco@a8d73","b439fSLR5KOLDDCq2ahWco@280fb","b439fSLR5KOLDDCq2ahWco@23d54","b439fSLR5KOLDDCq2ahWco@d33b5","b439fSLR5KOLDDCq2ahWco@9c990","b439fSLR5KOLDDCq2ahWco@d293f","b439fSLR5KOLDDCq2ahWco@c2c61","b439fSLR5KOLDDCq2ahWco@822ba","b439fSLR5KOLDDCq2ahWco@ea49c","b439fSLR5KOLDDCq2ahWco@73337","b439fSLR5KOLDDCq2ahWco@4ea01","b439fSLR5KOLDDCq2ahWco@6bf16","b439fSLR5KOLDDCq2ahWco@69165","b439fSLR5KOLDDCq2ahWco@d6b3f","b439fSLR5KOLDDCq2ahWco@80e61","b439fSLR5KOLDDCq2ahWco@93735","b439fSLR5KOLDDCq2ahWco@40189","b439fSLR5KOLDDCq2ahWco@6c56c","b439fSLR5KOLDDCq2ahWco@54ccb","b439fSLR5KOLDDCq2ahWco@a8165","b439fSLR5KOLDDCq2ahWco@ac3e5","b439fSLR5KOLDDCq2ahWco@3e56e","b439fSLR5KOLDDCq2ahWco@d482b","b439fSLR5KOLDDCq2ahWco@3a858","b439fSLR5KOLDDCq2ahWco@2dcb0","b439fSLR5KOLDDCq2ahWco@1d653","b439fSLR5KOLDDCq2ahWco@0344e","b439fSLR5KOLDDCq2ahWco@18907","b439fSLR5KOLDDCq2ahWco@3812e","b439fSLR5KOLDDCq2ahWco@b2c37","b439fSLR5KOLDDCq2ahWco@b3886","b439fSLR5KOLDDCq2ahWco@b608f","b439fSLR5KOLDDCq2ahWco@87c9a","b439fSLR5KOLDDCq2ahWco@595e7","b439fSLR5KOLDDCq2ahWco@7d2a5","b439fSLR5KOLDDCq2ahWco@32996","b439fSLR5KOLDDCq2ahWco@6bca3","b439fSLR5KOLDDCq2ahWco@1df3b","b439fSLR5KOLDDCq2ahWco@6fdb7","b439fSLR5KOLDDCq2ahWco@13319","b439fSLR5KOLDDCq2ahWco@ee479","b439fSLR5KOLDDCq2ahWco@cc955","b439fSLR5KOLDDCq2ahWco@8d2a3","b439fSLR5KOLDDCq2ahWco@77243","b439fSLR5KOLDDCq2ahWco@a86bd","b439fSLR5KOLDDCq2ahWco@8bae0","b439fSLR5KOLDDCq2ahWco@78d0d","b439fSLR5KOLDDCq2ahWco@c3a13","b439fSLR5KOLDDCq2ahWco@0a4c0","b439fSLR5KOLDDCq2ahWco@f90d2","b439fSLR5KOLDDCq2ahWco@5e7b0","b439fSLR5KOLDDCq2ahWco@fc108","b439fSLR5KOLDDCq2ahWco@80929","b439fSLR5KOLDDCq2ahWco@9d828","b439fSLR5KOLDDCq2ahWco@ca972","b439fSLR5KOLDDCq2ahWco@46409","b439fSLR5KOLDDCq2ahWco@a676f","b439fSLR5KOLDDCq2ahWco@cf560","b439fSLR5KOLDDCq2ahWco@b4b5f","b439fSLR5KOLDDCq2ahWco@b61ba","b439fSLR5KOLDDCq2ahWco@e8591","b439fSLR5KOLDDCq2ahWco@6cef6","b439fSLR5KOLDDCq2ahWco@7d6ab","c8qt4y7bFKhJhJ6N3+4y36@6c48a","3eHrkwYmBAV4g8/lvgVfG9","12Y9dMgWdJKJGmTiZyQR9H@2e76e","06jv4/wTJLgr69dwPb2G9U@c39d2","402eiwKoNCp6FxIdd2o9YW@f9941","239ovTmkdI0YHNRg9fKy12@f9941","dcyNu0SadIz6ADj06Lu0/s@f9941","a4Hd20ZQBP24kF75KtAFWG@f9941","c8qt4y7bFKhJhJ6N3+4y36@f9941","57UgcWSMhKGYrPQcn4d3+w@f9941","85n7Ra+WxAmLOnOMcwty0E@f9941","b439fSLR5KOLDDCq2ahWco@70111","d0MqyYBeFAkIi762QNy1/B@b47c0","6fAc9/gb9Kfr1dCvwZaWSA@b47c0","dcyNu0SadIz6ADj06Lu0/s@6c48a","e3AVGkugBEoKClzhfNDGF7@6c48a"],["node","targetInfo","_mesh","_material","root","asset","_textureSource","_spriteFrame","_parent","mainTexture","_effectAsset","data","_target","_normalSprite","_pressedSprite","failScreen","carNode","_cameraComponent","scene","_envmapHDR","_envmapLDR"],[["cc.Node",["_name","_layer","_id","_objFlags","__editorExtras__","_components","_parent","_lpos","_children","_lscale","_prefab","_lrot","_euler"],-2,9,1,5,2,5,4,5,5],"cc.ImageAsset","cc.SpriteFrame",["cc.BoxCollider",["_isTrigger","_enabled","_size","_center","node","_material"],1,5,5,1,6],["cc.Sprite",["_sizeMode","_type","node","_spriteFrame","_color"],1,1,6,5],["cc.Node",["_name","_layer","_parent","_components","_children","_lpos","_lscale"],1,1,12,2,5,5],["cc.UITransform",["node","_contentSize","_anchorPoint"],3,1,5,5],"cc.TextureCube",["cc.MeshRenderer",["_name","node","_materials","bakeSettings","_mesh","__prefab"],2,1,3,4,6,4],["cc.RigidBody",["_mass","_group","node"],1,1],["cc.Widget",["_originalWidth","_top","_bottom","_alignFlags","_originalHeight","node"],-2,1],["cc.Button",["_transition","node","_normalColor","_target","_normalSprite","_pressedSprite"],2,1,5,1,6,6],["cc.Camera",["_orthoHeight","_far","_clearFlags","_visibility","_near","_projection","_priority","node","_color"],-4,1,5],["cc.Mesh",["_native","_hash","_struct"],1,11],["cc.Material",["_name","_states","_defines","_props"],0,12],["cc.Prefab",[],3],["cc.Node",["_name","_parent","_components","_lpos"],2,1,2,5],["cc.PrefabInfo",["fileId","instance","targetOverrides","nestedPrefabInstanceRoots","root","asset"],-1,1,1],["cc.PrefabInfo",["root","asset","fileId","instance","targetOverrides","nestedPrefabInstanceRoots"],-2,2],["cc.PrefabInfo",["fileId","targetOverrides","nestedPrefabInstanceRoots","root","instance","asset"],0,1,4,6],["cc.CompPrefabInfo",["fileId"],2],["cc.ModelBakeSettings",[],3],["cc.PhysicsMaterial",["_friction","_restitution"],1],["cc.SceneAsset",["_name"],2],["d7669HB1uZF4IujHoZZEfLn",["maxSpeed","node","carNode","failScreen"],2,1,1,1],["cc.Canvas",["node","_cameraComponent"],3,1,1],["cc.Scene",["_name","_children","_prefab","_globals"],2,2,4,4],["cc.SceneGlobals",["ambient","shadows","_skybox","fog","octree","lightProbeInfo"],3,4,4,4,4,4,4],["cc.AmbientInfo",["_skyIllumLDR","_skyColorHDR","_skyColorLDR","_groundAlbedoLDR"],2,5,5,5],["cc.ShadowsInfo",["_shadowColor"],3,5],["cc.SkyboxInfo",["_enabled","_envmapHDR","_envmapLDR"],2,6,6],["cc.FogInfo",[],3],["cc.OctreeInfo",[],3],["cc.LightProbeInfo",[],3],["cc.UIOpacity",["node"],3,1],["cc.PrefabInstance",["fileId","prefabRootNode","mountedComponents","propertyOverrides"],1,9,9],["cc.MountedComponentsInfo",["targetInfo","components"],3,4,9],["cc.TargetInfo",["localID"],2],["0c5c19cDzRErqLWSwwERMkK",["node","player","coinUITarget"],3,1,1,1],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,8],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,4],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,8],["a0540BtwkVLia6Do/bkJV5y",["node","playerNode"],3,1,1],["71046vyQ6tC7In8S6cta9Xd",[],3],["b2e11voyQpBi65Gs7M9YDpI",[],3],["daf67MHRONA+ZcH8Ip1e/cR",[],3],["8b636v40O5BoL3s/v/hdhRJ",["_enabled","node","player"],2,1,1],["d2bfeQnsHFKa57bZtgAM1hb",[],3],["cc.DirectionalLight",["node","_color","_staticSettings"],3,1,5,4],["cc.StaticLightSettings",[],3],["a5db2mxYHdA5JuKGDngZDWr",["node","retryButton","failIcon","background","downloadButton"],3,1,1,1,1,1],["cc.Slider",["_direction","_progress","node","_handle"],1,1,1],["cc.Label",["_string","_actualFontSize","_fontSize","_lineHeight","node"],-1,1],["dcb75xPX61HLJXZ6z17s+Hi",["tutorialRepeatDelay","node","slider","player","tutorialHand","coinLabel","failScreen"],2,1,1,1,1,1,1],["cc.EffectAsset",["_name","shaders","techniques"],0]],[[37,0,2],[42,0,1,2,2],[40,0,1,2,2],[36,0,1,1],[17,0,1,2,3,4,5,5],[13,0,1,2,3],[21,1],[8,1,5,2,3,4,1],[20,0,2],[41,0,1,2,3],[0,0,6,5,10,7,11,9,12,2],[3,3,2,5,1],[9,1,0,3],[48,1],[0,3,4,6,10,3],[19,0,1,2,3,4,5,4],[35,0,1,2,3,3],[3,0,4,2,2],[38,0,1,2,1],[39,0,1,2,3],[0,0,6,5,10,7,11,12,2],[6,0,1,1],[45,1],[3,1,2],[14,0,1,2,3,4],[4,2,3,1],[44,1],[15,1],[0,0,8,10,2],[0,0,1,6,5,7,3],[3,1,3,2],[6,0,1,2,1],[4,1,0,2,3,3],[0,0,1,6,5,3],[0,0,1,6,5,7,9,3],[5,0,1,2,3,5,6,3],[10,3,0,4,5,4],[11,0,1,2,3,4,5,2],[0,0,6,5,10,9,2],[0,0,2,8,5,7,3],[0,0,1,5,7,9,3],[0,0,2,8,3],[0,0,1,2,8,5,7,4],[0,0,1,8,5,9,3],[0,0,2,6,8,5,7,11,12,3],[0,0,6,5,7,11,9,12,2],[0,0,1,6,8,5,3],[0,0,1,2,6,8,7,4],[0,0,2,6,5,11,12,3],[0,0,2,6,8,3],[0,0,6,5,2],[5,0,1,2,4,3,3],[5,0,1,2,4,3,5,6,3],[16,0,1,2,3,2],[18,0,1,2,3,4,5,6],[8,0,1,2,3,4,2],[22,0,1,3],[23,0,2],[24,0,1,2,3,2],[3,4,3,2,1],[3,2,1],[3,3,2,1],[3,0,4,3,2,2],[9,0,2,2],[6,0,1],[4,0,2,4,3,2],[4,0,2,3,2],[4,0,2,2],[25,0,1,1],[10,1,2,0,5,4],[26,0,1,2,3,2],[27,0,1,2,3,4,5,1],[28,0,1,2,3,2],[29,0,1],[30,0,1,2,2],[31,1],[32,1],[33,1],[11,1,2,3,4,1],[34,0,1],[12,0,4,1,2,3,7,6],[12,5,6,0,1,2,3,7,8,7],[43,0,1,1],[46,1],[47,0,1,2,2],[49,0,1,2,1],[50,1],[51,0,1,2,3,4,1],[52,0,1,2,3,3],[53,0,1,2,3,4,5],[54,0,1,2,3,4,5,6,2],[55,0,1,2,4]],[[[[5,".bin",3892434022,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":6528,"length":504,"count":252,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":6528,"count":136,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.1250319480895996,-1.12503182888031,-2.5030078887939453],"maxPosition",8,[1,1.1250319480895996,1.1250323057174683,-0.7788976430892944]]],-1],0,0,[],[],[]],[[[5,".bin",4030699436,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":14976,"length":1320,"count":660,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":14976,"count":312,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.245538592338562,-1.2455388307571411,-1.2455388307571411],"maxPosition",8,[1,1.245538592338562,1.2455388307571411,1.2455388307571411]]],-1],0,0,[],[],[]],[[[5,".bin",4120044437,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":20448,"length":1608,"count":804,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":20448,"count":426,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.2455384731292725,-1.2455389499664307,-1.2455388307571411],"maxPosition",8,[1,1.2455387115478516,1.2455387115478516,1.2455388307571411]]],-1],0,0,[],[],[]],[[[5,".bin",3632968266,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":89664,"length":10416,"count":5208,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":89664,"count":1868,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.1138107776641846,-0.45490318536758423,-1.0989925861358643],"maxPosition",8,[1,1.113885760307312,0.8454568386077881,1.0987704992294312]]],-1],0,0,[],[],[]],[[[5,".bin",3632968266,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":89664,"length":10416,"count":5208,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":89664,"count":1868,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.1138107776641846,-0.45490318536758423,-1.0989925861358643],"maxPosition",8,[1,1.113885760307312,0.8454568386077881,1.0987704992294312]]],-1],0,0,[],[],[]],[[[5,".bin",407260942,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":20208,"length":3912,"count":1956,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":20208,"count":421,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.1439939737319946,-1.6290862560272217,-1.629090666770935],"maxPosition",8,[1,4.76837158203125e-7,1.629086971282959,1.629082441329956]]],-1],0,0,[],[],[]],[[[5,".bin",3892434022,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":6528,"length":504,"count":252,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":6528,"count":136,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.1250319480895996,-1.12503182888031,-2.5030078887939453],"maxPosition",8,[1,1.1250319480895996,1.1250323057174683,-0.7788976430892944]]],-1],0,0,[],[],[]],[[[5,".bin",4030699436,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":14976,"length":1320,"count":660,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":14976,"count":312,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.245538592338562,-1.2455388307571411,-1.2455388307571411],"maxPosition",8,[1,1.245538592338562,1.2455388307571411,1.2455388307571411]]],-1],0,0,[],[],[]],[[[5,".bin",4014500266,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":89664,"length":10416,"count":5208,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":89664,"count":1868,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.1138856410980225,-0.8454568982124329,-1.0989925861358643],"maxPosition",8,[1,1.1138108968734741,0.4549032747745514,1.0987704992294312]]],-1],0,0,[],[],[]],[[[24,"Material",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true,"USE_ALBEDO_MAP":true}],[[[{"shininessExponent":25,"emissiveScale":1,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4293388263],"emissive",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[9,10],[9,4]],[[[27],[28,"Machine_",[-2,-3,-4,-5,-6,-7,-8,-9,-10,-11],[4,"49a8W2zvZfgr1zEqsbBaOz",null,null,null,-1,0]],[20,"wheel_back.001",1,[[7,-12,[8,"c92/qVBsZeuoq/CuzXI+hw"],[0],[6],1]],[4,"10oEl8O1NQMacI5L07QkB8",null,null,null,1,0],[1,-2.6392431259155273,1.0396625995635986,-2.0376884937286377],[3,-0.7071068705935067,0,0,0.7071066917795769],[1,-90.00001448901888,0,0]],[20,"wheel_front.001",1,[[7,-13,[8,"b0HY5bKn5ZYI1V8n2qjcNz"],[2],[6],3]],[4,"30va3S0MJRBL/NWb8qsxhl",null,null,null,1,0],[1,2.6212399005889893,1.0396625995635986,-2.0376884937286377],[3,-0.7071068705935067,0,0,0.7071066917795769],[1,-90.00001448901888,0,0]],[20,"wheel_front",1,[[7,-14,[8,"4aVgHnRY5Wpobn+5B42iNv"],[4],[6],5]],[4,"e6/3LWKVNU05AjXD78GcGv",null,null,null,1,0],[1,2.6212399005889893,1.0396625995635986,2.0431573390960693],[3,-0.7071068705935067,0,0,0.7071066917795769],[1,-90.00001448901888,0,0]],[20,"wheel_back",1,[[7,-15,[8,"64Ig5hH8ZYvp7oUXVtI5dG"],[6],[6],7]],[4,"cdNJVFvClX4ItcUiMxUUin",null,null,null,1,0],[1,-2.6392431259155273,1.0396625995635986,2.0431573390960693],[3,-0.7071068705935067,0,0,0.7071066917795769],[1,-90.00001448901888,0,0]],[20,"frame_wheel.001",1,[[7,-16,[8,"bcwlVdCYhemKEWDN8cAFof"],[8],[6],9]],[4,"a1hh3Bd/JeTYYHQERiuzbx",null,null,null,1,0],[1,2.6145143508911133,3.2664175033569336,4.3888576328754425e-7],[3,-0.7071068705935067,0,0,0.7071066917795769],[1,-90.00001448901888,0,0]],[20,"frame_wheel",1,[[7,-17,[8,"bf5f8euW1bKom/ojeH/5zz"],[10],[6],11]],[4,"01ceRmE4JSHLHbfvkONyp7",null,null,null,1,0],[1,-2.6290273666381836,3.2664175033569336,4.3888576328754425e-7],[3,-0.7071068705935067,0,0,0.7071066917795769],[1,-90.00001448901888,0,0]],[20,"DBlock_Full.001",1,[[7,-18,[8,"6b+GLoYplfzqIkdCRozWbK"],[12],[6],13]],[4,"911KGRN5Ve8qCRJtNs3937",null,null,null,1,0],[1,-0.009352799504995346,3.305187940597534,3.671739250421524e-7],[3,-0.7071068705935067,0,0,0.7071066917795769],[1,-90.00001448901888,0,0]],[20,"Box.001",1,[[7,-19,[8,"d8Qyeg1d5U6JAIj5kEFVCu"],[14],[6],15]],[4,"a66izsailSfb9RmuTN/Yaa",null,null,null,1,0],[1,2.547520637512207,3.3079404830932617,4.752073436975479e-7],[3,-0.7071068705935067,0,0,0.7071066917795769],[1,-90.00001448901888,0,0]],[20,"Box",1,[[7,-20,[8,"18cFq3JuJWBY2g/Kso545S"],[16],[6],17]],[4,"7amRIjUV9fsL981+WEK4Ho",null,null,null,1,0],[1,-2.56524920463562,3.3079404830932617,4.752073436975479e-7],[3,-0.7071068705935067,0,0,0.7071066917795769],[1,-90.00001448901888,0,0]],[20,"booster",1,[[7,-21,[8,"a9Qr5gnRpSQ77PPgowVpsA"],[18],[6],19]],[4,"068EkwN11cxJ+L8nUkCGRs",null,null,null,1,0],[1,-3.6132044792175293,3.3865599632263184,-0.0010814778506755829],[3,-0.7071068705935067,0,0,0.7071066917795769],[1,-90.00001448901888,0,0]]],0,[0,4,1,0,-1,2,0,-2,3,0,-3,4,0,-4,5,0,-5,6,0,-6,7,0,-7,8,0,-8,9,0,-9,10,0,-10,11,0,0,2,0,0,3,0,0,4,0,0,5,0,0,6,0,0,7,0,0,8,0,0,9,0,0,10,0,0,11,0,11,1,21],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2],[3,10,3,11,3,12,3,13,3,14,3,15,3,16,3,17,3,18,3,19]],[[[5,".bin",4014500266,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":89664,"length":10416,"count":5208,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":89664,"count":1868,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-1.1138856410980225,-0.8454568982124329,-1.0989925861358643],"maxPosition",8,[1,1.1138108968734741,0.4549032747745514,1.0987704992294312]]],-1],0,0,[],[],[]],[[[5,".bin",2489017538,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":6776,"length":1200,"count":600,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":6776,"count":121,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-5,0,-5],"maxPosition",8,[1,5,0,5]]],-1],0,0,[],[],[]],[[{"name":"btn_download","rect":{"x":0,"y":0,"width":549,"height":150},"offset":{"x":0,"y":0},"originalSize":{"width":549,"height":150},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-274.5,-75,0,274.5,-75,0,-274.5,75,0,274.5,75,0],"indexes":[0,1,2,2,1,3],"uv":[0,150,549,150,0,0,549,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-274.5,"y":-75,"z":0},"maxPos":{"x":274.5,"y":75,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[2],0,[0],[6],[20]],[[{"name":"coin","rect":{"x":0,"y":0,"width":91,"height":90},"offset":{"x":0,"y":0},"originalSize":{"width":91,"height":90},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-45.5,-45,0,45.5,-45,0,-45.5,45,0,45.5,45,0],"indexes":[0,1,2,2,1,3],"uv":[0,90,91,90,0,0,91,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-45.5,"y":-45,"z":0},"maxPos":{"x":45.5,"y":45,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[2],0,[0],[6],[21]],[[{"name":"draggable","rect":{"x":0,"y":0,"width":290,"height":139},"offset":{"x":0,"y":0},"originalSize":{"width":290,"height":139},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-145,-69.5,0,145,-69.5,0,-145,69.5,0,145,69.5,0],"indexes":[0,1,2,2,1,3],"uv":[0,139,290,139,0,0,290,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-145,"y":-69.5,"z":0},"maxPos":{"x":145,"y":69.5,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[2],0,[0],[6],[22]],[[[27],[28,"Coin",[-2],[4,"0auORVX99QSYHjxYweQevA",null,null,null,-1,0]],[38,"Coin",1,[[7,-3,[8,"afz30X0l5eBqd5vg1uu8cX"],[0],[6],1]],[4,"50hVabCXdUoJWlC+a25B9X",null,null,null,1,0],[1,100,100,100]]],0,[0,4,1,0,-1,2,0,0,2,0,11,1,3],[0,0],[-1,2],[23,24]],[[[5,".bin",2713058639,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":12528,"length":1728,"count":864,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":12528,"count":261,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.003385390155017376,-0.003385390155017376,-0.0006163900252431631],"maxPosition",8,[1,0.003385390155017376,0.003385390155017376,0.0006163900252431631]]],-1],0,0,[],[],[]],[[[24,"Material",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true,"USE_ALBEDO_MAP":true}],[[[{"shininessExponent":25,"emissiveScale":1,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4293388263],"emissive",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[9,10],[25,4]],[[[24,"BG",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{},{}],[[[{},"mainTexture",6,0],{},{},{}],11,0,0,0]]],0,0,[0,0],[9,10],[26,27]],[[{"name":"draggable_plate","rect":{"x":0,"y":0,"width":314,"height":459},"offset":{"x":0,"y":0},"originalSize":{"width":314,"height":459},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-157,-229.5,0,157,-229.5,0,-157,229.5,0,157,229.5,0],"indexes":[0,1,2,2,1,3],"uv":[0,459,314,459,0,0,314,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-157,"y":-229.5,"z":0},"maxPos":{"x":157,"y":229.5,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[2],0,[0],[6],[28]],[[{"name":"default_btn_pressed","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"vertices":{"rawPosition":[-20,-20,0,20,-20,0,-20,20,0,20,20,0],"indexes":[0,1,2,2,1,3],"uv":[0,40,40,40,0,0,40,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-20,"y":-20,"z":0},"maxPos":{"x":20,"y":20,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[2],0,[0],[6],[29]],[[{"name":"default_sprite","rect":{"x":0,"y":2,"width":40,"height":36},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-20,-18,0,20,-18,0,-20,18,0,20,18,0],"indexes":[0,1,2,2,1,3],"uv":[0,38,40,38,0,2,40,2],"nuv":[0,0.05,1,0.05,0,0.95,1,0.95],"minPos":{"x":-20,"y":-18,"z":0},"maxPos":{"x":20,"y":18,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[2],0,[0],[6],[30]],[[{"base":"2,2,0,0,2,0","rgbe":false,"mipmaps":[{"front":"6fAc9/gb9Kfr1dCvwZaWSA@b47c0@e9a6d","back":"6fAc9/gb9Kfr1dCvwZaWSA@b47c0@40c10","left":"6fAc9/gb9Kfr1dCvwZaWSA@b47c0@8fd34","right":"6fAc9/gb9Kfr1dCvwZaWSA@b47c0@74afd","top":"6fAc9/gb9Kfr1dCvwZaWSA@b47c0@bb97f","bottom":"6fAc9/gb9Kfr1dCvwZaWSA@b47c0@7d38f"}]}],[7],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"name":"cross","rect":{"x":0,"y":0,"width":315,"height":315},"offset":{"x":0,"y":0},"originalSize":{"width":315,"height":315},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-157.5,-157.5,0,157.5,-157.5,0,-157.5,157.5,0,157.5,157.5,0],"indexes":[0,1,2,2,1,3],"uv":[0,315,315,315,0,0,315,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-157.5,"y":-157.5,"z":0},"maxPos":{"x":157.5,"y":157.5,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[2],0,[0],[6],[31]],[[[56,0,1]],0,0,[],[],[]],[[{"name":"logo","rect":{"x":0,"y":0,"width":366,"height":202},"offset":{"x":0,"y":0},"originalSize":{"width":366,"height":202},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-183,-101,0,183,-101,0,-183,101,0,183,101,0],"indexes":[0,1,2,2,1,3],"uv":[0,202,366,202,0,0,366,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-183,"y":-101,"z":0},"maxPos":{"x":183,"y":101,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[2],0,[0],[6],[32]],[[[5,".bin",2326861036,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0057139587588608265,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713882390409708,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",972473635,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713920574635267,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.0057139587588608265,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",1324010889,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713920574635267,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713920574635267,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",2326861036,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0057139587588608265,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713882390409708,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",2326861036,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0057139587588608265,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713882390409708,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",2326861036,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0057139587588608265,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713882390409708,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",1077098822,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.00571392523124814,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.00571392523124814,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",1077098822,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.00571392523124814,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.00571392523124814,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",1892375756,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1920,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1920,"count":40,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713920574635267,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713920574635267,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",2599631939,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":5664,"length":432,"count":216,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":5664,"count":118,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.3811908960342407,-0.04228263720870018,-0.042704466730356216],"maxPosition",8,[1,0.3756478428840637,0.045616813004016876,0.006066021975129843]]],-1],0,0,[],[],[]],[[[5,".bin",2326861036,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0057139587588608265,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713882390409708,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",1324010889,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713920574635267,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713920574635267,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",1892375756,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1920,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1920,"count":40,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713920574635267,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713920574635267,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",1892375756,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1920,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1920,"count":40,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713920574635267,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713920574635267,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",1892375756,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1920,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1920,"count":40,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713920574635267,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713920574635267,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",5275100,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005714035127311945,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713882390409708,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",2777597714,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1920,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1920,"count":40,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713920574635267,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713920574635267,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",1892375756,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1920,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1920,"count":40,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713920574635267,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713920574635267,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",2403014318,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713996943086386,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713844206184149,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",5275100,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005714035127311945,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713882390409708,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",2777597714,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1920,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1920,"count":40,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713920574635267,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713920574635267,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",1324010889,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713920574635267,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713920574635267,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",2535250265,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1920,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1920,"count":40,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713939666748047,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713901482522488,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",2972159383,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1920,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1920,"count":40,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713939666748047,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713901482522488,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",1114004834,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":21120,"length":2976,"count":1488,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":21120,"count":440,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.004550490528345108,-0.0432131253182888,-0.01454436220228672],"maxPosition",8,[1,0.004550490528345108,0.043213147670030594,0.09131286293268204]]],-1],0,0,[],[],[]],[[[5,".bin",1324010889,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713920574635267,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713920574635267,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[27],[28,"Road",[-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48,-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64],[4,"cfMJW5xYpVuoK2Tw8Ktwgb",null,null,null,-1,0]],[10,"Road_platform",1,[[7,-65,[8,"c3pQOIxsFabI6khxD9jt+k"],[0],[6],1]],[4,"174in2T2RdXYLyYCWkXPNA",null,null,null,1,0],[1,-24.2722225189209,-0.48971131443977356,0.35646775364875793],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_platform.001",1,[[7,-66,[8,"c4XBo46oFWf4a3VBLRWWlr"],[2],[6],3]],[4,"79PHaQWkhaN5AscoKnO1dO",null,null,null,1,0],[1,133.67799377441406,-0.48971131443977356,0.35646775364875793],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.001",1,[[7,-67,[8,"a6C6KCjdVcPKkSECiYFEJh"],[4],[6],5]],[4,"68CmGbTUxY7rwNbtgW37j2",null,null,null,1,0],[1,13.981903076171875,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.002",1,[[7,-68,[8,"aaV25eVo9fa7x43YKGNevS"],[6],[6],7]],[4,"e017n2Zs9WmaDOAv8mWnNA",null,null,null,1,0],[1,15.35324478149414,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.003",1,[[7,-69,[8,"18BokMJyVSg7rWAsrk2UqG"],[8],[6],9]],[4,"0a7xwy1QxaLaIphwQyeF1y",null,null,null,1,0],[1,16.724586486816406,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.004",1,[[7,-70,[8,"f68eYOHwBfyLxFu0ScZLCf"],[10],[6],11]],[4,"39MIHV9ElWvYBoJ+oFX8bE",null,null,null,1,0],[1,18.095928192138672,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.005",1,[[7,-71,[8,"72QksZQq9S068mBeal8tz4"],[12],[6],13]],[4,"09//qOYp5bKKgpUWLt25Vw",null,null,null,1,0],[1,19.467273712158203,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.006",1,[[7,-72,[8,"cd5oMPe6debYk+su6tMfL4"],[14],[6],15]],[4,"9aCmemyxBWdaU2cGuQxhZO",null,null,null,1,0],[1,20.838611602783203,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.007",1,[[7,-73,[8,"fckJ0IYs5WW7qe3VzM9gx9"],[16],[6],17]],[4,"92iKwNWlZZD7NMQED8mOhM",null,null,null,1,0],[1,22.2099552154541,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.008",1,[[7,-74,[8,"95FtueVM5c2Im51cW7uU7v"],[18],[6],19]],[4,"59ULJjIGZcGbMUPjxTmuTp",null,null,null,1,0],[1,23.581298828125,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.009",1,[[7,-75,[8,"07k9LwPyxTyKQYoAmmQDpW"],[20],[6],21]],[4,"49TMzHP79VV6m4zJcxR169",null,null,null,1,0],[1,24.9526424407959,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.010",1,[[7,-76,[8,"c1EWjlZJZeU5S0eIhBKp50"],[22],[6],23]],[4,"f7vyHBqoJdDI01QHjYTYhh",null,null,null,1,0],[1,26.32398223876953,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.011",1,[[7,-77,[8,"9ebsdjo25UJLbrURpoBJaJ"],[24],[6],25]],[4,"f0mAlqzuNelIyODhbEKubH",null,null,null,1,0],[1,27.695323944091797,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.012",1,[[7,-78,[8,"87x3wEp89R+qIdZm3wLjd+"],[26],[6],27]],[4,"04Pa9uyLZYWI+Wim9755ti",null,null,null,1,0],[1,29.066665649414062,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.013",1,[[7,-79,[8,"9f3sJOSn9XfpYoM2tejWJj"],[28],[6],29]],[4,"54L82Pf3Zb37rBqqJ23ixT",null,null,null,1,0],[1,30.438007354736328,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.014",1,[[7,-80,[8,"ebi7yefndZEIXXmNvImgbY"],[30],[6],31]],[4,"51TUgZjXtUnbeIG/dOkpqp",null,null,null,1,0],[1,31.809349060058594,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.015",1,[[7,-81,[8,"c79pQUpz5U+afYUntHBHGi"],[32],[6],33]],[4,"68C/+qfa5fYZvXdc2AMyye",null,null,null,1,0],[1,33.18069076538086,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.016",1,[[7,-82,[8,"00FdxST0xTGrOPk/I9UKSj"],[34],[6],35]],[4,"4aDi6TwTldjrmg6PxN0I/A",null,null,null,1,0],[1,34.552032470703125,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.017",1,[[7,-83,[8,"e07jGRWnxb4JhD/uD0/R35"],[36],[6],37]],[4,"fe8yzt6V1a/Kgzik1RPZay",null,null,null,1,0],[1,35.92337417602539,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.018",1,[[7,-84,[8,"abt5mo9odeMoajHTw5xiuD"],[38],[6],39]],[4,"31yMsjRSVagJ7G4p8lYE4N",null,null,null,1,0],[1,37.294715881347656,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.019",1,[[7,-85,[8,"8dOMI5ydRRAbguinJdjpwi"],[40],[6],41]],[4,"01N87SJ9BTMLgdYb+NTTJk",null,null,null,1,0],[1,38.66605758666992,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.020",1,[[7,-86,[8,"99t43/ISBdTKPyaE0piadU"],[42],[6],43]],[4,"3evOST169Y6ZvfZfd4I6eO",null,null,null,1,0],[1,40.03740310668945,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.021",1,[[7,-87,[8,"48N6EeY5RTqbWp+71WsPRG"],[44],[6],45]],[4,"d2FPj+XB1WzZt0msye8iJF",null,null,null,1,0],[1,41.40874099731445,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.022",1,[[7,-88,[8,"09QeNJM4FYvKXTyV9wgikc"],[46],[6],47]],[4,"6da0QoiGVfZ5m7vTxNahet",null,null,null,1,0],[1,42.78007888793945,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.023",1,[[7,-89,[8,"c1FDCI0VBf67pV2M//wMiA"],[48],[6],49]],[4,"917HCuE9Vau4TgLme+Lao7",null,null,null,1,0],[1,44.151424407958984,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.024",1,[[7,-90,[8,"790+b3lUZZIqR4WvYswEVy"],[50],[6],51]],[4,"66gYZ+5gpUMqelVAMgeAy9",null,null,null,1,0],[1,45.522762298583984,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.025",1,[[7,-91,[8,"f8Zp+o3C5a/K03CRPgADBz"],[52],[6],53]],[4,"86ODR2d/pVQL9R1ehCEDHK",null,null,null,1,0],[1,46.89411163330078,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.026",1,[[7,-92,[8,"62buzTZkFRdadXRJ2gZqwg"],[54],[6],55]],[4,"a98cWsU1dXA5GY/mu5pBsl",null,null,null,1,0],[1,48.26545333862305,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.027",1,[[7,-93,[8,"4a7ROze2FapJCIhC2YUZTw"],[56],[6],57]],[4,"b71bDfM2ZaFp7909W01eYU",null,null,null,1,0],[1,49.63679504394531,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.028",1,[[7,-94,[8,"fdQQZfHi5RjLmJXIoxI/aY"],[58],[6],59]],[4,"fd8R2GFCtZbogC4Vh+BLhm",null,null,null,1,0],[1,51.00813293457031,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.029",1,[[7,-95,[8,"9agmCp4HNXCK66agfCklHN"],[60],[6],61]],[4,"7blrd9kqxUna9jNHCkJGuV",null,null,null,1,0],[1,52.37947082519531,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.030",1,[[7,-96,[8,"45Ydr1HQhep5fAs1UwWTyi"],[62],[6],63]],[4,"5eMYy9p6pWbqLalq8tVcLK",null,null,null,1,0],[1,53.750816345214844,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.031",1,[[7,-97,[8,"5dxWctZ31e5Y35yoBti9FI"],[64],[6],65]],[4,"08sdhymO9aVYy8BwG/d+xC",null,null,null,1,0],[1,55.122154235839844,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.032",1,[[7,-98,[8,"0a/l9I+3FQFpZg+CWmIolg"],[66],[6],67]],[4,"45RfkiVMJdfbuyNb2mPW3a",null,null,null,1,0],[1,56.493499755859375,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.033",1,[[7,-99,[8,"58kx4DlV5VILwFLQv1t6oS"],[68],[6],69]],[4,"05QkCNkw5aNJdMGD4INznQ",null,null,null,1,0],[1,57.86484909057617,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.034",1,[[7,-100,[8,"13gal3Z0Fc37sITJwsOvLr"],[70],[6],71]],[4,"56McHCFMRYvo2J8lmq2cZg",null,null,null,1,0],[1,59.23618698120117,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.035",1,[[7,-101,[8,"56qzJobVZX076slNmCcwTp"],[72],[6],73]],[4,"c2W4U/ua1fl6R3dFANHNMt",null,null,null,1,0],[1,60.60752868652344,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.036",1,[[7,-102,[8,"f2Dn5+lyNfVLZ3LdCADWIM"],[74],[6],75]],[4,"c47yN71ANZBpb6dkoNK8bs",null,null,null,1,0],[1,61.97886657714844,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.037",1,[[7,-103,[8,"baxk4iw41QFJIuuiT+2ftQ"],[76],[6],77]],[4,"1fEw33tmNVfI8vGLxeb/+f",null,null,null,1,0],[1,63.3502082824707,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.038",1,[[7,-104,[8,"95JIWnJDZZsJovqXai1na2"],[78],[6],79]],[4,"c0+Fr1B1VaNZIl1yt3MduU",null,null,null,1,0],[1,64.72154235839844,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.039",1,[[7,-105,[8,"9dvjuRVk5WDbwws471Ibt8"],[80],[6],81]],[4,"5bU7kVtoxbspVr7Gk8f7yZ",null,null,null,1,0],[1,66.0928955078125,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.040",1,[[7,-106,[8,"092rRWqdxepbE0F9dOUNMA"],[82],[6],83]],[4,"bdxJAiTAVUMKyP8pxmADOS",null,null,null,1,0],[1,67.4642333984375,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.041",1,[[7,-107,[8,"070vxAeKtQN74aCg1K9I+u"],[84],[6],85]],[4,"d6A+6InPZYvpJW3IbS0Wl7",null,null,null,1,0],[1,68.8355712890625,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.042",1,[[7,-108,[8,"a2dtrXcNBYNKvtZ0JErqC8"],[86],[6],87]],[4,"a6gmn0v0tee5MUtTMQdLwY",null,null,null,1,0],[1,70.2069091796875,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.043",1,[[7,-109,[8,"c6MsPzcPVV9pI61Ztbtgfz"],[88],[6],89]],[4,"cfQpSEN8xfk67qfWWjW1IH",null,null,null,1,0],[1,71.57826232910156,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.044",1,[[7,-110,[8,"45rWKX9ohc3IsjVAR5VI/+"],[90],[6],91]],[4,"76dTysmbxbg47WUecSJoQj",null,null,null,1,0],[1,72.94960021972656,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.045",1,[[7,-111,[8,"d4t4JzvuBWUaYmDangq8uJ"],[92],[6],93]],[4,"50Tq9GjcVVVqNymvMtN0cz",null,null,null,1,0],[1,74.32093811035156,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.046",1,[[7,-112,[8,"33347IhbVbXZKkzJaqjsqe"],[94],[6],95]],[4,"dcuDgTMcRfqYbH5pIIu2Ay",null,null,null,1,0],[1,75.69229125976562,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.047",1,[[7,-113,[8,"2b1T7uy5BeeolfP6LMWMLi"],[96],[6],97]],[4,"dbnPDX5NBWjJy7EmzC3GIt",null,null,null,1,0],[1,77.06362915039062,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.048",1,[[7,-114,[8,"7csFZtriNXW5tvcbAlaKQd"],[98],[6],99]],[4,"42WhgU+BJTyqV6puSycqg8",null,null,null,1,0],[1,78.43496704101562,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.049",1,[[7,-115,[8,"6aXTP9grpR7aWFFcM3mXtV"],[100],[6],101]],[4,"b3jtrAIblWNrqzsR2c78ao",null,null,null,1,0],[1,79.80630493164062,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.050",1,[[7,-116,[8,"3am8O/YXxUALx9gscirHXV"],[102],[6],103]],[4,"4dIIAdVhBXcq7N2b8N7TWn",null,null,null,1,0],[1,81.17765808105469,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.051",1,[[7,-117,[8,"05QwwaqaJfpZB7lVNLHA4L"],[104],[6],105]],[4,"ccBYRoX7VarKrXnhMXtFED",null,null,null,1,0],[1,82.54901123046875,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.052",1,[[7,-118,[8,"99oMmIo0hTGqHR/UrAfPqX"],[106],[6],107]],[4,"e9JABiUQtRtY2OyVkJorTc",null,null,null,1,0],[1,83.92034912109375,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.053",1,[[7,-119,[8,"b0XIMFUCBZHZt4+Z5qX0rM"],[108],[6],109]],[4,"adJXQR9flTzoWz/Bg7Ik5j",null,null,null,1,0],[1,85.29170227050781,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.054",1,[[7,-120,[8,"0beRWLd1VavL1WP1ueAj4I"],[110],[6],111]],[4,"61R24SzvxT54Vl8seviC1G",null,null,null,1,0],[1,86.66304016113281,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.055",1,[[7,-121,[8,"63/2YSDNNVyZ7yOYJ8FkLw"],[112],[6],113]],[4,"afU6MobIhQmZEh2Sk+hfFJ",null,null,null,1,0],[1,88.03439331054688,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.056",1,[[7,-122,[8,"7341EgGxFQk7yIyeNedZyy"],[114],[6],115]],[4,"b3mpDzpEpb56d+jKXSFQXp",null,null,null,1,0],[1,89.40573120117188,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.057",1,[[7,-123,[8,"84RXF1GiZTmIuMWoJkv3NY"],[116],[6],117]],[4,"2dDR3p7lNdgozCgjbwrOvX",null,null,null,1,0],[1,90.77706909179688,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.058",1,[[7,-124,[8,"71vwpLlOBSrpia6Cpgl4yO"],[118],[6],119]],[4,"60in0+6NBcH4IdvipP/F4e",null,null,null,1,0],[1,92.1484146118164,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.059",1,[[7,-125,[8,"bbHMx8xyNd+5hV/6y70lWt"],[120],[6],121]],[4,"57eKjcMiJWVowgMiQs1lai",null,null,null,1,0],[1,93.519775390625,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"Road_Block_Wood.060",1,[[7,-126,[8,"08pmMECJRUy4LaQ7mKvxXr"],[122],[6],123]],[4,"aafTGYFhBZt72NQVleFbB0",null,null,null,1,0],[1,94.89111328125,-0.5190486907958984,1.646716594696045],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]],[10,"finish",1,[[7,-127,[8,"2fKjmeARlTMo3EolQhv2BU"],[124],[6],125]],[4,"cbblX3QndZeqahDdj6FBRx",null,null,null,1,0],[1,165.87115478515625,1.1004533767700195,0.16646458208560944],[3,-0.7071068407911908,0,0,0.7071067215818992],[1,100,100,100],[1,-90.00000965934633,0,0]]],0,[0,4,1,0,-1,2,0,-2,3,0,-3,4,0,-4,5,0,-5,6,0,-6,7,0,-7,8,0,-8,9,0,-9,10,0,-10,11,0,-11,12,0,-12,13,0,-13,14,0,-14,15,0,-15,16,0,-16,17,0,-17,18,0,-18,19,0,-19,20,0,-20,21,0,-21,22,0,-22,23,0,-23,24,0,-24,25,0,-25,26,0,-26,27,0,-27,28,0,-28,29,0,-29,30,0,-30,31,0,-31,32,0,-32,33,0,-33,34,0,-34,35,0,-35,36,0,-36,37,0,-37,38,0,-38,39,0,-39,40,0,-40,41,0,-41,42,0,-42,43,0,-43,44,0,-44,45,0,-45,46,0,-46,47,0,-47,48,0,-48,49,0,-49,50,0,-50,51,0,-51,52,0,-52,53,0,-53,54,0,-54,55,0,-55,56,0,-56,57,0,-57,58,0,-58,59,0,-59,60,0,-60,61,0,-61,62,0,-62,63,0,-63,64,0,0,2,0,0,3,0,0,4,0,0,5,0,0,6,0,0,7,0,0,8,0,0,9,0,0,10,0,0,11,0,0,12,0,0,13,0,0,14,0,0,15,0,0,16,0,0,17,0,0,18,0,0,19,0,0,20,0,0,21,0,0,22,0,0,23,0,0,24,0,0,25,0,0,26,0,0,27,0,0,28,0,0,29,0,0,30,0,0,31,0,0,32,0,0,33,0,0,34,0,0,35,0,0,36,0,0,37,0,0,38,0,0,39,0,0,40,0,0,41,0,0,42,0,0,43,0,0,44,0,0,45,0,0,46,0,0,47,0,0,48,0,0,49,0,0,50,0,0,51,0,0,52,0,0,53,0,0,54,0,0,55,0,0,56,0,0,57,0,0,58,0,0,59,0,0,60,0,0,61,0,0,62,0,0,63,0,0,64,0,11,1,127],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2,-1,2],[0,33,0,34,0,35,0,36,0,37,0,38,0,39,0,40,0,41,0,42,0,43,0,44,0,45,0,46,0,47,0,48,0,49,0,50,0,51,0,52,0,53,0,54,0,55,0,56,0,57,0,58,0,59,0,60,0,61,0,62,0,63,0,64,0,65,0,66,0,67,0,68,0,69,0,70,0,71,0,72,0,73,0,74,0,75,0,76,0,77,0,78,0,79,0,80,0,81,0,82,0,83,0,84,0,85,0,86,0,87,0,88,0,89,0,90,0,91,0,92,0,93,0,94,0,95]],[[[5,".bin",2777597714,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1920,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1920,"count":40,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713920574635267,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713920574635267,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",1324010889,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713920574635267,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713920574635267,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",2326861036,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0057139587588608265,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713882390409708,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",2326861036,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0057139587588608265,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713882390409708,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",165854048,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0057139587588608265,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.0057139587588608265,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",1892375756,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1920,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1920,"count":40,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713920574635267,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713920574635267,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",4101559315,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1920,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1920,"count":40,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713935010135174,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713920574635267,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",1324010889,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713920574635267,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713920574635267,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",2326861036,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0057139587588608265,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713882390409708,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",1324010889,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713920574635267,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713920574635267,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",1892375756,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1920,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1920,"count":40,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713920574635267,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713920574635267,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",2844174167,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1920,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1920,"count":40,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.00571392523124814,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.00571392523124814,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",5275100,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005714035127311945,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713882390409708,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",165854048,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0057139587588608265,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.0057139587588608265,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",2972159383,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1920,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1920,"count":40,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713939666748047,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713901482522488,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",1711968438,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713882390409708,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.0057139587588608265,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",2162795612,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":8736,"length":624,"count":312,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":8736,"count":182,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.3811908960342407,-0.04228263720870018,-0.042704466730356216],"maxPosition",8,[1,1.1521592140197754,0.045616813004016876,0.006066021975129843]]],-1],0,0,[],[],[]],[[[5,".bin",1766174321,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1920,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1920,"count":40,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0057139587588608265,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713882390409708,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",1324010889,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713920574635267,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713920574635267,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",1324010889,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713920574635267,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713920574635267,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",165854048,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0057139587588608265,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.0057139587588608265,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[24,"Material",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"DCC_APP_NAME":2,"HAS_EXPORTED_METALLIC":true,"USE_ALBEDO_MAP":true}],[[[{"shininessExponent":25,"emissiveScale":1,"metallic":0,"specularFactor":0.25,"transparencyFactor":0},"mainColor",8,[4,4293388263],"emissive",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[9,10],[96,4]],[[[5,".bin",1711968438,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713882390409708,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.0057139587588608265,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",5275100,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005714035127311945,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713882390409708,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",3829254222,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1920,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1920,"count":40,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713920574635267,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713930353522301,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",1324010889,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713920574635267,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713920574635267,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",5275100,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005714035127311945,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713882390409708,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",1711968438,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713882390409708,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.0057139587588608265,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",165854048,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0057139587588608265,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.0057139587588608265,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",2844174167,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1920,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1920,"count":40,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.00571392523124814,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.00571392523124814,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",2844174167,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1920,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1920,"count":40,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.00571392523124814,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.00571392523124814,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",1639486056,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1920,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1920,"count":40,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713901482522488,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713939666748047,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",1892375756,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1920,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1920,"count":40,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713920574635267,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713920574635267,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",165854048,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0057139587588608265,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.0057139587588608265,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",2777597714,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1920,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1920,"count":40,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713920574635267,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713920574635267,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",1711968438,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005713882390409708,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.0057139587588608265,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",165854048,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0057139587588608265,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.0057139587588608265,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[[5,".bin",5275100,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":120,"count":60,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005714035127311945,-0.029127974063158035,-0.00571392523124814],"maxPosition",8,[1,0.005713882390409708,0.05825594812631607,0.00571392523124814]]],-1],0,0,[],[],[]],[[{"name":"hand","rect":{"x":0,"y":0,"width":323,"height":305},"offset":{"x":0,"y":0},"originalSize":{"width":323,"height":305},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-161.5,-152.5,0,161.5,-152.5,0,-161.5,152.5,0,161.5,152.5,0],"indexes":[0,1,2,2,1,3],"uv":[0,305,323,305,0,0,323,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-161.5,"y":-152.5,"z":0},"maxPos":{"x":161.5,"y":152.5,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[2],0,[0],[6],[97]],[[{"base":"2,2,0,0,2,0","rgbe":true,"mipmaps":[{"front":"d0MqyYBeFAkIi762QNy1/B@b47c0@e9a6d","back":"d0MqyYBeFAkIi762QNy1/B@b47c0@40c10","left":"d0MqyYBeFAkIi762QNy1/B@b47c0@8fd34","right":"d0MqyYBeFAkIi762QNy1/B@b47c0@74afd","top":"d0MqyYBeFAkIi762QNy1/B@b47c0@bb97f","bottom":"d0MqyYBeFAkIi762QNy1/B@b47c0@7d38f"}]}],[7],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[[57,"scene"],[39,"Player","d7dn0bux1FXrTrhRcL0q4m",[-6],[[58,13.4,-3,-2,-1],[59,-4,[1,0,2,0],[1,5.574,4.162,4.625]],[63,10,-5]],[1,0,0.20000000298023224,0]],[40,"Coin",33554432,[[31,-7,[5,91,90],[0,0.7,0.4]],[25,-8,8]],[1,1257.567,867.793,0],[1,1.4,1.4,1]],[41,"Coins","e5zDV52iVOEpQW0G3OMC7s",[-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37]],[42,"Canvas",33554432,"8aBw5v01xGK6aaqYXy8fBP",[-42,-43,-44,-45,-46,-47,-48],[[21,-38,[5,960,640]],[68,-40,-39],[69,320.00000000000006,320,960,-41]],[1,480,320,0]],[70,"scene",[-80,-81,1,-82,4,3,-83],[54,null,null,"f46876e4-e81b-4931-b493-6d367be385e7",null,null,[-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72,-73,-74,-75,-76,-77,-78,-79]],[71,[72,0.8,[2,0.2,0.5,0.8,0.520833125],[2,0.452588,0.607642,0.755699,0],[2,0.618555,0.577848,0.544564,0]],[73,[4,4283190348]],[74,true,107,108],[75],[76],[77]]],[51,"FailScreen",33554432,4,[-87,-88,-89],[[[21,-84,[5,960,640]],[36,45,100,100,-85],-86],4,4,1]],[33,"Download",33554432,4,[[31,-90,[5,100,40],[0,4.8,8]],[32,1,0,-91,5],[37,2,-93,[4,4292269782],-92,6,7],[79,-94]]],[34,"Button",33554432,6,[[21,-95,[5,100,40]],[32,1,0,-96,14],[37,2,-98,[4,4292269782],-97,15,16]],[1,0,-150.583,0],[1,0,0,0]],[52,"Slider",33554432,4,[-102],[[[21,-99,[5,20,300]],[32,1,0,-100,4],-101],4,4,1],[1,342.36,-114.706,0],[1,5,0.7,1]],[35,"Handle",33554432,9,[[[21,-103,[5,300,20]],-104,[78,-106,[4,4292269782],-105,3]],4,1,4],[1,0,-150,0],[1,0.1,5,1]],[43,"Sprite",33554432,[2,-109],[[31,-107,[5,413,197],[0,-2.7,-4]],[25,-108,9]],[1,0.3,0.3,1]],[33,"BG",33554432,6,[[21,-110,[5,960,640]],[65,0,-111,[4,2516582400],12],[36,45,40,36,-112]]],[14,0,null,3,[15,"0auORVX99QSYHjxYweQevA",null,null,-120,[16,"95zKZiHetLQY0+3niMPSQo",null,[[3,[0,["0auORVX99QSYHjxYweQevA"]],[[18,-118,1,2],[17,true,-119,[1,0.8,0.8,0.8]]]]],[[19,"Coin",["_name"],-113],[2,["_lpos"],-114,[1,54,2.5,0]],[2,["_lrot"],-115,[3,0,0,0,1]],[2,["_euler"],-116,[1,0,0,0]],[2,["_lscale"],-117,[1,2,2,2]]]],78]],[0,["0auORVX99QSYHjxYweQevA"]],[14,0,null,3,[15,"0auORVX99QSYHjxYweQevA",null,null,-128,[16,"0eH6M8i0RM/LutqyohRaEu",null,[[3,[0,["0auORVX99QSYHjxYweQevA"]],[[18,-126,1,2],[17,true,-127,[1,0.8,0.8,0.8]]]]],[[19,"Coin-001",["_name"],-121],[2,["_lpos"],-122,[1,56.74,2.5,0]],[2,["_lrot"],-123,[3,0,0,0,1]],[2,["_euler"],-124,[1,0,0,0]],[2,["_lscale"],-125,[1,2,2,2]]]],79]],[0,["0auORVX99QSYHjxYweQevA"]],[14,0,null,3,[15,"0auORVX99QSYHjxYweQevA",null,null,-136,[16,"48khy/xaBElIOCD0eKU8mE",null,[[3,[0,["0auORVX99QSYHjxYweQevA"]],[[18,-134,1,2],[17,true,-135,[1,0.8,0.8,0.8]]]]],[[19,"Coin-002",["_name"],-129],[2,["_lpos"],-130,[1,59.511,2.5,0]],[2,["_lrot"],-131,[3,0,0,0,1]],[2,["_euler"],-132,[1,0,0,0]],[2,["_lscale"],-133,[1,2,2,2]]]],80]],[0,["0auORVX99QSYHjxYweQevA"]],[14,0,null,3,[15,"0auORVX99QSYHjxYweQevA",null,null,-144,[16,"cc1sJMhjFKw5bNfOUlMV/X",null,[[3,[0,["0auORVX99QSYHjxYweQevA"]],[[18,-142,1,2],[17,true,-143,[1,0.8,0.8,0.8]]]]],[[19,"Coin-003",["_name"],-137],[2,["_lpos"],-138,[1,62.219,2.5,0]],[2,["_lrot"],-139,[3,0,0,0,1]],[2,["_euler"],-140,[1,0,0,0]],[2,["_lscale"],-141,[1,2,2,2]]]],81]],[0,["0auORVX99QSYHjxYweQevA"]],[14,0,null,3,[15,"0auORVX99QSYHjxYweQevA",null,null,-152,[16,"22zGM1H69BHrJCG+dWBn9J",null,[[3,[0,["0auORVX99QSYHjxYweQevA"]],[[18,-150,1,2],[17,true,-151,[1,0.8,0.8,0.8]]]]],[[19,"Coin-004",["_name"],-145],[2,["_lpos"],-146,[1,64.959,2.5,0]],[2,["_lrot"],-147,[3,0,0,0,1]],[2,["_euler"],-148,[1,0,0,0]],[2,["_lscale"],-149,[1,2,2,2]]]],82]],[0,["0auORVX99QSYHjxYweQevA"]],[14,0,null,3,[15,"0auORVX99QSYHjxYweQevA",null,null,-160,[16,"9aSzYh3P1Br6W0dAV8bwz9",null,[[3,[0,["0auORVX99QSYHjxYweQevA"]],[[18,-158,1,2],[17,true,-159,[1,0.8,0.8,0.8]]]]],[[19,"Coin-005",["_name"],-153],[2,["_lpos"],-154,[1,67.784,2.5,0]],[2,["_lrot"],-155,[3,0,0,0,1]],[2,["_euler"],-156,[1,0,0,0]],[2,["_lscale"],-157,[1,2,2,2]]]],83]],[0,["0auORVX99QSYHjxYweQevA"]],[14,0,null,3,[15,"0auORVX99QSYHjxYweQevA",null,null,-168,[16,"1e9oNrPLlLHriGJAeLoLWj",null,[[3,[0,["0auORVX99QSYHjxYweQevA"]],[[18,-166,1,2],[17,true,-167,[1,0.8,0.8,0.8]]]]],[[19,"Coin-006",["_name"],-161],[2,["_lpos"],-162,[1,70.486,2.5,0]],[2,["_lrot"],-163,[3,0,0,0,1]],[2,["_euler"],-164,[1,0,0,0]],[2,["_lscale"],-165,[1,2,2,2]]]],84]],[0,["0auORVX99QSYHjxYweQevA"]],[14,0,null,3,[15,"0auORVX99QSYHjxYweQevA",null,null,-176,[16,"b3A7apbdBFJY6Ec1xdgNOx",null,[[3,[0,["0auORVX99QSYHjxYweQevA"]],[[18,-174,1,2],[17,true,-175,[1,0.8,0.8,0.8]]]]],[[19,"Coin-007",["_name"],-169],[2,["_lpos"],-170,[1,73.113,2.5,0]],[2,["_lrot"],-171,[3,0,0,0,1]],[2,["_euler"],-172,[1,0,0,0]],[2,["_lscale"],-173,[1,2,2,2]]]],85]],[0,["0auORVX99QSYHjxYweQevA"]],[14,0,null,3,[15,"0auORVX99QSYHjxYweQevA",null,null,-184,[16,"2aRU0PzVlGtY+bLYNHX648",null,[[3,[0,["0auORVX99QSYHjxYweQevA"]],[[18,-182,1,2],[17,true,-183,[1,0.8,0.8,0.8]]]]],[[19,"Coin-008",["_name"],-177],[2,["_lpos"],-178,[1,75.965,2.5,0]],[2,["_lrot"],-179,[3,0,0,0,1]],[2,["_euler"],-180,[1,0,0,0]],[2,["_lscale"],-181,[1,2,2,2]]]],86]],[0,["0auORVX99QSYHjxYweQevA"]],[14,0,null,3,[15,"0auORVX99QSYHjxYweQevA",null,null,-192,[16,"2fnezmYJ1E8Z/gaK0LtDKr",null,[[3,[0,["0auORVX99QSYHjxYweQevA"]],[[18,-190,1,2],[17,true,-191,[1,0.8,0.8,0.8]]]]],[[19,"Coin-009",["_name"],-185],[2,["_lpos"],-186,[1,78.817,2.5,0]],[2,["_lrot"],-187,[3,0,0,0,1]],[2,["_euler"],-188,[1,0,0,0]],[2,["_lscale"],-189,[1,2,2,2]]]],87]],[0,["0auORVX99QSYHjxYweQevA"]],[14,0,null,3,[15,"0auORVX99QSYHjxYweQevA",null,null,-200,[16,"fbIyeM4M9NzJ01k/7bWUfx",null,[[3,[0,["0auORVX99QSYHjxYweQevA"]],[[18,-198,1,2],[17,true,-199,[1,0.8,0.8,0.8]]]]],[[19,"Coin-010",["_name"],-193],[2,["_lpos"],-194,[1,81.519,2.5,0]],[2,["_lrot"],-195,[3,0,0,0,1]],[2,["_euler"],-196,[1,0,0,0]],[2,["_lscale"],-197,[1,2,2,2]]]],88]],[0,["0auORVX99QSYHjxYweQevA"]],[14,0,null,3,[15,"0auORVX99QSYHjxYweQevA",null,null,-208,[16,"7fAhMYmlJHtJxyFqB8p5n7",null,[[3,[0,["0auORVX99QSYHjxYweQevA"]],[[18,-206,1,2],[17,true,-207,[1,0.8,0.8,0.8]]]]],[[19,"Coin-011",["_name"],-201],[2,["_lpos"],-202,[1,84.296,2.5,0]],[2,["_lrot"],-203,[3,0,0,0,1]],[2,["_euler"],-204,[1,0,0,0]],[2,["_lscale"],-205,[1,2,2,2]]]],89]],[0,["0auORVX99QSYHjxYweQevA"]],[14,0,null,3,[15,"0auORVX99QSYHjxYweQevA",null,null,-216,[16,"fbU007scJGFrmChVktYWUj",null,[[3,[0,["0auORVX99QSYHjxYweQevA"]],[[18,-214,1,2],[17,true,-215,[1,0.8,0.8,0.8]]]]],[[19,"Coin-012",["_name"],-209],[2,["_lpos"],-210,[1,86.923,2.5,0]],[2,["_lrot"],-211,[3,0,0,0,1]],[2,["_euler"],-212,[1,0,0,0]],[2,["_lscale"],-213,[1,2,2,2]]]],90]],[0,["0auORVX99QSYHjxYweQevA"]],[14,0,null,3,[15,"0auORVX99QSYHjxYweQevA",null,null,-224,[16,"80hEUNjDRI7r3jGU0hGd8l",null,[[3,[0,["0auORVX99QSYHjxYweQevA"]],[[18,-222,1,2],[17,true,-223,[1,0.8,0.8,0.8]]]]],[[19,"Coin-013",["_name"],-217],[2,["_lpos"],-218,[1,89.662,2.5,0]],[2,["_lrot"],-219,[3,0,0,0,1]],[2,["_euler"],-220,[1,0,0,0]],[2,["_lscale"],-221,[1,2,2,2]]]],91]],[0,["0auORVX99QSYHjxYweQevA"]],[14,0,null,3,[15,"0auORVX99QSYHjxYweQevA",null,null,-232,[16,"9aA13RHgJK2brbDsNoevUh",null,[[3,[0,["0auORVX99QSYHjxYweQevA"]],[[18,-230,1,2],[17,true,-231,[1,0.8,0.8,0.8]]]]],[[19,"Coin-014",["_name"],-225],[2,["_lpos"],-226,[1,92.463,2.5,0]],[2,["_lrot"],-227,[3,0,0,0,1]],[2,["_euler"],-228,[1,0,0,0]],[2,["_lscale"],-229,[1,2,2,2]]]],92]],[0,["0auORVX99QSYHjxYweQevA"]],[14,0,null,3,[15,"0auORVX99QSYHjxYweQevA",null,null,-240,[16,"b6L9orTYhEv4C2U9tuBB/i",null,[[3,[0,["0auORVX99QSYHjxYweQevA"]],[[18,-238,1,2],[17,true,-239,[1,0.8,0.8,0.8]]]]],[[19,"Coin-015",["_name"],-233],[2,["_lpos"],-234,[1,95.202,2.5,0]],[2,["_lrot"],-235,[3,0,0,0,1]],[2,["_euler"],-236,[1,0,0,0]],[2,["_lscale"],-237,[1,2,2,2]]]],93]],[0,["0auORVX99QSYHjxYweQevA"]],[14,0,null,3,[15,"0auORVX99QSYHjxYweQevA",null,null,-248,[16,"423WjKlOBNgoPH+uuC0mtp",null,[[3,[0,["0auORVX99QSYHjxYweQevA"]],[[18,-246,1,2],[17,true,-247,[1,0.8,0.8,0.8]]]]],[[19,"Coin-016",["_name"],-241],[2,["_lpos"],-242,[1,98.065,2.5,0]],[2,["_lrot"],-243,[3,0,0,0,1]],[2,["_euler"],-244,[1,0,0,0]],[2,["_lscale"],-245,[1,2,2,2]]]],94]],[0,["0auORVX99QSYHjxYweQevA"]],[14,0,null,3,[15,"0auORVX99QSYHjxYweQevA",null,null,-256,[16,"9fM1/P1FFKiLBiVKxB8kkG",null,[[3,[0,["0auORVX99QSYHjxYweQevA"]],[[18,-254,1,2],[17,true,-255,[1,0.8,0.8,0.8]]]]],[[19,"Coin-017",["_name"],-249],[2,["_lpos"],-250,[1,100.679,2.5,0]],[2,["_lrot"],-251,[3,0,0,0,1]],[2,["_euler"],-252,[1,0,0,0]],[2,["_lscale"],-253,[1,2,2,2]]]],95]],[0,["0auORVX99QSYHjxYweQevA"]],[14,0,null,3,[15,"0auORVX99QSYHjxYweQevA",null,null,-264,[16,"9f+H+LhTZLDJcB14Gtls99",null,[[3,[0,["0auORVX99QSYHjxYweQevA"]],[[18,-262,1,2],[17,true,-263,[1,0.8,0.8,0.8]]]]],[[19,"Coin-018",["_name"],-257],[2,["_lpos"],-258,[1,103.48,2.5,0]],[2,["_lrot"],-259,[3,0,0,0,1]],[2,["_euler"],-260,[1,0,0,0]],[2,["_lscale"],-261,[1,2,2,2]]]],96]],[0,["0auORVX99QSYHjxYweQevA"]],[14,0,null,3,[15,"0auORVX99QSYHjxYweQevA",null,null,-272,[16,"3ar0Mw5l1PM7mJqdiSwCph",null,[[3,[0,["0auORVX99QSYHjxYweQevA"]],[[18,-270,1,2],[17,true,-271,[1,0.8,0.8,0.8]]]]],[[19,"Coin-019",["_name"],-265],[2,["_lpos"],-266,[1,106.343,2.5,0]],[2,["_lrot"],-267,[3,0,0,0,1]],[2,["_euler"],-268,[1,0,0,0]],[2,["_lscale"],-269,[1,2,2,2]]]],97]],[0,["0auORVX99QSYHjxYweQevA"]],[14,0,null,3,[15,"0auORVX99QSYHjxYweQevA",null,null,-280,[16,"00FiAXRe1FxY3ZQ3zpS8Ra",null,[[3,[0,["0auORVX99QSYHjxYweQevA"]],[[18,-278,1,2],[17,true,-279,[1,0.8,0.8,0.8]]]]],[[19,"Coin-020",["_name"],-273],[2,["_lpos"],-274,[1,108.957,2.5,0]],[2,["_lrot"],-275,[3,0,0,0,1]],[2,["_euler"],-276,[1,0,0,0]],[2,["_lscale"],-277,[1,2,2,2]]]],98]],[0,["0auORVX99QSYHjxYweQevA"]],[14,0,null,3,[15,"0auORVX99QSYHjxYweQevA",null,null,-288,[16,"06lxNBYeRHiqYg7BYzu9O+",null,[[3,[0,["0auORVX99QSYHjxYweQevA"]],[[18,-286,1,2],[17,true,-287,[1,0.8,0.8,0.8]]]]],[[19,"Coin-021",["_name"],-281],[2,["_lpos"],-282,[1,111.633,2.5,0]],[2,["_lrot"],-283,[3,0,0,0,1]],[2,["_euler"],-284,[1,0,0,0]],[2,["_lscale"],-285,[1,2,2,2]]]],99]],[0,["0auORVX99QSYHjxYweQevA"]],[14,0,null,3,[15,"0auORVX99QSYHjxYweQevA",null,null,-296,[16,"180SFPWUhB/rdFUMJeui1/",null,[[3,[0,["0auORVX99QSYHjxYweQevA"]],[[18,-294,1,2],[17,true,-295,[1,0.8,0.8,0.8]]]]],[[19,"Coin-022",["_name"],-289],[2,["_lpos"],-290,[1,114.372,2.5,0]],[2,["_lrot"],-291,[3,0,0,0,1]],[2,["_euler"],-292,[1,0,0,0]],[2,["_lscale"],-293,[1,2,2,2]]]],100]],[0,["0auORVX99QSYHjxYweQevA"]],[14,0,null,3,[15,"0auORVX99QSYHjxYweQevA",null,null,-304,[16,"c8HnogoC5L1pFWiQv7APlp",null,[[3,[0,["0auORVX99QSYHjxYweQevA"]],[[18,-302,1,2],[17,true,-303,[1,0.8,0.8,0.8]]]]],[[19,"Coin-023",["_name"],-297],[2,["_lpos"],-298,[1,117.173,2.5,0]],[2,["_lrot"],-299,[3,0,0,0,1]],[2,["_euler"],-300,[1,0,0,0]],[2,["_lscale"],-301,[1,2,2,2]]]],101]],[0,["0auORVX99QSYHjxYweQevA"]],[14,0,null,3,[15,"0auORVX99QSYHjxYweQevA",null,null,-312,[16,"edvatk9pVMaYaE3oS3cPgT",null,[[3,[0,["0auORVX99QSYHjxYweQevA"]],[[18,-310,1,2],[17,true,-311,[1,0.8,0.8,0.8]]]]],[[19,"Coin-024",["_name"],-305],[2,["_lpos"],-306,[1,119.912,2.5,0]],[2,["_lrot"],-307,[3,0,0,0,1]],[2,["_euler"],-308,[1,0,0,0]],[2,["_lscale"],-309,[1,2,2,2]]]],102]],[0,["0auORVX99QSYHjxYweQevA"]],[14,0,null,3,[15,"0auORVX99QSYHjxYweQevA",null,null,-320,[16,"0a73aZzw9LcpkoJgtYZm+2",null,[[3,[0,["0auORVX99QSYHjxYweQevA"]],[[18,-318,1,2],[17,true,-319,[1,0.8,0.8,0.8]]]]],[[19,"Coin-025",["_name"],-313],[2,["_lpos"],-314,[1,122.775,2.5,0]],[2,["_lrot"],-315,[3,0,0,0,1]],[2,["_euler"],-316,[1,0,0,0]],[2,["_lscale"],-317,[1,2,2,2]]]],103]],[0,["0auORVX99QSYHjxYweQevA"]],[14,0,null,3,[15,"0auORVX99QSYHjxYweQevA",null,null,-328,[16,"2fq78XFKdKWLPHvFHn/jlc",null,[[3,[0,["0auORVX99QSYHjxYweQevA"]],[[18,-326,1,2],[17,true,-327,[1,0.8,0.8,0.8]]]]],[[19,"Coin-026",["_name"],-321],[2,["_lpos"],-322,[1,125.265,2.5,0]],[2,["_lrot"],-323,[3,0,0,0,1]],[2,["_euler"],-324,[1,0,0,0]],[2,["_lscale"],-325,[1,2,2,2]]]],104]],[0,["0auORVX99QSYHjxYweQevA"]],[14,0,null,3,[15,"0auORVX99QSYHjxYweQevA",null,null,-336,[16,"c46/lloepMb5MB4kBZ5Wj+",null,[[3,[0,["0auORVX99QSYHjxYweQevA"]],[[18,-334,1,2],[17,true,-335,[1,0.8,0.8,0.8]]]]],[[19,"Coin-027",["_name"],-329],[2,["_lpos"],-330,[1,128.004,2.5,0]],[2,["_lrot"],-331,[3,0,0,0,1]],[2,["_euler"],-332,[1,0,0,0]],[2,["_lscale"],-333,[1,2,2,2]]]],105]],[0,["0auORVX99QSYHjxYweQevA"]],[14,0,null,3,[15,"0auORVX99QSYHjxYweQevA",null,null,-344,[16,"23u9LXIX5Gvr5UBbZ0bZgZ",null,[[3,[0,["0auORVX99QSYHjxYweQevA"]],[[18,-342,1,2],[17,true,-343,[1,0.8,0.8,0.8]]]]],[[19,"Coin-028",["_name"],-337],[2,["_lpos"],-338,[1,130.805,2.5,0]],[2,["_lrot"],-339,[3,0,0,0,1]],[2,["_euler"],-340,[1,0,0,0]],[2,["_lscale"],-341,[1,2,2,2]]]],106]],[0,["0auORVX99QSYHjxYweQevA"]],[44,"Main Camera","c9DMICJLFO5IeO07EPon7U",5,[-347],[[80,320,8,100,14,1822425087,-345],[82,-346,1]],[1,-7,18,18],[3,-0.29466904175699526,-0.1901405784893418,-0.05995109411443877,0.9345708012538345],[1,-35,-23,0]],[14,0,null,1,[15,"49a8W2zvZfgr1zEqsbBaOz",null,null,-348,[16,"f9ZK8OhkJMFaWl0uTCFFpy",null,[[3,[0,["10oEl8O1NQMacI5L07QkB8"]],[[26],[22],[23,false]]],[3,[0,["30va3S0MJRBL/NWb8qsxhl"]],[[26],[22],[23,false]]],[3,[0,["e6/3LWKVNU05AjXD78GcGv"]],[[26],[22],[23,false]]],[3,[0,["cdNJVFvClX4ItcUiMxUUin"]],[[26],[22],[23,false]]],[3,[0,["068EkwN11cxJ+L8nUkCGRs"]],[[83],[22],[30,false,[1,-1.1,0,0]]]],[3,[0,["a1hh3Bd/JeTYYHQERiuzbx"]],[[22],[30,false,[1,0,0,-2]]]],[3,[0,["01ceRmE4JSHLHbfvkONyp7"]],[[22],[30,false,[1,0,0,-2]]]],[3,[0,["911KGRN5Ve8qCRJtNs3937"]],[[22],[23,false]]],[3,[0,["a66izsailSfb9RmuTN/Yaa"]],[[22],[23,false]]],[3,[0,["7amRIjUV9fsL981+WEK4Ho"]],[[22],[23,false]]]],[[9,"Machine_",["_name"],[0,["49a8W2zvZfgr1zEqsbBaOz"]]],[1,["_lpos"],[0,["49a8W2zvZfgr1zEqsbBaOz"]],[1,0,0,0]],[1,["_lrot"],[0,["49a8W2zvZfgr1zEqsbBaOz"]],[3,0,0,0,1]],[1,["_euler"],[0,["49a8W2zvZfgr1zEqsbBaOz"]],[1,0,0,0]],[1,["_lpos"],[0,["10oEl8O1NQMacI5L07QkB8"]],[1,-2.639,1.04,-2.038]]]],2]],[29,"TutorialHand",33554432,4,[[21,-349,[5,90,90]],[66,0,-350,11]],[1,373.635,-249.108,0]],[29,"Sprite",33554432,6,[[21,-351,[5,315,315]],[25,-352,13]],[1,0,100,0]],[45,"BG",71,[[55,"Plane<ModelComponent>",-353,[0],[6],1],[84,false,-354,1]],[1,19.96768431005519,7.456919381743808,-50.80074641157955],[3,0.7782460313108241,0.16968507611627,-0.1287979829806406,0.5907208894837611],[1,10,0.9999999999999998,10],[1,104.24438258930631,23.796052361496667,6.427515122096669]],[46,"Coin",33554432,4,[11],[[64,-355]]],[35,"Label",33554432,11,[[[21,-356,[5,50.05,113.4]],-357],4,1],[1,1400,890,0],[1,1.2,1,1]],[34,"Sprite",33554432,4,[[21,-358,[5,366,202]],[25,-359,10]],[1,-370,250,0],[1,0.5,0.5,1]],[47,"Road",1,"a4Us2ttFhIda4wwMjTe6c5",5,[-360,-361],[1,37.3,0,0]],[14,0,null,79,[15,"cfMJW5xYpVuoK2Tw8Ktwgb",null,null,-362,[16,"76bVJ0e61D9qWpv18SeNGH",null,[[3,[0,["aafTGYFhBZt72NQVleFbB0"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],18],[12,2,10],[13]]],[3,[0,["174in2T2RdXYLyYCWkXPNA"]],[[60,[1,0.751,0.077,0.01]]]],[3,[0,["79PHaQWkhaN5AscoKnO1dO"]],[[61,[1,0.385,0,0],[1,1.532,0.1,0.01]]]],[3,[0,["68CmGbTUxY7rwNbtgW37j2"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],19],[12,2,10],[13]]],[3,[0,["57eKjcMiJWVowgMiQs1lai"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],20],[12,2,10],[13]]],[3,[0,["60in0+6NBcH4IdvipP/F4e"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],21],[12,2,10],[13]]],[3,[0,["2dDR3p7lNdgozCgjbwrOvX"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],22],[12,2,10],[13]]],[3,[0,["b3mpDzpEpb56d+jKXSFQXp"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],23],[12,2,10],[13]]],[3,[0,["afU6MobIhQmZEh2Sk+hfFJ"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],24],[12,2,10],[13]]],[3,[0,["61R24SzvxT54Vl8seviC1G"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],25],[12,2,10],[13]]],[3,[0,["adJXQR9flTzoWz/Bg7Ik5j"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],26],[12,2,10],[13]]],[3,[0,["e9JABiUQtRtY2OyVkJorTc"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],27],[12,2,10],[13]]],[3,[0,["ccBYRoX7VarKrXnhMXtFED"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],28],[12,2,10],[13]]],[3,[0,["4dIIAdVhBXcq7N2b8N7TWn"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],29],[12,2,10],[13]]],[3,[0,["b3jtrAIblWNrqzsR2c78ao"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],30],[12,2,10],[13]]],[3,[0,["42WhgU+BJTyqV6puSycqg8"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],31],[12,2,10],[13]]],[3,[0,["dbnPDX5NBWjJy7EmzC3GIt"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],32],[12,2,10],[13]]],[3,[0,["dcuDgTMcRfqYbH5pIIu2Ay"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],33],[12,2,10],[13]]],[3,[0,["50Tq9GjcVVVqNymvMtN0cz"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],34],[12,2,10],[13]]],[3,[0,["76dTysmbxbg47WUecSJoQj"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],35],[12,2,10],[13]]],[3,[0,["cfQpSEN8xfk67qfWWjW1IH"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],36],[12,2,10],[13]]],[3,[0,["a6gmn0v0tee5MUtTMQdLwY"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],37],[12,2,10],[13]]],[3,[0,["d6A+6InPZYvpJW3IbS0Wl7"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],38],[12,2,10],[13]]],[3,[0,["bdxJAiTAVUMKyP8pxmADOS"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],39],[12,2,10],[13]]],[3,[0,["5bU7kVtoxbspVr7Gk8f7yZ"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],40],[12,2,10],[13]]],[3,[0,["c0+Fr1B1VaNZIl1yt3MduU"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],41],[12,2,10],[13]]],[3,[0,["1fEw33tmNVfI8vGLxeb/+f"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],42],[12,2,10],[13]]],[3,[0,["c47yN71ANZBpb6dkoNK8bs"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],43],[12,2,10],[13]]],[3,[0,["c2W4U/ua1fl6R3dFANHNMt"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],44],[12,2,10],[13]]],[3,[0,["56McHCFMRYvo2J8lmq2cZg"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],45],[12,2,10],[13]]],[3,[0,["05QkCNkw5aNJdMGD4INznQ"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],46],[12,2,10],[13]]],[3,[0,["45RfkiVMJdfbuyNb2mPW3a"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],47],[12,2,10],[13]]],[3,[0,["08sdhymO9aVYy8BwG/d+xC"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],48],[12,2,10],[13]]],[3,[0,["5eMYy9p6pWbqLalq8tVcLK"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],49],[12,2,10],[13]]],[3,[0,["7blrd9kqxUna9jNHCkJGuV"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],50],[12,2,10],[13]]],[3,[0,["fd8R2GFCtZbogC4Vh+BLhm"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],51],[12,2,10],[13]]],[3,[0,["b71bDfM2ZaFp7909W01eYU"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],52],[12,2,10],[13]]],[3,[0,["a98cWsU1dXA5GY/mu5pBsl"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],53],[12,2,10],[13]]],[3,[0,["86ODR2d/pVQL9R1ehCEDHK"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],54],[12,2,10],[13]]],[3,[0,["66gYZ+5gpUMqelVAMgeAy9"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],55],[12,2,10],[13]]],[3,[0,["917HCuE9Vau4TgLme+Lao7"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],56],[12,2,10],[13]]],[3,[0,["6da0QoiGVfZ5m7vTxNahet"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],57],[12,2,10],[13]]],[3,[0,["d2FPj+XB1WzZt0msye8iJF"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],58],[12,2,10],[13]]],[3,[0,["3evOST169Y6ZvfZfd4I6eO"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],59],[12,2,10],[13]]],[3,[0,["01N87SJ9BTMLgdYb+NTTJk"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],60],[12,2,10],[13]]],[3,[0,["31yMsjRSVagJ7G4p8lYE4N"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],61],[12,2,10],[13]]],[3,[0,["fe8yzt6V1a/Kgzik1RPZay"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],62],[12,2,10],[13]]],[3,[0,["4aDi6TwTldjrmg6PxN0I/A"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],63],[12,2,10],[13]]],[3,[0,["68C/+qfa5fYZvXdc2AMyye"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],64],[12,2,10],[13]]],[3,[0,["51TUgZjXtUnbeIG/dOkpqp"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],65],[12,2,10],[13]]],[3,[0,["54L82Pf3Zb37rBqqJ23ixT"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],66],[12,2,10],[13]]],[3,[0,["04Pa9uyLZYWI+Wim9755ti"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],67],[12,2,10],[13]]],[3,[0,["f0mAlqzuNelIyODhbEKubH"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],68],[12,2,10],[13]]],[3,[0,["f7vyHBqoJdDI01QHjYTYhh"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],69],[12,2,10],[13]]],[3,[0,["49TMzHP79VV6m4zJcxR169"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],70],[12,2,10],[13]]],[3,[0,["59ULJjIGZcGbMUPjxTmuTp"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],71],[12,2,10],[13]]],[3,[0,["92iKwNWlZZD7NMQED8mOhM"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],72],[12,2,10],[13]]],[3,[0,["9aCmemyxBWdaU2cGuQxhZO"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],73],[12,2,10],[13]]],[3,[0,["09//qOYp5bKKgpUWLt25Vw"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],74],[12,2,10],[13]]],[3,[0,["39MIHV9ElWvYBoJ+oFX8bE"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],75],[12,2,10],[13]]],[3,[0,["0a7xwy1QxaLaIphwQyeF1y"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],76],[12,2,10],[13]]],[3,[0,["e017n2Zs9WmaDOAv8mWnNA"]],[[11,[1,0,0.015,0],[1,0.01,0.072,0.012],77],[12,2,10],[13]]]],[[9,"Road",["_name"],[0,["cfMJW5xYpVuoK2Tw8Ktwgb"]]],[1,["_lpos"],[0,["cfMJW5xYpVuoK2Tw8Ktwgb"]],[1,0,0,0]],[1,["_lrot"],[0,["cfMJW5xYpVuoK2Tw8Ktwgb"]],[3,0,0,0,1]],[1,["_euler"],[0,["cfMJW5xYpVuoK2Tw8Ktwgb"]],[1,0,0,0]],[1,["_lscale"],[0,["68CmGbTUxY7rwNbtgW37j2"]],[1,64.3,100,100]],[1,["_lscale"],[0,["e017n2Zs9WmaDOAv8mWnNA"]],[1,64.3,100,100]],[1,["_lscale"],[0,["0a7xwy1QxaLaIphwQyeF1y"]],[1,64.3,100,100]],[1,["_lscale"],[0,["39MIHV9ElWvYBoJ+oFX8bE"]],[1,64.3,100,100]],[1,["_lscale"],[0,["09//qOYp5bKKgpUWLt25Vw"]],[1,64.3,100,100]],[1,["_lscale"],[0,["9aCmemyxBWdaU2cGuQxhZO"]],[1,64.3,100,100]],[1,["_lscale"],[0,["92iKwNWlZZD7NMQED8mOhM"]],[1,64.3,100,100]],[1,["_lscale"],[0,["59ULJjIGZcGbMUPjxTmuTp"]],[1,64.3,100,100]],[1,["_lscale"],[0,["49TMzHP79VV6m4zJcxR169"]],[1,64.3,100,100]],[1,["_lscale"],[0,["f7vyHBqoJdDI01QHjYTYhh"]],[1,64.3,100,100]],[1,["_lscale"],[0,["f0mAlqzuNelIyODhbEKubH"]],[1,64.3,100,100]],[1,["_lscale"],[0,["04Pa9uyLZYWI+Wim9755ti"]],[1,64.3,100,100]],[1,["_lscale"],[0,["54L82Pf3Zb37rBqqJ23ixT"]],[1,64.3,100,100]],[1,["_lscale"],[0,["51TUgZjXtUnbeIG/dOkpqp"]],[1,64.3,100,100]],[1,["_lscale"],[0,["68C/+qfa5fYZvXdc2AMyye"]],[1,64.3,100,100]],[1,["_lscale"],[0,["4aDi6TwTldjrmg6PxN0I/A"]],[1,64.3,100,100]],[1,["_lscale"],[0,["fe8yzt6V1a/Kgzik1RPZay"]],[1,64.3,100,100]],[1,["_lscale"],[0,["31yMsjRSVagJ7G4p8lYE4N"]],[1,64.3,100,100]],[1,["_lscale"],[0,["01N87SJ9BTMLgdYb+NTTJk"]],[1,64.3,100,100]],[1,["_lscale"],[0,["3evOST169Y6ZvfZfd4I6eO"]],[1,64.3,100,100]],[1,["_lscale"],[0,["d2FPj+XB1WzZt0msye8iJF"]],[1,64.3,100,100]],[1,["_lscale"],[0,["6da0QoiGVfZ5m7vTxNahet"]],[1,64.3,100,100]],[1,["_lscale"],[0,["917HCuE9Vau4TgLme+Lao7"]],[1,64.3,100,100]],[1,["_lscale"],[0,["66gYZ+5gpUMqelVAMgeAy9"]],[1,64.3,100,100]],[1,["_lscale"],[0,["86ODR2d/pVQL9R1ehCEDHK"]],[1,64.3,100,100]],[1,["_lscale"],[0,["a98cWsU1dXA5GY/mu5pBsl"]],[1,64.3,100,100]],[1,["_lscale"],[0,["b71bDfM2ZaFp7909W01eYU"]],[1,64.3,100,100]],[1,["_lscale"],[0,["fd8R2GFCtZbogC4Vh+BLhm"]],[1,64.3,100,100]],[1,["_lscale"],[0,["7blrd9kqxUna9jNHCkJGuV"]],[1,64.3,100,100]],[1,["_lscale"],[0,["5eMYy9p6pWbqLalq8tVcLK"]],[1,64.3,100,100]],[1,["_lscale"],[0,["08sdhymO9aVYy8BwG/d+xC"]],[1,64.3,100,100]],[1,["_lscale"],[0,["45RfkiVMJdfbuyNb2mPW3a"]],[1,64.3,100,100]],[1,["_lscale"],[0,["05QkCNkw5aNJdMGD4INznQ"]],[1,64.3,100,100]],[1,["_lscale"],[0,["56McHCFMRYvo2J8lmq2cZg"]],[1,64.3,100,100]],[1,["_lscale"],[0,["c2W4U/ua1fl6R3dFANHNMt"]],[1,64.3,100,100]],[1,["_lscale"],[0,["c47yN71ANZBpb6dkoNK8bs"]],[1,64.3,100,100]],[1,["_lscale"],[0,["1fEw33tmNVfI8vGLxeb/+f"]],[1,64.3,100,100]],[1,["_lscale"],[0,["c0+Fr1B1VaNZIl1yt3MduU"]],[1,64.3,100,100]],[1,["_lscale"],[0,["5bU7kVtoxbspVr7Gk8f7yZ"]],[1,64.3,100,100]],[1,["_lscale"],[0,["bdxJAiTAVUMKyP8pxmADOS"]],[1,64.3,100,100]],[1,["_lscale"],[0,["d6A+6InPZYvpJW3IbS0Wl7"]],[1,64.3,100,100]],[1,["_lscale"],[0,["a6gmn0v0tee5MUtTMQdLwY"]],[1,64.3,100,100]],[1,["_lscale"],[0,["cfQpSEN8xfk67qfWWjW1IH"]],[1,64.3,100,100]],[1,["_lscale"],[0,["76dTysmbxbg47WUecSJoQj"]],[1,64.3,100,100]],[1,["_lscale"],[0,["50Tq9GjcVVVqNymvMtN0cz"]],[1,64.3,100,100]],[1,["_lscale"],[0,["dcuDgTMcRfqYbH5pIIu2Ay"]],[1,64.3,100,100]],[1,["_lscale"],[0,["dbnPDX5NBWjJy7EmzC3GIt"]],[1,64.3,100,100]],[1,["_lscale"],[0,["42WhgU+BJTyqV6puSycqg8"]],[1,64.3,100,100]],[1,["_lscale"],[0,["b3jtrAIblWNrqzsR2c78ao"]],[1,64.3,100,100]],[1,["_lscale"],[0,["4dIIAdVhBXcq7N2b8N7TWn"]],[1,64.3,100,100]],[1,["_lscale"],[0,["ccBYRoX7VarKrXnhMXtFED"]],[1,64.3,100,100]],[1,["_lscale"],[0,["e9JABiUQtRtY2OyVkJorTc"]],[1,64.3,100,100]],[1,["_lscale"],[0,["adJXQR9flTzoWz/Bg7Ik5j"]],[1,64.3,100,100]],[1,["_lscale"],[0,["61R24SzvxT54Vl8seviC1G"]],[1,64.3,100,100]],[1,["_lscale"],[0,["afU6MobIhQmZEh2Sk+hfFJ"]],[1,64.3,100,100]],[1,["_lscale"],[0,["b3mpDzpEpb56d+jKXSFQXp"]],[1,64.3,100,100]],[1,["_lscale"],[0,["2dDR3p7lNdgozCgjbwrOvX"]],[1,64.3,100,100]],[1,["_lscale"],[0,["60in0+6NBcH4IdvipP/F4e"]],[1,64.3,100,100]],[1,["_lscale"],[0,["57eKjcMiJWVowgMiQs1lai"]],[1,64.3,100,100]],[1,["_lscale"],[0,["aafTGYFhBZt72NQVleFbB0"]],[1,64.3,100,100]],[1,["_lpos"],[0,["68CmGbTUxY7rwNbtgW37j2"]],[1,13.981902313232425,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["e017n2Zs9WmaDOAv8mWnNA"]],[1,15.35324401855469,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["0a7xwy1QxaLaIphwQyeF1y"]],[1,16.724585723876956,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["39MIHV9ElWvYBoJ+oFX8bE"]],[1,18.09592742919922,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["09//qOYp5bKKgpUWLt25Vw"]],[1,19.467272949218753,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["9aCmemyxBWdaU2cGuQxhZO"]],[1,20.838610839843753,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["92iKwNWlZZD7NMQED8mOhM"]],[1,22.209956359863284,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["59ULJjIGZcGbMUPjxTmuTp"]],[1,23.58129806518555,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["49TMzHP79VV6m4zJcxR169"]],[1,24.95264358520508,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["f7vyHBqoJdDI01QHjYTYhh"]],[1,26.32398147583008,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["f0mAlqzuNelIyODhbEKubH"]],[1,27.695323181152347,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["04Pa9uyLZYWI+Wim9755ti"]],[1,29.066668701171878,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["54L82Pf3Zb37rBqqJ23ixT"]],[1,30.438006591796878,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["51TUgZjXtUnbeIG/dOkpqp"]],[1,31.80935211181641,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["68C/+qfa5fYZvXdc2AMyye"]],[1,33.18069000244141,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["4aDi6TwTldjrmg6PxN0I/A"]],[1,34.55203552246094,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["fe8yzt6V1a/Kgzik1RPZay"]],[1,35.92337341308594,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["31yMsjRSVagJ7G4p8lYE4N"]],[1,37.29471893310547,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["01N87SJ9BTMLgdYb+NTTJk"]],[1,38.66605682373047,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["3evOST169Y6ZvfZfd4I6eO"]],[1,40.03740234375,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["d2FPj+XB1WzZt0msye8iJF"]],[1,41.408740234375,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["6da0QoiGVfZ5m7vTxNahet"]],[1,42.780078125,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["917HCuE9Vau4TgLme+Lao7"]],[1,44.151423645019534,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["66gYZ+5gpUMqelVAMgeAy9"]],[1,45.522761535644534,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["86ODR2d/pVQL9R1ehCEDHK"]],[1,46.8941146850586,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["a98cWsU1dXA5GY/mu5pBsl"]],[1,48.2654525756836,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["b71bDfM2ZaFp7909W01eYU"]],[1,49.63679809570313,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["fd8R2GFCtZbogC4Vh+BLhm"]],[1,51.00813598632813,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["7blrd9kqxUna9jNHCkJGuV"]],[1,52.37947387695313,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["5eMYy9p6pWbqLalq8tVcLK"]],[1,53.75081939697266,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["08sdhymO9aVYy8BwG/d+xC"]],[1,55.12215728759766,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["45RfkiVMJdfbuyNb2mPW3a"]],[1,56.49350280761719,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["05QkCNkw5aNJdMGD4INznQ"]],[1,57.86484832763672,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["56McHCFMRYvo2J8lmq2cZg"]],[1,59.23618621826172,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["c2W4U/ua1fl6R3dFANHNMt"]],[1,60.60753173828125,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["c47yN71ANZBpb6dkoNK8bs"]],[1,61.97886962890625,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["1fEw33tmNVfI8vGLxeb/+f"]],[1,63.35020751953125,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["c0+Fr1B1VaNZIl1yt3MduU"]],[1,64.72154541015625,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["5bU7kVtoxbspVr7Gk8f7yZ"]],[1,66.09289855957032,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["bdxJAiTAVUMKyP8pxmADOS"]],[1,67.46423645019532,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["d6A+6InPZYvpJW3IbS0Wl7"]],[1,68.83557434082032,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["a6gmn0v0tee5MUtTMQdLwY"]],[1,70.20691223144532,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["cfQpSEN8xfk67qfWWjW1IH"]],[1,71.57826538085938,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["76dTysmbxbg47WUecSJoQj"]],[1,72.94960327148438,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["50Tq9GjcVVVqNymvMtN0cz"]],[1,74.32094116210938,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["dcuDgTMcRfqYbH5pIIu2Ay"]],[1,75.69229431152344,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["dbnPDX5NBWjJy7EmzC3GIt"]],[1,77.06363220214844,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["42WhgU+BJTyqV6puSycqg8"]],[1,78.43497009277344,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["b3jtrAIblWNrqzsR2c78ao"]],[1,79.80630798339844,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["4dIIAdVhBXcq7N2b8N7TWn"]],[1,81.1776611328125,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["ccBYRoX7VarKrXnhMXtFED"]],[1,82.54901428222657,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["e9JABiUQtRtY2OyVkJorTc"]],[1,83.92035217285157,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["adJXQR9flTzoWz/Bg7Ik5j"]],[1,85.29170532226563,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["61R24SzvxT54Vl8seviC1G"]],[1,86.66304321289063,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["afU6MobIhQmZEh2Sk+hfFJ"]],[1,88.03439636230469,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["b3mpDzpEpb56d+jKXSFQXp"]],[1,89.40573425292969,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["2dDR3p7lNdgozCgjbwrOvX"]],[1,90.77707214355469,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["60in0+6NBcH4IdvipP/F4e"]],[1,92.14841003417969,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["57eKjcMiJWVowgMiQs1lai"]],[1,93.51977844238282,-0.5190489888191223,1.646716594696045]],[1,["_lpos"],[0,["aafTGYFhBZt72NQVleFbB0"]],[1,94.89111633300782,-0.5190489888191223,1.646716594696045]],[1,["_euler"],[0,["68CmGbTUxY7rwNbtgW37j2"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["68CmGbTUxY7rwNbtgW37j2"]]],[9,1,["_layer"],[0,["e017n2Zs9WmaDOAv8mWnNA"]]],[1,["_euler"],[0,["e017n2Zs9WmaDOAv8mWnNA"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["0a7xwy1QxaLaIphwQyeF1y"]]],[1,["_euler"],[0,["0a7xwy1QxaLaIphwQyeF1y"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["39MIHV9ElWvYBoJ+oFX8bE"]]],[1,["_euler"],[0,["39MIHV9ElWvYBoJ+oFX8bE"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["09//qOYp5bKKgpUWLt25Vw"]]],[1,["_euler"],[0,["09//qOYp5bKKgpUWLt25Vw"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["9aCmemyxBWdaU2cGuQxhZO"]]],[1,["_euler"],[0,["9aCmemyxBWdaU2cGuQxhZO"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["92iKwNWlZZD7NMQED8mOhM"]]],[1,["_euler"],[0,["92iKwNWlZZD7NMQED8mOhM"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["59ULJjIGZcGbMUPjxTmuTp"]]],[1,["_euler"],[0,["59ULJjIGZcGbMUPjxTmuTp"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["49TMzHP79VV6m4zJcxR169"]]],[1,["_euler"],[0,["49TMzHP79VV6m4zJcxR169"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["f7vyHBqoJdDI01QHjYTYhh"]]],[1,["_euler"],[0,["f7vyHBqoJdDI01QHjYTYhh"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["f0mAlqzuNelIyODhbEKubH"]]],[1,["_euler"],[0,["f0mAlqzuNelIyODhbEKubH"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["04Pa9uyLZYWI+Wim9755ti"]]],[1,["_euler"],[0,["04Pa9uyLZYWI+Wim9755ti"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["54L82Pf3Zb37rBqqJ23ixT"]]],[1,["_euler"],[0,["54L82Pf3Zb37rBqqJ23ixT"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["51TUgZjXtUnbeIG/dOkpqp"]]],[1,["_euler"],[0,["51TUgZjXtUnbeIG/dOkpqp"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["68C/+qfa5fYZvXdc2AMyye"]]],[1,["_euler"],[0,["68C/+qfa5fYZvXdc2AMyye"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["4aDi6TwTldjrmg6PxN0I/A"]]],[1,["_euler"],[0,["4aDi6TwTldjrmg6PxN0I/A"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["fe8yzt6V1a/Kgzik1RPZay"]]],[1,["_euler"],[0,["fe8yzt6V1a/Kgzik1RPZay"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["31yMsjRSVagJ7G4p8lYE4N"]]],[1,["_euler"],[0,["31yMsjRSVagJ7G4p8lYE4N"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["01N87SJ9BTMLgdYb+NTTJk"]]],[1,["_euler"],[0,["01N87SJ9BTMLgdYb+NTTJk"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["3evOST169Y6ZvfZfd4I6eO"]]],[1,["_euler"],[0,["3evOST169Y6ZvfZfd4I6eO"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["d2FPj+XB1WzZt0msye8iJF"]]],[1,["_euler"],[0,["d2FPj+XB1WzZt0msye8iJF"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["6da0QoiGVfZ5m7vTxNahet"]]],[1,["_euler"],[0,["6da0QoiGVfZ5m7vTxNahet"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["917HCuE9Vau4TgLme+Lao7"]]],[1,["_euler"],[0,["917HCuE9Vau4TgLme+Lao7"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["66gYZ+5gpUMqelVAMgeAy9"]]],[1,["_euler"],[0,["66gYZ+5gpUMqelVAMgeAy9"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["86ODR2d/pVQL9R1ehCEDHK"]]],[1,["_euler"],[0,["86ODR2d/pVQL9R1ehCEDHK"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["a98cWsU1dXA5GY/mu5pBsl"]]],[1,["_euler"],[0,["a98cWsU1dXA5GY/mu5pBsl"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["b71bDfM2ZaFp7909W01eYU"]]],[1,["_euler"],[0,["b71bDfM2ZaFp7909W01eYU"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["fd8R2GFCtZbogC4Vh+BLhm"]]],[1,["_euler"],[0,["fd8R2GFCtZbogC4Vh+BLhm"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["7blrd9kqxUna9jNHCkJGuV"]]],[1,["_euler"],[0,["7blrd9kqxUna9jNHCkJGuV"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["5eMYy9p6pWbqLalq8tVcLK"]]],[1,["_euler"],[0,["5eMYy9p6pWbqLalq8tVcLK"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["08sdhymO9aVYy8BwG/d+xC"]]],[1,["_euler"],[0,["08sdhymO9aVYy8BwG/d+xC"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["45RfkiVMJdfbuyNb2mPW3a"]]],[1,["_euler"],[0,["45RfkiVMJdfbuyNb2mPW3a"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["05QkCNkw5aNJdMGD4INznQ"]]],[1,["_euler"],[0,["05QkCNkw5aNJdMGD4INznQ"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["56McHCFMRYvo2J8lmq2cZg"]]],[1,["_euler"],[0,["56McHCFMRYvo2J8lmq2cZg"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["c2W4U/ua1fl6R3dFANHNMt"]]],[1,["_euler"],[0,["c2W4U/ua1fl6R3dFANHNMt"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["c47yN71ANZBpb6dkoNK8bs"]]],[1,["_euler"],[0,["c47yN71ANZBpb6dkoNK8bs"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["1fEw33tmNVfI8vGLxeb/+f"]]],[1,["_euler"],[0,["1fEw33tmNVfI8vGLxeb/+f"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["c0+Fr1B1VaNZIl1yt3MduU"]]],[1,["_euler"],[0,["c0+Fr1B1VaNZIl1yt3MduU"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["5bU7kVtoxbspVr7Gk8f7yZ"]]],[1,["_euler"],[0,["5bU7kVtoxbspVr7Gk8f7yZ"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["bdxJAiTAVUMKyP8pxmADOS"]]],[1,["_euler"],[0,["bdxJAiTAVUMKyP8pxmADOS"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["d6A+6InPZYvpJW3IbS0Wl7"]]],[1,["_euler"],[0,["d6A+6InPZYvpJW3IbS0Wl7"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["a6gmn0v0tee5MUtTMQdLwY"]]],[1,["_euler"],[0,["a6gmn0v0tee5MUtTMQdLwY"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["cfQpSEN8xfk67qfWWjW1IH"]]],[1,["_euler"],[0,["cfQpSEN8xfk67qfWWjW1IH"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["76dTysmbxbg47WUecSJoQj"]]],[1,["_euler"],[0,["76dTysmbxbg47WUecSJoQj"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["50Tq9GjcVVVqNymvMtN0cz"]]],[1,["_euler"],[0,["50Tq9GjcVVVqNymvMtN0cz"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["dcuDgTMcRfqYbH5pIIu2Ay"]]],[1,["_euler"],[0,["dcuDgTMcRfqYbH5pIIu2Ay"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["dbnPDX5NBWjJy7EmzC3GIt"]]],[1,["_euler"],[0,["dbnPDX5NBWjJy7EmzC3GIt"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["42WhgU+BJTyqV6puSycqg8"]]],[1,["_euler"],[0,["42WhgU+BJTyqV6puSycqg8"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["b3jtrAIblWNrqzsR2c78ao"]]],[1,["_euler"],[0,["b3jtrAIblWNrqzsR2c78ao"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["4dIIAdVhBXcq7N2b8N7TWn"]]],[1,["_euler"],[0,["4dIIAdVhBXcq7N2b8N7TWn"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["ccBYRoX7VarKrXnhMXtFED"]]],[1,["_euler"],[0,["ccBYRoX7VarKrXnhMXtFED"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["e9JABiUQtRtY2OyVkJorTc"]]],[1,["_euler"],[0,["e9JABiUQtRtY2OyVkJorTc"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["adJXQR9flTzoWz/Bg7Ik5j"]]],[1,["_euler"],[0,["adJXQR9flTzoWz/Bg7Ik5j"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["61R24SzvxT54Vl8seviC1G"]]],[1,["_euler"],[0,["61R24SzvxT54Vl8seviC1G"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["afU6MobIhQmZEh2Sk+hfFJ"]]],[1,["_euler"],[0,["afU6MobIhQmZEh2Sk+hfFJ"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["b3mpDzpEpb56d+jKXSFQXp"]]],[1,["_euler"],[0,["b3mpDzpEpb56d+jKXSFQXp"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["2dDR3p7lNdgozCgjbwrOvX"]]],[1,["_euler"],[0,["2dDR3p7lNdgozCgjbwrOvX"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["60in0+6NBcH4IdvipP/F4e"]]],[1,["_euler"],[0,["60in0+6NBcH4IdvipP/F4e"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["57eKjcMiJWVowgMiQs1lai"]]],[1,["_euler"],[0,["57eKjcMiJWVowgMiQs1lai"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["aafTGYFhBZt72NQVleFbB0"]]],[1,["_euler"],[0,["aafTGYFhBZt72NQVleFbB0"]],[1,-89.99999803884879,0,0]],[9,1,["_layer"],[0,["cfMJW5xYpVuoK2Tw8Ktwgb"]]],[9,1,["_layer"],[0,["174in2T2RdXYLyYCWkXPNA"]]],[9,1,["_layer"],[0,["79PHaQWkhaN5AscoKnO1dO"]]],[9,1,["_layer"],[0,["cbblX3QndZeqahDdj6FBRx"]]]]],17]],[48,"Main Light","c0y6F5f+pAvI805TdmxIjx",5,[[85,-363,[4,4293982975],[86]]],[3,-0.06397656665577071,-0.44608233363525845,-0.8239028751062036,-0.3436591377065261],[1,-117.894,-194.909,38.562]],[87,6,8,74,12,7],[53,"Camera",4,[-364],[1,0,0,1000]],[81,0,1073741824,320,2000,6,41943040,83,[4,4278190080]],[67,0,10],[88,1,0,9,85],[89,"0",90,90,90,77],[29,"Fail",1,79,[[62,true,-365,[1,0,-1.7,-1],[1,82.474,0.625,7.634]]],[1,54.746,0,1.414]],[49,"GM","e42WJu7xdN/Lj5tChojkwt",5,[-366]],[50,"GameManager",89,[[90,1.5,-367,86,1,73,87,6]]]],0,[0,15,82,0,16,72,0,0,1,0,0,1,0,0,1,0,-1,72,0,0,2,0,0,2,0,-1,13,0,-2,15,0,-3,17,0,-4,19,0,-5,21,0,-6,23,0,-7,25,0,-8,27,0,-9,29,0,-10,31,0,-11,33,0,-12,35,0,-13,37,0,-14,39,0,-15,41,0,-16,43,0,-17,45,0,-18,47,0,-19,49,0,-20,51,0,-21,53,0,-22,55,0,-23,57,0,-24,59,0,-25,61,0,-26,63,0,-27,65,0,-28,67,0,-29,69,0,0,4,0,17,84,0,0,4,0,0,4,0,-1,83,0,-2,9,0,-3,7,0,-4,76,0,-5,78,0,-6,73,0,-7,6,0,-1,72,0,-2,80,0,-3,13,0,-4,15,0,-5,17,0,-6,19,0,-7,21,0,-8,23,0,-9,25,0,-10,27,0,-11,29,0,-12,31,0,-13,33,0,-14,35,0,-15,37,0,-16,39,0,-17,41,0,-18,43,0,-19,45,0,-20,47,0,-21,49,0,-22,51,0,-23,53,0,-24,55,0,-25,57,0,-26,59,0,-27,61,0,-28,63,0,-29,65,0,-30,67,0,-31,69,0,-1,81,0,-2,71,0,-4,79,0,-7,89,0,0,6,0,0,6,0,-3,82,0,-1,12,0,-2,74,0,-3,8,0,0,7,0,0,7,0,12,7,0,0,7,0,0,7,0,0,8,0,0,8,0,12,8,0,0,8,0,0,9,0,0,9,0,-3,86,0,-1,10,0,0,10,0,-2,85,0,12,10,0,0,10,0,0,11,0,0,11,0,-2,77,0,0,12,0,0,12,0,0,12,0,1,14,0,1,14,0,1,14,0,1,14,0,1,14,0,0,13,0,0,13,0,4,13,0,1,16,0,1,16,0,1,16,0,1,16,0,1,16,0,0,15,0,0,15,0,4,15,0,1,18,0,1,18,0,1,18,0,1,18,0,1,18,0,0,17,0,0,17,0,4,17,0,1,20,0,1,20,0,1,20,0,1,20,0,1,20,0,0,19,0,0,19,0,4,19,0,1,22,0,1,22,0,1,22,0,1,22,0,1,22,0,0,21,0,0,21,0,4,21,0,1,24,0,1,24,0,1,24,0,1,24,0,1,24,0,0,23,0,0,23,0,4,23,0,1,26,0,1,26,0,1,26,0,1,26,0,1,26,0,0,25,0,0,25,0,4,25,0,1,28,0,1,28,0,1,28,0,1,28,0,1,28,0,0,27,0,0,27,0,4,27,0,1,30,0,1,30,0,1,30,0,1,30,0,1,30,0,0,29,0,0,29,0,4,29,0,1,32,0,1,32,0,1,32,0,1,32,0,1,32,0,0,31,0,0,31,0,4,31,0,1,34,0,1,34,0,1,34,0,1,34,0,1,34,0,0,33,0,0,33,0,4,33,0,1,36,0,1,36,0,1,36,0,1,36,0,1,36,0,0,35,0,0,35,0,4,35,0,1,38,0,1,38,0,1,38,0,1,38,0,1,38,0,0,37,0,0,37,0,4,37,0,1,40,0,1,40,0,1,40,0,1,40,0,1,40,0,0,39,0,0,39,0,4,39,0,1,42,0,1,42,0,1,42,0,1,42,0,1,42,0,0,41,0,0,41,0,4,41,0,1,44,0,1,44,0,1,44,0,1,44,0,1,44,0,0,43,0,0,43,0,4,43,0,1,46,0,1,46,0,1,46,0,1,46,0,1,46,0,0,45,0,0,45,0,4,45,0,1,48,0,1,48,0,1,48,0,1,48,0,1,48,0,0,47,0,0,47,0,4,47,0,1,50,0,1,50,0,1,50,0,1,50,0,1,50,0,0,49,0,0,49,0,4,49,0,1,52,0,1,52,0,1,52,0,1,52,0,1,52,0,0,51,0,0,51,0,4,51,0,1,54,0,1,54,0,1,54,0,1,54,0,1,54,0,0,53,0,0,53,0,4,53,0,1,56,0,1,56,0,1,56,0,1,56,0,1,56,0,0,55,0,0,55,0,4,55,0,1,58,0,1,58,0,1,58,0,1,58,0,1,58,0,0,57,0,0,57,0,4,57,0,1,60,0,1,60,0,1,60,0,1,60,0,1,60,0,0,59,0,0,59,0,4,59,0,1,62,0,1,62,0,1,62,0,1,62,0,1,62,0,0,61,0,0,61,0,4,61,0,1,64,0,1,64,0,1,64,0,1,64,0,1,64,0,0,63,0,0,63,0,4,63,0,1,66,0,1,66,0,1,66,0,1,66,0,1,66,0,0,65,0,0,65,0,4,65,0,1,68,0,1,68,0,1,68,0,1,68,0,1,68,0,0,67,0,0,67,0,4,67,0,1,70,0,1,70,0,1,70,0,1,70,0,1,70,0,0,69,0,0,69,0,4,69,0,0,71,0,0,71,0,-1,75,0,4,72,0,0,73,0,0,73,0,0,74,0,0,74,0,0,75,0,0,75,0,0,76,0,0,77,0,-2,87,0,0,78,0,0,78,0,-1,80,0,-2,88,0,4,80,0,0,81,0,-1,84,0,0,88,0,-1,90,0,0,90,0,18,5,1,8,5,2,8,11,3,8,5,4,8,5,11,8,76,367],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,85],[-1,2,5,13,7,7,13,14,7,7,7,7,7,7,7,13,14,5,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,19,20,7],[98,99,100,5,101,6,6,7,102,103,104,105,106,107,8,8,7,108,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,109,110,5]],[[{"name":"bar_plate","rect":{"x":1,"y":1,"width":413,"height":197},"offset":{"x":0,"y":0},"originalSize":{"width":415,"height":199},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-206.5,-98.5,0,206.5,-98.5,0,-206.5,98.5,0,206.5,98.5,0],"indexes":[0,1,2,2,1,3],"uv":[1,198,414,198,1,1,414,1],"nuv":[0.0024096385542168677,0.005025125628140704,0.9975903614457832,0.005025125628140704,0.0024096385542168677,0.9949748743718593,0.9975903614457832,0.9949748743718593],"minPos":{"x":-206.5,"y":-98.5,"z":0},"maxPos":{"x":206.5,"y":98.5,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[2],0,[0],[6],[111]],[[{"name":"btn_try_again","rect":{"x":0,"y":0,"width":431,"height":172},"offset":{"x":0,"y":0},"originalSize":{"width":431,"height":172},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-215.5,-86,0,215.5,-86,0,-215.5,86,0,215.5,86,0],"indexes":[0,1,2,2,1,3],"uv":[0,172,431,172,0,0,431,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-215.5,"y":-86,"z":0},"maxPos":{"x":215.5,"y":86,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[2],0,[0],[6],[112]],[[[91,"util/dcc/imported-specular-glossiness",[{"hash":3452512057,"name":"util/dcc/imported-specular-glossiness|standard-vs|standard-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"diffuseColor","type":16,"count":1},{"name":"specularColor","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScale","type":13,"count":1},{"name":"alphaThreshold","type":13,"count":1},{"name":"shininessExponent","type":13,"count":1},{"name":"glossiness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalScale","type":13,"count":1},{"name":"transparencyFactor","type":13,"count":1},{"name":"diffuseFactor","type":13,"count":1},{"name":"specularFactor","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"shininessExponentMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_SHININESS_MAP"]},{"name":"specularGlossinessMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_SPECULAR_GLOSSINESS_MAP"]},{"name":"specularMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_SPECULAR_MAP"]},{"name":"metallicMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_MAP"]},{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_ALBEDO_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_TRANSPARENCY_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_EMISSIVE_MAP"]},{"name":"emissiveScaleMap","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["USE_EMISSIVESCALE_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["USE_NORMAL_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":10,"defines":["USE_OCCLUSION_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_color","format":44,"location":6,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":7,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":15,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":16,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":17,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"tags":[],"defines":[]},{"name":"fragColor0","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":1,"tags":["CC_PIPELINE_TYPE"],"defines":["CC_PIPELINE_TYPE"]},{"name":"fragColor1","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":2,"defines":["CC_PIPELINE_TYPE"]},{"name":"fragColor2","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":3,"defines":["CC_PIPELINE_TYPE"]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCLocal","stageFlags":17,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]},{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_lightPos","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true},{"name":"cc_lightColor","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightSizeRangeAngle","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightDir","typename":"vec4","type":16,"count":0,"isArray":true}],"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_sh_linear_const_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_a","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"diffuseColor","type":16,"count":1},{"name":"specularColor","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScale","type":13,"count":1},{"name":"alphaThreshold","type":13,"count":1},{"name":"shininessExponent","type":13,"count":1},{"name":"glossiness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalScale","type":13,"count":1},{"name":"transparencyFactor","type":13,"count":1},{"name":"diffuseFactor","type":13,"count":1},{"name":"specularFactor","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"shininessExponentMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_SHININESS_MAP"]},{"name":"specularGlossinessMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_SPECULAR_GLOSSINESS_MAP"]},{"name":"specularMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_SPECULAR_MAP"]},{"name":"metallicMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_MAP"]},{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_ALBEDO_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_TRANSPARENCY_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_EMISSIVE_MAP"]},{"name":"emissiveScaleMap","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["USE_EMISSIVESCALE_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["USE_NORMAL_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":10,"defines":["USE_OCCLUSION_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCSM","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_csmViewDir0","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir1","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir2","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmAtlas","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_matCSMViewProj","typename":"mat4","type":25,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjDepthInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmSplitsInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":[]},{"name":"cc_diffuseMap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE USE_REFLECTION_DENOISE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING USE_COMPATIBLE_LIGHTING\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    in vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    in vec4 a_sh_linear_const_r;\n    in vec4 a_sh_linear_const_g;\n    in vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n#endif\nout highp vec3 v_worldPos;\nout mediump vec4 v_normal;\nout vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  out lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  out mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  out mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  out mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  out mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  out mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  out highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  out highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    out mediump vec4 v_sh_linear_const_r;\n    out mediump vec4 v_sh_linear_const_g;\n    out mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n    float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n        vec4 wPos = pos;\n        float cam_dis = distance(cameraPos, wPos.xyz);\n        return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n    }\n    float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * fogDensity);\n        return f;\n    }\n    float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n        return f;\n    }\n    float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n        vec4 wPos = pos;\n        vec3 camWorldProj = cameraPos.xyz;\n        camWorldProj.y = 0.;\n        vec3 worldPosProj = wPos.xyz;\n        worldPosProj.y = 0.;\n        float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n        float fDeltaY, fDensityIntegral;\n        if (cameraPos.y > fogTop) {\n            if (wPos.y < fogTop) {\n                fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n                fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n            }\n            else {\n                fDeltaY = 0.;\n                fDensityIntegral = 0.;\n            }\n        }\n        else {\n            if (wPos.y < fogTop) {\n                float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n                float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n                fDeltaY = abs(fDeltaA - fDeltaB);\n                fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n            }\n            else {\n                fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n                fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n            }\n        }\n        float fDensity;\n        if (fDeltaY != 0.) {\n            fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n        }\n        else {\n            fDensity = 0.;\n        }\n        float f = exp(-fDensity);\n        return f;\n    }\n  #endif\n  void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n  {\n  #if CC_USE_FOG == 0\n  \tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n  #elif CC_USE_FOG == 1\n  \tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 2\n  \tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 3\n  \tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n  #else\n  \tfactor = 1.0;\n  #endif\n  }\n#endif\nlayout(std140) uniform Constants {\n  vec4  tilingOffset;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float emissiveScale;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.position.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\nvec3 SurfacesVertexModifyLocalNormal(in SurfacesStandardVertexIntermediate In)\n{\n  return In.normal.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 SurfacesVertexModifyLocalTangent(in SurfacesStandardVertexIntermediate In)\n    {\n      return In.tangent;\n    }\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\nvec3 SurfacesVertexModifyWorldNormal(in SurfacesStandardVertexIntermediate In)\n{\n    vec3 worldNormal = In.worldNormal.xyz;\n  #if CC_SURFACES_USE_TWO_SIDED\n      worldNormal.xyz *= In.worldNormal.w;\n  #endif\n  return worldNormal;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\nvec2 SurfacesVertexModifyShadowBias(in SurfacesStandardVertexIntermediate In, vec2 originShadowBias)\n{\n  return originShadowBias;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferFog(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(vec4(In.worldPos, 1.0), In.fogFactor);\n#endif\n}\nvoid CCSurfacesVertexTransferShadow(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    In.shadowBiasAndProbeId = vec4(0.0);\n  #endif\n  #if CC_RECEIVE_SHADOW\n    In.shadowBiasAndProbeId.xy = vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.xy += a_localShadowBiasAndProbeId.xy;\n    #else\n      In.shadowBiasAndProbeId.xy += cc_localShadowBias.xy;\n    #endif\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.zw = a_localShadowBiasAndProbeId.zw;\n    #else\n      In.shadowBiasAndProbeId.zw = cc_localShadowBias.zw;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferLightMapUV(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #if USE_INSTANCING\n    In.lightmapUV.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    In.lightmapUV.z = a_lightingMapUVParam.w;\n  #else\n    In.lightmapUV.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    In.lightmapUV.z = cc_lightingMapUVParam.w;\n  #endif\n#endif\n}\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  In.normal.xyz = SurfacesVertexModifyLocalNormal(In);\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    In.tangent = SurfacesVertexModifyLocalTangent(In);\n  #endif\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matProj * cc_matView * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  vec3 viewDirect = normalize(cc_cameraPos.xyz - In.worldPos);\n  In.worldNormal.w = dot(In.worldNormal.xyz, viewDirect) < 0.0 ? -1.0 : 1.0;\n  In.worldNormal.xyz = SurfacesVertexModifyWorldNormal(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexTransferFog(In);\n  CCSurfacesVertexTransferLightMapUV(In);\n  CCSurfacesVertexTransferShadow(In);\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    In.shadowBiasAndProbeId.xy = SurfacesVertexModifyShadowBias(In, In.shadowBiasAndProbeId.xy);\n  #endif\n  CCSurfacesVertexOutput(In);\n}","frag":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE USE_REFLECTION_DENOISE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING USE_COMPATIBLE_LIGHTING\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nin highp vec3 v_worldPos;\nin mediump vec4 v_normal;\nin vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  in mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  in mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  in mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  in mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  in highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  in highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    in mediump vec4 v_sh_linear_const_r;\n    in mediump vec4 v_sh_linear_const_g;\n    in mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    layout(std140) uniform CCForwardLight {\n      highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n      vec4 cc_lightColor[LIGHTS_PER_PASS];\n      vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n      vec4 cc_lightDir[LIGHTS_PER_PASS];\n    };\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    layout(std140) uniform CCSH {\n      vec4 cc_sh_linear_const_r;\n      vec4 cc_sh_linear_const_g;\n      vec4 cc_sh_linear_const_b;\n      vec4 cc_sh_quadratic_r;\n      vec4 cc_sh_quadratic_g;\n      vec4 cc_sh_quadratic_b;\n      vec4 cc_sh_quadratic_a;\n    };\n  #endif\n#endif\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nvec4 packRGBE (vec3 rgb) {\n  highp float maxComp = max(max(rgb.r, rgb.g), rgb.b);\n  highp float e = 128.0;\n  if (maxComp > 0.0001) {\n    e = log(maxComp) / log(1.1);\n    e = ceil(e);\n    e = clamp(e + 128.0, 0.0, 255.0);\n  }\n  highp float sc = 1.0 / pow(1.1, e - 128.0);\n  vec3 encode = clamp(rgb * sc, vec3(0.0), vec3(1.0)) * 255.0;\n  vec3 encode_rounded = floor(encode) + step(encode - floor(encode), vec3(0.5));\n  return vec4(encode_rounded, e) / 255.0;\n}\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 HDRToLDR(vec3 color)\n{\n  #if CC_USE_HDR\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n      if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING)\n    #endif\n    #if CC_TONE_MAPPING_TYPE == HDR_TONE_MAPPING_ACES\n      color.rgb = ACESToneMap(color.rgb);\n    #endif\n  #endif\n  return color;\n}\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\nbool isnans(vec2 val) {\n    return isnan(val.x) || isnan(val.y);\n}\nbool isnans(vec3 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z);\n}\nbool isnans(vec4 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z) || isnan(val.w);\n}\nbool isinfs(vec2 val) {\n    return isinf(val.x) || isinf(val.y);\n}\nbool isinfs(vec3 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z);\n}\nbool isinfs(vec4 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z) || isinf(val.w);\n}\nfloat saturate(float value) {\n    return min(max(value, 0.0), 1.0);\n}\nvec2 saturate(vec2 value) { return vec2(saturate(value.x), saturate(value.y)); }\nvec3 saturate(vec3 value) { return vec3(saturate(value.x), saturate(value.y), saturate(value.z)); }\nvec4 saturate(vec4 value) { return vec4(saturate(value.x), saturate(value.y), saturate(value.z), saturate(value.w)); }\nvec2 GetPlanarReflectScreenUV(vec3 worldPos, mat4 matVirtualCameraViewProj, float flipNDCSign, vec3 viewDir, vec3 reflectDir)\n{\n  vec4 clipPos = matVirtualCameraViewProj * vec4(worldPos, 1.0);\n  vec2 screenUV = clipPos.xy / clipPos.w * 0.5 + 0.5;\n  screenUV = vec2(1.0 - screenUV.x, screenUV.y);\n  screenUV = flipNDCSign == 1.0 ? vec2(screenUV.x, 1.0 - screenUV.y) : screenUV;\n  return screenUV;\n}\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nvec3 CalculateBinormal(vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    return cross(normal, tangent) * mirrorNormal;\n}\nvec3 CalculateNormal(vec3 tangent, vec3 binormal)\n{\n    return cross(tangent, binormal);\n}\nvec3 CalculateNormalFromTangentSpace(vec3 normalFromTangentSpace, float normalStrength, vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    vec3 binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n    return (normalFromTangentSpace.x * normalStrength) * normalize(tangent) +\n           (normalFromTangentSpace.y * normalStrength) * normalize(binormal) +\n            normalFromTangentSpace.z * normalize(normal);\n}\nvec3 RotationVecFromAxisY(vec3 v, float cosTheta, float sinTheta)\n{\n    vec3 result;\n    result.x = dot(v, vec3(cosTheta, 0.0, -sinTheta));\n    result.y = v.y;\n    result.z = dot(v, vec3(sinTheta, 0.0,  cosTheta));\n    return result;\n}\nvec3 RotationVecFromAxisY(vec3 v, float rotateAngleArc)\n{\n  return RotationVecFromAxisY(v, cos(rotateAngleArc), sin(rotateAngleArc));\n}\nvoid RotateTangentAndBinormal(inout vec3 tangent, inout vec3 binormal, vec3 normal, float rotationAngle)\n{\n    float cosTheta = cos(rotationAngle), sinTheta = sin(rotationAngle);\n    vec3 B = RotationVecFromAxisY(vec3(1.0, 0.0, 0.0), cosTheta, sinTheta);\n    vec3 T = RotationVecFromAxisY(vec3(0.0, 0.0, 1.0), cosTheta, sinTheta);\n    vec3 tangentNew, binormalNew;\n    binormalNew = B.x * binormal + B.y * normal + B.z * tangent;\n    binormal = normalize(binormalNew);\n    tangentNew = T.x * binormal + T.y * normal + T.z * tangent;\n    tangent = normalize(tangentNew);\n}\nvoid RotateNormalAndBinormal(inout vec3 binormal, inout vec3 normal, in vec3 tangent, float rotationAngle, float mirrorNormal)\n{\n  if(rotationAngle > 0.0)\n  {\n    normal += (binormal - normal) * rotationAngle;\n    normal = normalize(normal);\n    binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n  }\n  else if(rotationAngle < 0.0)\n  {\n    binormal += (binormal - normal) * rotationAngle;\n    binormal = normalize(binormal);\n    normal = CalculateNormal(tangent, binormal);\n  }\n}\nvec2 signNotZero(vec2 v) {\n  return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\nvec2 float32x3_to_oct(in vec3 v) {\n  vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n  return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n}\nbool GetMetallicAlbedoFromDiffuseSpecularWithoutColor(out float metallic, out vec3 albedo, vec3 diffuse, vec3 specular, float f0 )\n{\n\tfloat d = max(max(diffuse.x, diffuse.y), diffuse.z);\n\tvec3 normalizedColor = diffuse / (d + (d < EPSILON_LOWP ? EPSILON_LOWP : 0.0));\n\tnormalizedColor = d < EPSILON_LOWP ? specular : normalizedColor;\n\tfloat s = max(max(specular.x, specular.y), specular.z);\n\tfloat delta = (d + s) * (d + s)  - 4.0 * f0 * d;\n\tfloat deltaSqrt = sqrt(max(0.0, delta));\n\tfloat solverMetallic = (-d - s + 2.0 * f0 + deltaSqrt) / (2.0 * f0);\n\tvec3 solverAlbedo = (d + s) * normalizedColor - vec3(f0 * (1.0 - solverMetallic));\n\tbool isValidSolver = delta >= 0.0;\n\tmetallic = isValidSolver ? clamp(solverMetallic, 0.0, 1.0) : 0.0;\n\talbedo = isValidSolver ? vec3(max(0.0, solverAlbedo.x), max(0.0, solverAlbedo.y), max(0.0, solverAlbedo.z)) : diffuse;\n\treturn isValidSolver;\n}\n  vec3 EnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n      #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n        roughness = pow(roughness, 0.5);\n      #endif\n    \tfloat mip = roughness * (mipCount - 1.0);\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n      vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    \tvec4 biased = fragTextureLod(cc_environment, rotationDir, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, rotationDir);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n  vec3 EnvReflection(samplerCube tex, vec3 R, float roughness, float mipCount) {\n    #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n      roughness = pow(roughness, 0.5);\n    #endif\n    vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    vec4 envmap = fragTextureLod(tex, rotationDir, roughness * (mipCount - 1.0));\n    #if CC_USE_IBL == 2 || CC_USE_REFLECTION_PROBE != REFLECTION_PROBE_TYPE_NONE\n      return unpackRGBE(envmap);\n    #else\n      return SRGBToLinear(envmap.rgb);\n    #endif\n  }\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  float SampleShadowMap (vec3 shadowNDCPos, highp sampler2D shadowMap)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return dot(texture(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    #else\n      return texture(shadowMap, shadowNDCPos.xy).x;\n    #endif\n  }\n  float SampleShadowMapSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0 = SampleShadowMap(vec3(shadowNDCPos.x, shadowNDCPos.y, shadowNDCPos.z), shadowMap);\n    float block1 = SampleShadowMap(vec3(shadowNDCPos_offset.x, shadowNDCPos.y, shadowNDCPos.z), shadowMap);\n    float block2 = SampleShadowMap(vec3(shadowNDCPos.x, shadowNDCPos_offset.y, shadowNDCPos.z), shadowMap);\n    float block3 = SampleShadowMap(vec3(shadowNDCPos_offset.x, shadowNDCPos_offset.y, shadowNDCPos.z), shadowMap);\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorHard (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return step(shadowNDCPos.z, dot(texture(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      return step(shadowNDCPos.z, texture(shadowMap, shadowNDCPos.xy).x);\n    #endif\n  }\n  float NativePCFShadowFactorSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block1 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n    #endif\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n    float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n    float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n    float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n      block1 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n      block4 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block5 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n      block6 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n      block7 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n      block8 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n    #endif\n    float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float NativePCFShadowFactorSoft5X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 twoTap = oneTap * 2.0;\n    vec2 offset1 = shadowNDCPos.xy + vec2(-twoTap.x, -twoTap.y);\n    vec2 offset2 = shadowNDCPos.xy + vec2(-oneTap.x, -twoTap.y);\n    vec2 offset3 = shadowNDCPos.xy + vec2(0.0, -twoTap.y);\n    vec2 offset4 = shadowNDCPos.xy + vec2(oneTap.x, -twoTap.y);\n    vec2 offset5 = shadowNDCPos.xy + vec2(twoTap.x, -twoTap.y);\n    vec2 offset6 = shadowNDCPos.xy + vec2(-twoTap.x, -oneTap.y);\n    vec2 offset7 = shadowNDCPos.xy + vec2(-oneTap.x, -oneTap.y);\n    vec2 offset8 = shadowNDCPos.xy + vec2(0.0, -oneTap.y);\n    vec2 offset9 = shadowNDCPos.xy + vec2(oneTap.x, -oneTap.y);\n    vec2 offset10 = shadowNDCPos.xy + vec2(twoTap.x, -oneTap.y);\n    vec2 offset11 = shadowNDCPos.xy + vec2(-twoTap.x, 0.0);\n    vec2 offset12 = shadowNDCPos.xy + vec2(-oneTap.x, 0.0);\n    vec2 offset13 = shadowNDCPos.xy + vec2(0.0, 0.0);\n    vec2 offset14 = shadowNDCPos.xy + vec2(oneTap.x, 0.0);\n    vec2 offset15 = shadowNDCPos.xy + vec2(twoTap.x, 0.0);\n    vec2 offset16 = shadowNDCPos.xy + vec2(-twoTap.x, oneTap.y);\n    vec2 offset17 = shadowNDCPos.xy + vec2(-oneTap.x, oneTap.y);\n    vec2 offset18 = shadowNDCPos.xy + vec2(0.0, oneTap.y);\n    vec2 offset19 = shadowNDCPos.xy + vec2(oneTap.x, oneTap.y);\n    vec2 offset20 = shadowNDCPos.xy + vec2(twoTap.x, oneTap.y);\n    vec2 offset21 = shadowNDCPos.xy + vec2(-twoTap.x, twoTap.y);\n    vec2 offset22 = shadowNDCPos.xy + vec2(-oneTap.x, twoTap.y);\n    vec2 offset23 = shadowNDCPos.xy + vec2(0.0, twoTap.y);\n    vec2 offset24 = shadowNDCPos.xy + vec2(oneTap.x, twoTap.y);\n    vec2 offset25 = shadowNDCPos.xy + vec2(twoTap.x, twoTap.y);\n    float block1, block2, block3, block4, block5, block6, block7, block8, block9, block10, block11, block12, block13, block14, block15, block16, block17, block18, block19, block20, block21, block22, block23, block24, block25;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, offset1), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, offset2), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, offset3), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture(shadowMap, offset4), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture(shadowMap, offset5), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture(shadowMap, offset6), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture(shadowMap, offset7), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture(shadowMap, offset8), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block9 = step(shadowNDCPos.z, dot(texture(shadowMap, offset9), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block10 = step(shadowNDCPos.z, dot(texture(shadowMap, offset10), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block11 = step(shadowNDCPos.z, dot(texture(shadowMap, offset11), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block12 = step(shadowNDCPos.z, dot(texture(shadowMap, offset12), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block13 = step(shadowNDCPos.z, dot(texture(shadowMap, offset13), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block14 = step(shadowNDCPos.z, dot(texture(shadowMap, offset14), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block15 = step(shadowNDCPos.z, dot(texture(shadowMap, offset15), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block16 = step(shadowNDCPos.z, dot(texture(shadowMap, offset16), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block17 = step(shadowNDCPos.z, dot(texture(shadowMap, offset17), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block18 = step(shadowNDCPos.z, dot(texture(shadowMap, offset18), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block19 = step(shadowNDCPos.z, dot(texture(shadowMap, offset19), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block20 = step(shadowNDCPos.z, dot(texture(shadowMap, offset20), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block21 = step(shadowNDCPos.z, dot(texture(shadowMap, offset21), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block22 = step(shadowNDCPos.z, dot(texture(shadowMap, offset22), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block23 = step(shadowNDCPos.z, dot(texture(shadowMap, offset23), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block24 = step(shadowNDCPos.z, dot(texture(shadowMap, offset24), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block25 = step(shadowNDCPos.z, dot(texture(shadowMap, offset25), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block1 = step(shadowNDCPos.z, texture(shadowMap, offset1).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, offset2).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, offset3).x);\n      block4 = step(shadowNDCPos.z, texture(shadowMap, offset4).x);\n      block5 = step(shadowNDCPos.z, texture(shadowMap, offset5).x);\n      block6 = step(shadowNDCPos.z, texture(shadowMap, offset6).x);\n      block7 = step(shadowNDCPos.z, texture(shadowMap, offset7).x);\n      block8 = step(shadowNDCPos.z, texture(shadowMap, offset8).x);\n      block9 = step(shadowNDCPos.z, texture(shadowMap, offset9).x);\n      block10 = step(shadowNDCPos.z, texture(shadowMap, offset10).x);\n      block11 = step(shadowNDCPos.z, texture(shadowMap, offset11).x);\n      block12 = step(shadowNDCPos.z, texture(shadowMap, offset12).x);\n      block13 = step(shadowNDCPos.z, texture(shadowMap, offset13).x);\n      block14 = step(shadowNDCPos.z, texture(shadowMap, offset14).x);\n      block15 = step(shadowNDCPos.z, texture(shadowMap, offset15).x);\n      block16 = step(shadowNDCPos.z, texture(shadowMap, offset16).x);\n      block17 = step(shadowNDCPos.z, texture(shadowMap, offset17).x);\n      block18 = step(shadowNDCPos.z, texture(shadowMap, offset18).x);\n      block19 = step(shadowNDCPos.z, texture(shadowMap, offset19).x);\n      block20 = step(shadowNDCPos.z, texture(shadowMap, offset20).x);\n      block21 = step(shadowNDCPos.z, texture(shadowMap, offset21).x);\n      block22 = step(shadowNDCPos.z, texture(shadowMap, offset22).x);\n      block23 = step(shadowNDCPos.z, texture(shadowMap, offset23).x);\n      block24 = step(shadowNDCPos.z, texture(shadowMap, offset24).x);\n      block25 = step(shadowNDCPos.z, texture(shadowMap, offset25).x);\n    #endif\n    vec2 coef = fract(shadowNDCPos.xy * shadowMapResolution);\n    vec2 v1X1 = mix(vec2(block1, block6), vec2(block2, block7), coef.xx);\n    vec2 v1X2 = mix(vec2(block2, block7), vec2(block3, block8), coef.xx);\n    vec2 v1X3 = mix(vec2(block3, block8), vec2(block4, block9), coef.xx);\n    vec2 v1X4 = mix(vec2(block4, block9), vec2(block5, block10), coef.xx);\n    float v1 = mix(v1X1.x, v1X1.y, coef.y) + mix(v1X2.x, v1X2.y, coef.y) + mix(v1X3.x, v1X3.y, coef.y) + mix(v1X4.x, v1X4.y, coef.y);\n    vec2 v2X1 = mix(vec2(block6, block11), vec2(block7, block12), coef.xx);\n    vec2 v2X2 = mix(vec2(block7, block12), vec2(block8, block13), coef.xx);\n    vec2 v2X3 = mix(vec2(block8, block13), vec2(block9, block14), coef.xx);\n    vec2 v2X4 = mix(vec2(block9, block14), vec2(block10, block15), coef.xx);\n    float v2 = mix(v2X1.x, v2X1.y, coef.y) + mix(v2X2.x, v2X2.y, coef.y) + mix(v2X3.x, v2X3.y, coef.y) + mix(v2X4.x, v2X4.y, coef.y);\n    vec2 v3X1 = mix(vec2(block11, block16), vec2(block12, block17), coef.xx);\n    vec2 v3X2 = mix(vec2(block12, block17), vec2(block13, block18), coef.xx);\n    vec2 v3X3 = mix(vec2(block13, block18), vec2(block14, block19), coef.xx);\n    vec2 v3X4 = mix(vec2(block14, block19), vec2(block15, block20), coef.xx);\n    float v3 = mix(v3X1.x, v3X1.y, coef.y) + mix(v3X2.x, v3X2.y, coef.y) + mix(v3X3.x, v3X3.y, coef.y) + mix(v3X4.x, v3X4.y, coef.y);\n    vec2 v4X1 = mix(vec2(block16, block21), vec2(block17, block22), coef.xx);\n    vec2 v4X2 = mix(vec2(block17, block22), vec2(block18, block23), coef.xx);\n    vec2 v4X3 = mix(vec2(block18, block23), vec2(block19, block24), coef.xx);\n    vec2 v4X4 = mix(vec2(block19, block24), vec2(block20, block25), coef.xx);\n    float v4 = mix(v4X1.x, v4X1.y, coef.y) + mix(v4X2.x, v4X2.y, coef.y) + mix(v4X3.x, v4X3.y, coef.y) + mix(v4X4.x, v4X4.y, coef.y);\n    float fAvg = (v1 + v2 + v3 + v4) * 0.0625;\n    return fAvg;\n  }\n  bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n  {\n  \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n  \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n  \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n  \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n  \t\treturn false;\n  \t}\n  \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n  \treturn true;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n  {\n    vec4 newShadowPos = shadowPos;\n    if (normalBias > EPSILON_LOWP)\n    {\n      vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n      if (viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n  {\n  \tvec4 newShadowPos = shadowPos;\n  \tif (normalBias > EPSILON_LOWP)\n  \t{\n  \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n  \t\tif (viewNormal.z < 0.1)\n  \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n  \t}\n  \treturn newShadowPos;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Orthgraphic(float NDCDepth, float projScaleZ, float projBiasZ)\n  {\n  \treturn (NDCDepth - projBiasZ) / projScaleZ;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Perspective(float NDCDepth, float homogenousDividW, float invProjScaleZ, float invProjBiasZ)\n  {\n  \treturn NDCDepth * invProjScaleZ + homogenousDividW * invProjBiasZ;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n  \tvec3 viewSpacePos;\n  \tviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n  \tviewSpacePos.z = GetViewSpaceDepthFromNDCDepth_Perspective(shadowPos.z, shadowPos.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n  \tviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n  \tvec4 clipSpacePos;\n  \tclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n  \tclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n  \t#if CC_SHADOWMAP_USE_LINEAR_DEPTH\n  \t\tclipSpacePos.z = GetLinearDepthFromViewSpace(viewSpacePos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n  \t\tclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n  \t#endif\n  \treturn clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n  {\n  \tfloat coeffA = projScaleZ;\n  \tfloat coeffB = projBiasZ;\n  \tfloat viewSpacePos_z = GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowPos.z, projScaleZ, projBiasZ);\n  \tviewSpacePos_z += viewspaceDepthBias;\n  \tvec4 result = shadowPos;\n  \tresult.z = viewSpacePos_z * coeffA + coeffB;\n  \treturn result;\n  }\n  vec4 ApplyShadowDepthBias_PerspectiveLinearDepth(vec4 shadowPos, float viewspaceDepthBias, vec3 worldPos)\n  {\n    shadowPos.z = CCGetLinearDepth(worldPos, viewspaceDepthBias) * 2.0 - 1.0;\n    shadowPos.z *= shadowPos.w;\n    return shadowPos;\n  }\n  float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCSpotShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    vec4 pos = vec4(1.0);\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      pos = ApplyShadowDepthBias_PerspectiveLinearDepth(shadowPos, shadowBias.x, worldPos);\n    #else\n      pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);\n    #endif\n    float realtimeShadow = 1.0;\n    if (pcf > 2.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft5X(pos, worldPos);\n    }else if (pcf > 1.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft3X(pos, worldPos);\n    }else if (pcf > 0.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft(pos, worldPos);\n    }else {\n      realtimeShadow = CCGetSpotLightShadowFactorHard(pos, worldPos);\n    }\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  float CCShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n    float realtimeShadow = 1.0;\n    #if CC_DIR_SHADOW_PCF_TYPE == 3\n      realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 2\n      realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 1\n      realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 0\n      realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n    #endif\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    bool CCGetCSMLevelWithTransition(out highp float ratio, vec3 clipPos) {\n      highp float maxRange = 1.0 - cc_csmSplitsInfo.x;\n      highp float minRange = cc_csmSplitsInfo.x;\n      highp float thresholdInvert = 1.0 / cc_csmSplitsInfo.x;\n      ratio = 0.0;\n      if (clipPos.x <= minRange) {\n        ratio = clipPos.x * thresholdInvert;\n        return true;\n      }\n      if (clipPos.x >= maxRange) {\n        ratio = 1.0 - (clipPos.x - maxRange) * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y <= minRange) {\n        ratio = clipPos.y  * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y >= maxRange) {\n        ratio = 1.0 - (clipPos.y - maxRange) * thresholdInvert;\n        return true;\n      }\n      return false;\n    }\n    bool CCHasCSMLevel(int level, vec3 worldPos) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      bool hasLevel = false;\n      for (int i = 0; i < 4; i++) {\n        if (i == level) {\n          vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n          if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n              clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n              clipPos.z >= 0.0 && clipPos.z <= 1.0) {\n            hasLevel = true;\n          }\n        }\n      }\n      return hasLevel;\n    }\n    void CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos, int level) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && i == level) {\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n        }\n      }\n    }\n    int CCGetCSMLevel(out bool isTransitionArea, out highp float transitionRatio, out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      int level = -1;\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && level < 0) {\n          #if CC_CASCADED_LAYERS_TRANSITION\n            isTransitionArea = CCGetCSMLevelWithTransition(transitionRatio, clipPos);\n          #endif\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n          level = i;\n        }\n      }\n      return level;\n    }\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      bool isTransitionArea = false;\n      highp float transitionRatio = 0.0;\n      return CCGetCSMLevel(isTransitionArea, transitionRatio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias)\n    {\n      bool isTransitionArea = false;\n      highp float ratio = 0.0;\n      csmPos = vec4(1.0);\n      vec4 shadowProjDepthInfo, shadowProjInfo;\n      vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n      int level = -1;\n      #if CC_CASCADED_LAYERS_TRANSITION\n        level = CCGetCSMLevel(isTransitionArea, ratio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #else\n        level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #endif\n      if (level < 0) { return 1.0; }\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n      csmPosWithBias = pos;\n      float realtimeShadow = 1.0;\n      #if CC_DIR_SHADOW_PCF_TYPE == 3\n        realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 2\n        realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 1\n        realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 0\n        realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n      #endif\n      #if CC_CASCADED_LAYERS_TRANSITION\n        vec4 nextCSMPos = vec4(1.0);\n        vec4 nextShadowProjDepthInfo, nextShadowProjInfo;\n        vec3 nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2;\n        float nextRealtimeShadow = 1.0;\n        CCGetCSMLevel(nextCSMPos, nextShadowProjDepthInfo, nextShadowProjInfo, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, worldPos, level + 1);\n        bool hasNextLevel = CCHasCSMLevel(level + 1, worldPos);\n        if (hasNextLevel && isTransitionArea) {\n          vec4 nexPos = ApplyShadowDepthBias_FaceNormal(nextCSMPos, N, shadowBias.y, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, nextShadowProjInfo.xy);\n          nexPos = ApplyShadowDepthBias_Orthographic(nexPos, shadowBias.x, nextShadowProjDepthInfo.x, nextShadowProjDepthInfo.y);\n          #if CC_DIR_SHADOW_PCF_TYPE == 3\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft5X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 2\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft3X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 1\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 0\n            nextRealtimeShadow = CCGetDirLightShadowFactorHard(nexPos);\n          #endif\n          return mix(mix(nextRealtimeShadow, realtimeShadow, ratio), 1.0, cc_shadowNFLSInfo.w);\n        }\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #else\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #endif\n    }\n  #else\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      return -1;\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias) {\n      csmPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n      return CCShadowFactorBase(csmPosWithBias, csmPos, N, shadowBias);\n    }\n  #endif\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias) {\n    vec4 shadowPosWithDepthBias;\n    return CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, N, shadowBias);\n  }\n  float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n    vec4 csmPos, csmPosWithBias;\n    return CCCSMFactorBase(csmPos, csmPosWithBias, worldPos, N, shadowBias);\n  }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    vec4 shadowPosWithDepthBias;\n    return CCSpotShadowFactorBase(shadowPosWithDepthBias, shadowPos, worldPos, shadowBias);\n  }\n#endif\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n\tcolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  vec3 SHEvaluate(vec3 normal)\n  {\n      vec3 result;\n  #if USE_INSTANCING\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(v_sh_linear_const_r, normal4);\n      result.g = dot(v_sh_linear_const_g, normal4);\n      result.b = dot(v_sh_linear_const_b, normal4);\n  #else\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(cc_sh_linear_const_r, normal4);\n      result.g = dot(cc_sh_linear_const_g, normal4);\n      result.b = dot(cc_sh_linear_const_b, normal4);\n      vec4 n14 = normal.xyzz * normal.yzzx;\n      float n5 = normal.x * normal.x - normal.y * normal.y;\n      result.r += dot(cc_sh_quadratic_r, n14);\n      result.g += dot(cc_sh_quadratic_g, n14);\n      result.b += dot(cc_sh_quadratic_b, n14);\n      result += (cc_sh_quadratic_a.rgb * n5);\n  #endif\n    #if CC_USE_HDR\n      result *= cc_exposure.w * cc_exposure.x;\n    #endif\n    return result;\n  }\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n  };\n  vec4 GetTexData(sampler2D dataMap, float dataMapWidth, float x, float uv_y)\n  {\n    return vec4(\n        decode32(texture(dataMap, vec2(((x + 0.5)/dataMapWidth), uv_y))),\n        decode32(texture(dataMap, vec2(((x + 1.5)/dataMapWidth), uv_y))),\n        decode32(texture(dataMap, vec2(((x + 2.5)/dataMapWidth), uv_y))),\n        decode32(texture(dataMap, vec2(((x + 3.5)/dataMapWidth), uv_y)))\n      );\n  }\n  void GetPlanarReflectionProbeData(out vec4 plane, out float planarReflectionDepthScale, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        plane.xyz = texData1.xyz;\n        plane.w = texData2.x;\n        planarReflectionDepthScale = texData2.y;\n        mipCount = texData2.z;\n      #else\n        plane = cc_reflectionProbeData1;\n        planarReflectionDepthScale = cc_reflectionProbeData2.x;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n  }\n  void GetCubeReflectionProbeData(out vec3 centerPos, out vec3 boxHalfSize, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        centerPos = texData1.xyz;\n        boxHalfSize = texData2.xyz;\n        mipCount = texData3.x;\n      #else\n        centerPos = cc_reflectionProbeData1.xyz;\n        boxHalfSize = cc_reflectionProbeData2.xyz;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n  }\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n  void SampleAndDecodeLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  #if CC_LIGHT_MAP_VERSION > 2\n  #elif CC_LIGHT_MAP_VERSION > 1\n  \tvec4 dataLow = texture(lightingMap, luv);\n  \tvec4 dataHigh = texture(lightingMap, luv + vec2(0.5, 0.0));\n  \tlightmapColor.xyz = dataLow.xyz + dataHigh.xyz * 0.00392156862745098;\n      lightmapColor.rgb *= lum;\n  \tdirShadow = dataLow.a;\n  \tao = dataHigh.a;\n  #else\n      vec4 lightmap = texture(lightingMap, luv);\n      lightmapColor = lightmap.rgb * lum;\n  \tdirShadow = lightmap.a;\n  \tao = 1.0;\n  #endif\n  }\n  void GetLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  \tvec4 lightmap;\n  \tvec2 occlusion;\n  \tSampleAndDecodeLightMapColor(lightmapColor, dirShadow, ao, lightingMap, luv, lum, worldNormal);\n  #if CC_USE_HDR\n      lightmapColor.rgb *= cc_exposure.w * cc_exposure.x;\n  #endif\n  }\n#endif\nlayout(std140) uniform Constants {\n  vec4  tilingOffset;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float emissiveScale;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\n#define DCC_APP_OTHERS 0\n#define DCC_APP_MAX 1\n#define DCC_APP_BLENDER 2\n#define DCC_APP_CINEMA4D 3\n#define DCC_APP_GLTF 4\n#define DCC_APP_MAYA 5\n#if USE_SHININESS_MAP\n  uniform sampler2D shininessExponentMap;\n#endif\n#if USE_SPECULAR_GLOSSINESS_MAP\n  uniform sampler2D specularGlossinessMap;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n #if USE_METALLIC_MAP\n  uniform sampler2D metallicMap;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_EMISSIVESCALE_MAP\n  uniform sampler2D emissiveScaleMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\nfloat discolor(vec3 srcColor)\n{\n  return dot(GRAY_VECTOR, srcColor);\n}\nfloat convertShininessExponent(float shininessExp)\n{\n  #if DCC_APP_NAME == DCC_APP_BLENDER\n    float glossiness = clamp(sqrt(shininessExp) * 0.1, 0.0, 0.95);\n  #elif DCC_APP_NAME == DCC_APP_MAX || DCC_APP_NAME == DCC_APP_MAYA\n    float l2 = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n    float glossiness = pow(l2, 0.5);\n  #else\n    float glossiness = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n  #endif\n    return glossiness;\n}\nfloat getSpecularIntensityFromRoughness(float roughness)\n{\n  #if DCC_APP_NAME == DCC_APP_BLENDER\n    float specularIntensityMultiplier = mix(1.0, 5.0, roughness);\n  #elif DCC_APP_NAME == DCC_APP_CINEMA4D\n    float specularIntensityMultiplier = mix(1.0, 50.0, roughness);\n  #elif DCC_APP_NAME == DCC_APP_MAX || DCC_APP_NAME == DCC_APP_MAYA\n    float specularIntensityMultiplier = mix(1.0, 20.0, roughness);\n  #else\n    float specularIntensityMultiplier = 1.0;\n  #endif\n    return specularIntensityMultiplier;\n}\nvec4 getSpecularColorAndFactor()\n{\n  vec3 inSpecular = specularColor.rgb * specularFactor;\n  float inFactor = 1.0;\n  #if USE_SPECULAR_GLOSSINESS_MAP\n    inSpecular = SRGBToLinear(texture(specularGlossinessMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_SPECULAR_MAP\n      vec4 specularTex = texture(specularMap, TEXTURE_UV);\n      specularTex.rgb = SRGBToLinear(specularTex.rgb);\n      inSpecular = specularTex.rgb;\n  #endif\n  return vec4(inSpecular, inFactor);\n}\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n  vec3 normal = FSInput_worldNormal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    normal = CalculateNormalFromTangentSpace(nmmp, normalScale, normalize(normal.xyz), normalize(FSInput_worldTangent), FSInput_mirrorNormal);\n  #endif\n  return normalize(normal);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n  vec3 emissiveColor = emissive.rgb;\n  #if USE_EMISSIVE_MAP\n      emissiveColor.rgb = SRGBToLinear(texture(emissiveMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_EMISSIVESCALE_MAP\n      vec4 emissiveScaleColor = texture(emissiveScaleMap, TEXTURE_UV);\n      emissiveScaleColor.rgb = SRGBToLinear(emissiveScaleColor.rgb);\n      emissiveColor.rgb *= emissiveScaleColor.rgb;\n  #else\n      emissiveColor.rgb *= emissiveScale;\n  #endif\n  return emissiveColor;\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nstruct SurfacesMaterialData\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPos, worldPos_fract_part;\n  #else\n  vec3 worldPos;\n  #endif\n  vec4 baseColor;\n  vec3 worldNormal;\n  vec3 emissive;\n  float specularIntensity;\n  float roughness;\n  float metallic;\n  float ao;\n  vec3 worldTangent, worldBinormal;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 outScatteringColor, inScatteringColor;\n  vec4 transmitScatteringParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 baseColor2ndSpecular, color2ndSpecular;\n  float intensity2ndSpecular, roughness2ndSpecular;\n  vec3 worldNormal2ndSpecular, worldTangent2ndSpecular, worldBinormal2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  vec4 sssParams;\n#endif\n};\nvoid SurfacesFragmentModifySharedData(inout SurfacesMaterialData surfaceData)\n{\n    vec4 baseColor = vec4(1.0);\n    #if USE_VERTEX_COLOR\n      baseColor.rgb *= SRGBToLinear(FSInput_vertexColor.rgb);\n      baseColor.a *= FSInput_vertexColor.a;\n    #endif\n    #if USE_ALBEDO_MAP\n      vec4 texColor = texture(albedoMap, TEXTURE_UV);\n      texColor.rgb = SRGBToLinear(texColor.rgb);\n      texColor.a *= transparencyFactor;\n      baseColor *= texColor;\n    #else\n      baseColor *= diffuseColor;\n    #endif\n    baseColor.rgb *= diffuseFactor;\n    #if USE_TRANSPARENCY_MAP\n      baseColor.a = texture(transparencyMap, TEXTURE_UV).TRANSPARENCY_MAP_CHANNEL;\n      #if DCC_APP_NAME == DCC_APP_MAYA\n        baseColor.a = 1.0 - baseColor.a;\n      #endif\n    #endif\n    #if USE_ALPHA_TEST\n      if (baseColor.a < alphaThreshold) discard;\n    #endif\n    vec4 specularColorAndFactor = getSpecularColorAndFactor();\n    float inGlossiness = 0.0, inSpecularIntensity = 1.0;\n    #if HAS_EXPORTED_GLOSSINESS\n      #if USE_SPECULAR_GLOSSINESS_MAP\n        inGlossiness = 1.0 - texture(specularGlossinessMap, TEXTURE_UV).a;\n      #else\n        inGlossiness = glossiness;\n      #endif\n    #else\n      #if USE_SHININESS_MAP\n        #if GLOSSINESS_MAP_USE_SINGLE_CHANNEL\n          inGlossiness = 1.0 - texture(shininessExponentMap, TEXTURE_UV).GLOSSINESS_MAP_CHANNEL;\n        #else\n          inGlossiness = 1.0 - discolor(texture(shininessExponentMap, TEXTURE_UV).rgb);\n        #endif\n      #else\n        inGlossiness = convertShininessExponent(shininessExponent);\n      #endif\n      inSpecularIntensity *= getSpecularIntensityFromRoughness(1.0 - inGlossiness);\n    #endif\n    float inMetallic = 0.0;\n    vec3 albedo = baseColor.rgb;\n    #if HAS_EXPORTED_METALLIC\n      inMetallic = metallic;\n      float spec = specularFactor;\n      #if USE_SPECULAR_MAP\n        spec = dot(GRAY_VECTOR, texture(specularMap, TEXTURE_UV).rgb);\n      #endif\n      inSpecularIntensity *= spec * 0.5;\n    #else\n      GetMetallicAlbedoFromDiffuseSpecularWithoutColor(inMetallic, albedo.rgb, baseColor.rgb, specularColorAndFactor.rgb, 0.04);\n      inSpecularIntensity *= inMetallic;\n    #endif\n    baseColor.rgb = albedo;\n    surfaceData.baseColor = baseColor;\n    surfaceData.specularIntensity = inSpecularIntensity * 0.5;\n    surfaceData.roughness = 1.0 - inGlossiness;\n    surfaceData.metallic = inMetallic;\n    surfaceData.ao = 1.0;\n    #if USE_OCCLUSION_MAP\n      surfaceData.ao = texture(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;\n    #endif\n}\nstruct LightingIntermediateData\n{\n  vec3 N, H, L, V;\n  float distToLight, distToLightSqr;\n  float distToCamera, distToCameraSqr;\n  float angleAttenuation, distAttenuation;\n  float NoL, NoV, NoH;\n  float NoLSat, NoVSat, NoHSat;\n  float NoVAbsSat;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPosition, worldPosition_fract_part;\n  #else\n  vec3 worldPosition;\n  #endif\n  vec3 T, B;\n  float specularParam;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 shadowPosAndDepth;\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitScatteringParams;\n  vec3 outScatteringColor, inScatteringColor;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n};\nvoid CCSurfacesLightingGetIntermediateData_PerPixel(inout LightingIntermediateData data, vec3 worldNormal, vec3 worldPos, vec3 worldTangent, vec3 worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n    , float anisotropyShape\n#endif\n)\n{\n  data.N = worldNormal;\n  data.V = cc_cameraPos.xyz - worldPos;\n  data.distToCameraSqr = dot(data.V, data.V);\n  data.distToCamera = sqrt(data.distToCameraSqr);\n  data.V /= data.distToCamera;\n  data.angleAttenuation = data.distAttenuation = 1.0;\n  data.NoV = dot(data.N, data.V);\n  data.NoVSat = max(data.NoV, 0.0);\n  data.NoVAbsSat = max(abs(data.NoV), 0.0);\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(data.worldPosition, data.worldPosition_fract_part, worldPos);\n  #else\n  data.worldPosition = worldPos;\n  #endif\n  data.T = worldTangent;\n  data.B = worldBinormal;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  data.anisotropyShape = anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  data.outScatteringColor = vec3(1.0);\n  data.inScatteringColor = vec3(0.0);\n  data.transmitScatteringParams = vec4(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  data.shadowPosAndDepth = vec4(0.0, 0.0, SURFACES_MAX_TRANSMIT_DEPTH_VALUE, SURFACES_MAX_TRANSMIT_DEPTH_VALUE);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  data.baseColorTT = vec3(0.0);\n  data.ttIntensity = data.ttScatterCoef = 0.0;\n#endif\n}\nvoid CCSurfacesLightingGetIntermediateData_PerLight(inout LightingIntermediateData data, vec3 lightDirWithDist)\n{\n  data.L = lightDirWithDist;\n  data.distToLightSqr = dot(data.L, data.L);\n  data.distToLight = sqrt(data.distToLightSqr);\n  data.L /= data.distToLight;\n  data.H = normalize(data.L + data.V);\n  data.NoL = dot(data.N, data.L);\n  data.NoH = dot(data.N, data.H);\n  data.NoLSat = max(data.NoL, 0.0);\n  data.NoHSat = max(data.NoH, 0.0);\n}\nstruct LightingResult\n{\n  vec3 diffuseColorWithLighting, specularColorWithLighting, specularColorWithEnvLighting;\n  vec3 directDiffuse, directSpecular;\n  vec3 environmentDiffuse, environmentSpecular;\n  float shadow, ao;\n  vec3 lightmapColor;\n  vec3 emissive;\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float fresnel;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  vec3 directTransmitSpecular, environmentTransmitSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 directTransmitDiffuse, environmentTransmitDiffuse;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 direct2ndSpecular, environment2ndSpecular;\n  vec3 specularColorWithLighting2ndSpecular, specularColorWithEnvLighting2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 directTT;\n  vec3 diffuseColorWithLightingTT;\n#endif\n};\nstruct LightingMiscData\n{\n  float lightType;\n  vec3 lightPos, lightDir;\n  vec4 lightColorAndIntensity;\n  vec4 lightSizeRangeAngle;\n};\nfloat D_GGX(float roughness, float NoH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float d = (NoH * m2 - NoH) * NoH + 1.0;\n    return m2 / max(EPSILON, d * d);\n}\nfloat D_GGXMobile(float roughness, float NoH) {\n  float OneMinusNoHSqr = 1.0 - NoH * NoH;\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / max(EPSILON, OneMinusNoHSqr + n * n);\n  return p * p;\n}\nvoid GetAnisotropicRoughness(float roughness, float anisotropyShape, out float roughnessX, out float roughnessY)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    float r1 = roughness, r2 = roughness;\n    float lerpedRoughness = mix(1.0, 10.0, anisotropyShape);\n    r2 *= shapeSign < 0.0 ? lerpedRoughness : 1.0;\n    r1 *= shapeSign > 0.0 ? lerpedRoughness : 1.0;\n    roughnessX = saturate(r1);\n    roughnessY = saturate(r2);\n}\nfloat D_GGXAniso(float RoughnessX, float RoughnessY, float NoH, vec3 H, vec3 X, vec3 Y)\n{\n    float mx = max(EPSILON_LOWP, RoughnessX * RoughnessX);\n    float my = max(EPSILON_LOWP, RoughnessY * RoughnessY);\n    float XoH = dot(X, H);\n    float YoH = dot(Y, H);\n    float d = XoH * XoH / (mx * mx) + YoH * YoH / (my * my) + NoH * NoH;\n    return 1.0 / max(EPSILON_LOWP, mx * my * d * d);\n}\nvec3 GetAnisotropicReflect(float roughness, float anisotropyShape, vec3 V, vec3 N, vec3 X, vec3 Y)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    anisotropyShape = min(anisotropyShape, 0.4);\n    anisotropyShape *= smoothstep(0.0, 0.03, roughness);\n    vec3 reflectTarget = shapeSign < 0.0 ? mix(N, -Y, anisotropyShape) :\n                         shapeSign > 0.0 ? mix(N, -X, anisotropyShape) : N;\n    return reflect(-V, reflectTarget);\n}\nvec3 IntegratedGFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return max(vec3(0.0), specular * AB.x + AB.y);\n}\n#define DiffuseCoefficient_EnergyConservation INV_PI\nfloat CalculateFresnelCoefficient(float ior, float NoVSat)\n{\n\tfloat g, c, n, prev, next;\n\tn = ior;\n\tc = ior * NoVSat;\n\tg = sqrt(1.0 + c * c - c);\n\tprev = (g - c) / (g + c);\n\tnext = (c * (g+c) - n*n) / (c * (g-c) + n*n);\n\tprev *= prev;\n\tnext *= next;\n\treturn 0.5 * prev * (1.0 + next);\n}\nvec3 CalculateScattering(vec3 unscatteredColor, float distance, float outScatterExtinctCoef, float inScatterExtinctCoef, float inScatterCoef, vec3 inScatterColor, vec3 outScatterColor)\n{\n    vec2 e = vec2(outScatterExtinctCoef, inScatterExtinctCoef * inScatterCoef);\n    vec2 extinction = exp(-e * distance);\n    vec3 inScattered = (1.0 - extinction.y) * inScatterColor;\n\tvec3 outScattered = unscatteredColor * extinction.x * outScatterColor;\n    return outScattered + inScattered;\n}\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat CalculateDistanceAttenuation(float distToLightSqr, float lightRadius, float lightRange)\n{\n  float litRadiusSqr = lightRadius * lightRadius;\n  float attRadiusSqrInv = 1.0 / max(lightRange, 0.01);\n  attRadiusSqrInv *= attRadiusSqrInv;\n  float edgeAttenuation = litRadiusSqr / max(litRadiusSqr, distToLightSqr);\n  return GetDistAtt(distToLightSqr, attRadiusSqrInv) * edgeAttenuation;\n}\nfloat CalculateAngleAttenuation(vec3 spotLightDir, vec3 L, float cosAngleOuter)\n{\n  float cosInner = max(dot(spotLightDir, L), 0.01);\n  float litAngleScale = 1.0 / max(0.001, cosInner - cosAngleOuter);\n  float litAngleOffset = -cosAngleOuter * litAngleScale;\n  return GetAngleAtt(L, spotLightDir, litAngleScale, litAngleOffset);\n}\nvec3 CalculateRefractDirection(vec3 N, vec3 V, float NoV, float ior)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  float cosA = abs(NoV);\n  float sinA = sqrt(1.0 - cosA * cosA);\n  float sinB = saturate(sinA / ior);\n  float cosB = sqrt(1.0 - sinB * sinB);\n  vec3 edgeA = -V + N * cosA;\n  vec3 edgeB = normalize(edgeA) * sinB;\n  vec3 R = edgeB - N * cosB;\n  return R;\n}\nvec3 CalculateReflectDirection(vec3 N, vec3 V, float NoV)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  return reflect(-V, N);\n}\nvec3 CalculatePlanarReflectPositionOnPlane(vec3 N, vec3 V, vec3 worldPos, vec4 plane, vec3 cameraPos, float probeReflectedDepth)\n{\n  float distPixelToPlane = -dot(plane, vec4(worldPos, 1.0));\n  plane.w += distPixelToPlane;\n  float distCameraToPlane = abs(-dot(plane, vec4(cameraPos, 1.0)));\n  vec3 planeN = plane.xyz;\n  vec3 virtualCameraPos = cameraPos - 2.0 * distCameraToPlane * planeN;\n  vec3 bumpedR = normalize(reflect(-V, N));\n  vec3 reflectedPointPos = worldPos + probeReflectedDepth * bumpedR;\n  vec3 virtualCameraToReflectedPoint = normalize(reflectedPointPos - virtualCameraPos);\n  float y = distCameraToPlane / max(EPSILON_LOWP, dot(planeN, virtualCameraToReflectedPoint));\n  return virtualCameraPos + y * virtualCameraToReflectedPoint;\n}\nvec4 CalculateBoxProjectedDirection(vec3 R, vec3 worldPos, vec3 cubeCenterPos, vec3 cubeBoxHalfSize)\n{\n  vec3 W = worldPos - cubeCenterPos;\n  vec3 projectedLength = (sign(R) * cubeBoxHalfSize - W) / (R + vec3(EPSILON));\n  float len = min(min(projectedLength.x, projectedLength.y), projectedLength.z);\n  vec3 P = W + len * R;\n  float weight = len < 0.0 ? 0.0 : 1.0;\n  return vec4(P, weight);\n}\nvec3 CalculateDirectDiffuse(in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    return irradiance * DiffuseCoefficient_EnergyConservation;\n}\nvec3 CalculateDirectSpecular(in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    float roughness = lightingData.specularParam;\n  #if CC_SURFACES_LIGHTING_ANISOTROPIC\n      float rT, rB;\n      GetAnisotropicRoughness(roughness, lightingData.anisotropyShape, rT, rB);\n      float calcSpec = D_GGXAniso(rT, rB, lightingData.NoHSat, lightingData.H, lightingData.T, lightingData.B);\n  #else\n    #if CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n      float calcSpec = (roughness * 0.25 + 0.25) * D_GGXMobile(roughness, lightingData.NoHSat);\n    #else\n      float calcSpec = D_GGX(roughness, lightingData.NoHSat);\n    #endif\n  #endif\n    return irradiance * calcSpec;\n}\n#if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  vec3 EnvAnisotropicReflection(samplerCube tex, vec3 R, float roughness, float mipCount, float anisotropyShape, vec3 V, vec3 N, vec3 T, vec3 B) {\n      R = normalize(R);\n      float integratedBRDF = 0.0;\n      vec3 envSpec = vec3(0.0);\n      const int SAMPLE_STEP_COUNT = CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT;\n      float sampleAngleRange = PI * abs(anisotropyShape);\n      vec3 anisoDirection = anisotropyShape < 0.0 ? T : B;\n      vec3 ROnNormalPlane = normalize(R - anisoDirection * dot(R, anisoDirection));\n      vec3 stepOffset = normalize(ROnNormalPlane - N) * (sampleAngleRange / float(SAMPLE_STEP_COUNT * 2));\n      for (int i = -SAMPLE_STEP_COUNT; i <= SAMPLE_STEP_COUNT; ++i)\n      {\n          float rT, rB;\n          GetAnisotropicRoughness(roughness, anisotropyShape, rT, rB);\n          #if CC_IBL_CONVOLUTED\n            float coef = abs(float(i)) / float(SAMPLE_STEP_COUNT) * float(SAMPLE_STEP_COUNT);\n          #else\n            float coef = pow(abs(float(i)) / float(SAMPLE_STEP_COUNT), 1.3) * float(SAMPLE_STEP_COUNT);\n          #endif\n          vec3 H = normalize(N + stepOffset * sign(float(i)) * coef);\n          vec3 L = reflect(-V, H);\n          float NoHSat = saturate(dot(N, H));\n          float calcSpec = D_GGXAniso(rT, rB, NoHSat, H, T, B);\n          envSpec += calcSpec * EnvReflection(tex, L, roughness, mipCount);\n          integratedBRDF += calcSpec;\n      }\n      envSpec /= integratedBRDF;\n      return envSpec;\n  }\n#endif\nvec3 SampleEnvironmentSpecular(samplerCube tex, in LightingIntermediateData lightingData, float mipCount)\n{\n    vec3 envSpec = vec3(0.0);\n    float roughness = lightingData.specularParam;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV);\n    #endif\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(tex, R, roughness, mipCount, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, mipCount, 0.6);\n      #else\n        envSpec = EnvReflection(tex, R, roughness, mipCount);\n      #endif\n    #endif\n    return envSpec;\n}\nvec3 SampleEnvironmentSpecular(samplerCube tex, in LightingIntermediateData lightingData, float mipCount, vec3 worldPos, vec3 cubeCenterPos, vec3 boxHalfSize)\n{\n    vec3 envSpec = vec3(0.0);\n    float roughness = lightingData.specularParam;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV);\n    #endif\n    vec4 fixedR = CalculateBoxProjectedDirection(R, worldPos, cubeCenterPos, boxHalfSize);\n    R = fixedR.xyz;\n    vec3 envmap = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w).xyz;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(tex, fixedR.xyz, roughness, mipCount, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n      envSpec = mix(envmap, envSpec, fixedR.w);\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, mipCount, 0.6);\n      #else\n        envSpec = mix(envmap, EnvReflection(tex, R, roughness, mipCount), fixedR.w);\n      #endif\n    #endif\n    return envSpec;\n}\nvec3 CalculateEnvironmentDiffuse(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  float fAmb = max(EPSILON, 0.5 - lightingData.N.y * 0.5);\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP && !CC_USE_LIGHT_PROBE\n      vec3 rotationDir = RotationVecFromAxisY(lightingData.N, cc_surfaceTransform.z, cc_surfaceTransform.w);\n      vec4 diffuseMap = texture(cc_diffuseMap, rotationDir);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n  #endif\n  ambDiff.rgb *= lightIntensity;\n  #if CC_USE_LIGHT_PROBE\n    ambDiff.rgb += SHEvaluate(lightingData.N);\n  #endif\n  return ambDiff.rgb;\n}\nvec3 CalculateEnvironmentSpecular(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  vec3 envSpec = vec3(0.0);\n#if CC_USE_REFLECTION_PROBE\n    vec3 worldPos;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    worldPos = unpackHighpData(lightingData.worldPosition, lightingData.worldPosition_fract_part);\n    #else\n    worldPos = lightingData.worldPosition;\n    #endif\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n    if(FSInput_reflectionProbeId < 0.0){\n        envSpec = SampleEnvironmentSpecular(cc_reflectionProbeCubemap, lightingData, cc_ambientGround.w);\n    }else{\n      vec3 centerPos, boxHalfSize;\n      float mipCount;\n      GetCubeReflectionProbeData(centerPos, boxHalfSize, mipCount, FSInput_reflectionProbeId);\n      envSpec = SampleEnvironmentSpecular(cc_reflectionProbeCubemap, lightingData, mipCount, worldPos, centerPos, boxHalfSize);\n    }\n  #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_PLANAR\n    vec3 R = normalize(CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV));\n    if(FSInput_reflectionProbeId < 0.0){\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPos, cc_matViewProj, cc_cameraPos.w, lightingData.V, R);\n        envSpec = unpackRGBE(fragTextureLod(cc_reflectionProbePlanarMap, screenUV, 1.0)).xyz;\n    }else{\n        vec4 plane;\n        float planarReflectionDepthScale, mipCount;\n        GetPlanarReflectionProbeData(plane, planarReflectionDepthScale, mipCount, FSInput_reflectionProbeId);\n        vec3 worldPosOffset = CalculatePlanarReflectPositionOnPlane(lightingData.N, lightingData.V, worldPos, plane, cc_cameraPos.xyz, planarReflectionDepthScale);\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPosOffset, cc_matViewProj, cc_cameraPos.w, lightingData.V, R);\n        envSpec = unpackRGBE(fragTextureLod(cc_reflectionProbePlanarMap, screenUV, mipCount)).xyz;\n    }\n  #endif\n#elif CC_USE_IBL\n    envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n#endif\n  return envSpec * lightIntensity;\n}\nbool CCSurfacesLightingEnableShadow(in float NoL)\n{\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  return true;\n#elif CC_SURFACES_LIGHTING_SSS\n  return true;\n#else\n  return NoL > 0.0;\n#endif\n}\nfloat CCSurfacesLightingCalculateDistanceAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle)\n{\n  return CalculateDistanceAttenuation(lightingData.distToLightSqr, lightSizeRangeAngle.x, lightSizeRangeAngle.y);\n}\nfloat CCSurfacesLightingCalculateAngleAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle, in vec3 spotLightDir)\n{\n  return CalculateAngleAttenuation(spotLightDir, lightingData.L, lightSizeRangeAngle.z);\n}\nvoid CCSurfacesLightingCalculateDirect(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n#if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n  lightingDiffuse = CalculateDirectDiffuse(lightingData, lightSourceColorAndIntensity);\n#else\n  lightingDiffuse = vec3(0.0);\n#endif\n#if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n  lightingSpecular = CalculateDirectSpecular(lightingData, lightSourceColorAndIntensity);\n#else\n  lightingSpecular = vec3(0.0);\n#endif\n}\nvoid CCSurfacesLightingCalculateEnvironment(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n{\n#if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n  lightingDiffuse = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n#else\n  lightingDiffuse = vec3(0.0);\n#endif\n#if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n  lightingSpecular = CalculateEnvironmentSpecular(lightingData, lightIntensity);\n#else\n  lightingSpecular = vec3(0.0);\n#endif\n}\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float CCSurfaceLightingCalculateFresnel(in LightingIntermediateData lightingData)\n  {\n    return CalculateFresnelCoefficient(lightingData.ior, abs(lightingData.NoV));\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  void CCSurfacesLightingCalculateDirectTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    float roughness = lightingData.specularParam;\n    float NoLSat = saturate(dot(lightingData.N, -lightingData.L));\n    vec3 irradiance = NoLSat * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float RoL = dot(lightingData.L, normalize(R));\n    float calcSpec = D_GGX(roughness, saturate(RoL));\n    lightingSpecular = irradiance * calcSpec;\n  }\n  void CCSurfacesLightingCalculateEnvironmentTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n  {\n    vec3 envSpec = vec3(0.0);\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float roughness = lightingData.specularParam;\n  #if CC_USE_REFLECTION_PROBE\n    #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n      envSpec = EnvReflection(cc_reflectionProbeCubemap, R, roughness, cc_ambientGround.w);\n    #endif\n  #endif\n  #if CC_USE_IBL && CC_USE_REFLECTION_PROBE != REFLECTION_PROBE_TYPE_CUBE\n    envSpec = EnvReflection(cc_environment, R, roughness, cc_ambientGround.w);\n  #endif\n    lightingSpecular = CalculateScattering(envSpec * lightIntensity, lightingData.transmitScatteringParams.w, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define objectThickness lightingData.transmitDiffuseParams.x\n  #define transmitMask lightingData.transmitDiffuseParams.y\n  #define envTransmitScale lightingData.transmitDiffuseParams.z\n  #define envFixedDistanceScale lightingData.transmitScatteringParams.w\n  #define transmitDistanceScale lightingData.transmitDiffuseParams.w\n  #define DONOT_USE_SHADOWMAP_DISTANCE ((abs(float(lightingData.shadowPosAndDepth.z) - float(lightingData.shadowPosAndDepth.w)) < EPSILON) && (abs(float(lightingData.shadowPosAndDepth.z) - float(SURFACES_MAX_TRANSMIT_DEPTH_VALUE)) < EPSILON))\n  #define SHADOWMAP_DISTANCE max(lightingData.shadowPosAndDepth.w - lightingData.shadowPosAndDepth.z, 0.0)\n  void CCSurfacesLightingCalculateDirectTransmitDiffuse(out vec3 transmitDiffuse, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity, float shadow)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n    float distance = lightingData.transmitScatteringParams.w;\n    if (!DONOT_USE_SHADOWMAP_DISTANCE)\n    {\n      distance = transmitDistanceScale * SHADOWMAP_DISTANCE;\n      shadow = step(SHADOWMAP_DISTANCE, objectThickness) > 0.0 ? 1.0 : shadow;\n    }\n    vec3 backIrradiance = CalculateDirectDiffuse(lightingData, lightSourceColorAndIntensity);\n    backIrradiance *= shadow * transmitMask;\n    transmitDiffuse = CalculateScattering(backIrradiance, distance, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n  #else\n    transmitDiffuse = vec3(0.0);\n  #endif\n  }\n  void CCSurfacesLightingCalculateEnvironmentTransmitDiffuse(out vec3 transmitDiffuse, in LightingIntermediateData lightingData, float lightIntensity, float ao, vec3 shadowLightDirection)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n    float distance = lightingData.transmitScatteringParams.w;\n    if (!DONOT_USE_SHADOWMAP_DISTANCE)\n    {\n      float shadowMapDistance = transmitDistanceScale * SHADOWMAP_DISTANCE;\n      float fixedDistance = transmitDistanceScale * envFixedDistanceScale;\n      float lerpCoef = saturate(dot(lightingData.N, shadowLightDirection));\n      distance = mix(fixedDistance, shadowMapDistance, lerpCoef);\n    }\n    vec3 backIrradiance = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n    backIrradiance *= ao * transmitMask;\n    transmitDiffuse = CalculateScattering(backIrradiance, distance, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n    transmitDiffuse *= envTransmitScale;\n  #else\n    transmitDiffuse = vec3(0.0);\n  #endif\n  }\n  #undef objectThickness\n  #undef transmitMask\n  #undef envTransmitScale\n  #undef envFixedDistanceScale\n  #undef DONOT_USE_SHADOWMAP_DISTANCE\n  #undef SHADOWMAP_DISTANCE\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #ifndef CC_SURFACES_FRAGMENT_MODIFY_2ND_SPECULAR_COLOR\n  #endif\n  void CCSurfacesLightingCalculateDirect2ndSpecular(out vec3 specularLighting, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity, float intensitySpecular, in vec3 originalSpecular)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n    vec3 unused;\n    CCSurfacesLightingCalculateDirect(unused, specularLighting, lightingData, lightSourceColorAndIntensity);\n    specularLighting *= intensitySpecular;\n  #else\n    specularLighting = vec3(0.0);\n  #endif\n  }\n  void CCSurfacesLightingCalculateEnvironment2ndSpecular(out vec3 specularLighting, in LightingIntermediateData lightingData, float lightIntensity, float intensitySpecular, in vec3 originalSpecular)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n    vec3 unused;\n    specularLighting = CalculateEnvironmentSpecular(lightingData, lightIntensity);\n    specularLighting *= intensitySpecular;\n  #else\n    specularLighting = vec3(0.0);\n  #endif\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  void CCSurfacesLightingCalculateDirectTT(inout LightingResult lightingResult, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    lightingResult.diffuseColorWithLightingTT = lightingResult.diffuseColorWithLighting;\n    float w = lightingData.ttIntensity;\n    vec3 scatteredLighting = pow(saturate(lightingData.baseColorTT * w + lightingData.NoLSat) * lightingData.NoLSat, vec3(mix(0.5, 0.5 + lightingData.ttScatterCoef, w)));\n    vec3 ttLighting = scatteredLighting - lightingData.NoLSat;\n    lightingResult.directTT = ttLighting * DiffuseCoefficient_EnergyConservation * lightSourceColorAndIntensity.xyz* lightSourceColorAndIntensity.w;\n  }\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n    return FSInput_vertexColor;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n    return normalize(FSInput_worldNormal);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_TANGENT_AND_BINORMAL\nvoid SurfacesFragmentModifyWorldTangentAndBinormal(inout vec3 worldTangent, inout vec3 worldBinormal, vec3 worldNormal)\n{\n    vec3 tangent = normalize(FSInput_worldTangent);\n#if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 binormal = normalize(CalculateBinormal(worldNormal.xyz, tangent, FSInput_mirrorNormal));\n    tangent = normalize(cross(binormal, worldNormal));\n#else\n    vec3 binormal = vec3(0.0, 0.0, 0.0);\n#endif\n    worldTangent = tangent;\n    worldBinormal = binormal;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_IOR\nfloat SurfacesFragmentModifyIOR()\n{\n    return 1.0;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\nvec4 SurfacesFragmentModifyAnisotropyParams(out float isRotation)\n{\n    isRotation = 1.0;\n    return vec4(1.0, 0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvec4 SurfacesFragmentModifyPBRParams()\n{\n    return vec4(1.0, 0.5, 0.0, 0.5);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_SCATTERING_PARAMS\nvec4 SurfacesFragmentModifyTransmitScatteringParams()\n{\n    return vec4(1.0, 1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_IN_SCATTERING_COLOR\nvec3 SurfacesFragmentModifyTransmitInScatteringColor()\n{\n    return vec3(0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_OUT_SCATTERING_COLOR\nvec3 SurfacesFragmentModifyTransmitOutScatteringColor()\n{\n    return vec3(1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_DIFFUSE_PARAMS\nvec4 SurfacesFragmentModifyTransmitDiffuseParams()\n{\n    return vec4(1.0, 1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_PARAMS\nvec4 SurfacesFragmentModifyTRTParams()\n{\n    return vec4(0.2, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_COLOR\nvec3 SurfacesFragmentModifyTRTColor()\n{\n    return vec3(1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TT_PARAMS\nvec4 SurfacesFragmentModifyTTParams()\n{\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TT_COLOR\nvec3 SurfacesFragmentModifyTTColor(in vec3 baseColor)\n{\n    return vec3(1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_DUAL_LOBE_SPECULAR_PARAMS\nvec4 SurfacesFragmentModifyDualLobeSpecularParams(float roughness)\n{\n    return vec4(0.2, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SSS_PARAMS\nvec4 SurfacesFragmentModifySSSParams()\n{\n    return vec4(1.0, 0.1, 1.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nvoid SurfacesFragmentModifySharedData(inout SurfacesMaterialData surfaceData)\n{\n}\n#endif\nvoid CCSurfacesFragmentGetMaterialData(inout SurfacesMaterialData surfaceData)\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part, FSInput_worldPos);\n  #else\n  surfaceData.worldPos = FSInput_worldPos;\n  #endif\n  surfaceData.baseColor = SurfacesFragmentModifyBaseColorAndTransparency();\n  surfaceData.worldNormal = SurfacesFragmentModifyWorldNormal();\n  SurfacesFragmentModifyWorldTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal);\n  surfaceData.ior = SurfacesFragmentModifyIOR();\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float isRotation;\n  vec4 anisotropyParams = SurfacesFragmentModifyAnisotropyParams(isRotation);\n  surfaceData.anisotropyShape = anisotropyParams.x;\n  if (isRotation > 0.0) {\n    RotateTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal, anisotropyParams.y);\n  } else {\n    vec3 anisoDirTS = anisotropyParams.yzw;\n    vec3 tangentWS = anisoDirTS.x * surfaceData.worldTangent + anisoDirTS.y * surfaceData.worldBinormal + anisoDirTS.z * surfaceData.worldNormal;\n    surfaceData.worldTangent = normalize(tangentWS);\n    surfaceData.worldBinormal = cross(surfaceData.worldNormal, tangentWS);\n  }\n#endif\n  surfaceData.emissive = SurfacesFragmentModifyEmissive();\n  vec4 pbr = SurfacesFragmentModifyPBRParams();\n  surfaceData.ao = pbr.x;\n  surfaceData.roughness = pbr.y;\n  surfaceData.metallic = pbr.z;\n  surfaceData.specularIntensity = pbr.w;\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  surfaceData.transmitScatteringParams = SurfacesFragmentModifyTransmitScatteringParams();\n  surfaceData.inScatteringColor = SurfacesFragmentModifyTransmitInScatteringColor();\n  surfaceData.outScatteringColor = SurfacesFragmentModifyTransmitOutScatteringColor();\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  surfaceData.transmitDiffuseParams = SurfacesFragmentModifyTransmitDiffuseParams();\n#endif\n#if CC_SURFACES_LIGHTING_TRT\n  vec4 trtParams = SurfacesFragmentModifyTRTParams();\n  surfaceData.roughness2ndSpecular = saturate(surfaceData.roughness + trtParams.x);\n  surfaceData.intensity2ndSpecular = trtParams.w;\n  surfaceData.baseColor2ndSpecular = vec3(1.0);\n  surfaceData.color2ndSpecular = SurfacesFragmentModifyTRTColor();\n  surfaceData.worldNormal2ndSpecular = surfaceData.worldNormal;\n  surfaceData.worldTangent2ndSpecular = surfaceData.worldTangent;\n  surfaceData.worldBinormal2ndSpecular = surfaceData.worldBinormal;\n  RotateNormalAndBinormal(surfaceData.worldBinormal2ndSpecular, surfaceData.worldNormal2ndSpecular, surfaceData.worldTangent2ndSpecular, trtParams.y, FSInput_mirrorNormal);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec4 ttParams = SurfacesFragmentModifyTTParams();\n  surfaceData.ttScatterCoef = ttParams.x;\n  surfaceData.ttIntensity = ttParams.w;\n  surfaceData.baseColorTT = SurfacesFragmentModifyTTColor(surfaceData.baseColor.rgb);\n#endif\n#if CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  vec4 dualLobeParams = SurfacesFragmentModifyDualLobeSpecularParams(surfaceData.roughness);\n  surfaceData.roughness2ndSpecular = saturate(dualLobeParams.x);\n  surfaceData.intensity2ndSpecular = dualLobeParams.w;\n  surfaceData.baseColor2ndSpecular = surfaceData.baseColor.rgb;\n  surfaceData.color2ndSpecular = vec3(1.0);\n  surfaceData.worldNormal2ndSpecular = surfaceData.worldNormal;\n  surfaceData.worldTangent2ndSpecular = surfaceData.worldTangent;\n  surfaceData.worldBinormal2ndSpecular = surfaceData.worldBinormal;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  surfaceData.sssParams = SurfacesFragmentModifySSSParams();\n#endif\n  SurfacesFragmentModifySharedData(surfaceData);\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP) {\n      surfaceData.worldNormal = normalize(FSInput_worldNormal);\n      surfaceData.worldTangent = normalize(FSInput_worldTangent);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW\n  if (!IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO)\n  {\n      surfaceData.baseColor.rgb = vec3(1.0);\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        surfaceData.baseColor2ndSpecular.rgb = vec3(1.0);\n      #endif\n      #if CC_SURFACES_LIGHTING_TT\n        surfaceData.baseColorTT.rgb = vec3(1.0);\n      #endif\n  }\n#endif\n}\nvec3 CCSurfacesGetDiffuseColor(in SurfacesMaterialData surfaceData)\n{\n  return surfaceData.baseColor.rgb * (1.0 - surfaceData.metallic);\n}\nvec3 CCSurfacesGetSpecularColor(in SurfacesMaterialData surfaceData)\n{\n  float F0 = surfaceData.specularIntensity * 0.08;\n  return mix(vec3(F0), surfaceData.baseColor.rgb, surfaceData.metallic);\n}\nvoid CCSurfacesLightingInitializeColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, inout vec3 specularColorWithEnvLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n  diffuseColorWithLighting = CCSurfacesGetDiffuseColor(surfaceData);\n  specularColorWithLighting = CCSurfacesGetSpecularColor(surfaceData).xyz;\n  specularColorWithEnvLighting = IntegratedGFApprox(specularColorWithLighting, surfaceData.roughness, lightingData.NoVAbsSat);\n}\nvoid CCSurfacesLightingCalculateColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, inout vec3 specularColorWithEnvLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n}\nvoid CCSurfacesInitializeLightingIntermediateData(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  vec3 worldPos;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n  #else\n  worldPos = surfaceData.worldPos;\n  #endif\n  CCSurfacesLightingGetIntermediateData_PerPixel(lightingData, surfaceData.worldNormal, worldPos, surfaceData.worldTangent, surfaceData.worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n      , surfaceData.anisotropyShape\n#endif\n  );\n  lightingData.specularParam = surfaceData.roughness;\n  lightingData.ior = surfaceData.ior;\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingData.transmitScatteringParams = surfaceData.transmitScatteringParams;\n  lightingData.inScatteringColor = surfaceData.inScatteringColor;\n  lightingData.outScatteringColor = surfaceData.outScatteringColor;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingData.transmitDiffuseParams = surfaceData.transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  lightingData.baseColorTT = surfaceData.baseColorTT;\n  lightingData.ttIntensity = surfaceData.ttIntensity;\n  lightingData.ttScatterCoef = surfaceData.ttScatterCoef;\n#endif\n}\nvoid CCSurfacesLightingCalculateIntermediateData_PerLight(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData, vec3 lightDirWithDist)\n{\n  CCSurfacesLightingGetIntermediateData_PerLight(lightingData, lightDirWithDist);\n}\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\nvoid CCSurfacesGetLightingIntermediateDataTransmitDiffuse(inout LightingIntermediateData lightingDataTD, in LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  lightingDataTD = lightingData;\n  lightingDataTD.N = lightingData.transmitScatteringParams.z > 0.0 ? -FSInput_worldNormal : -(normalize(FSInput_worldNormal)+lightingData.V);\n  lightingDataTD.N = normalize(lightingDataTD.N);\n}\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\nvoid CCSurfacesGetSurfacesMaterialData2ndSpecular(inout SurfacesMaterialData surfaceData2ndSpecular, in SurfacesMaterialData surfaceData)\n{\n  surfaceData2ndSpecular = surfaceData;\n  surfaceData2ndSpecular.baseColor = vec4(surfaceData.baseColor2ndSpecular, 1.0);\n  surfaceData2ndSpecular.roughness = surfaceData.roughness2ndSpecular;\n  surfaceData2ndSpecular.worldNormal = surfaceData.worldNormal2ndSpecular;\n  surfaceData2ndSpecular.worldTangent = surfaceData.worldTangent2ndSpecular;\n  surfaceData2ndSpecular.worldBinormal = surfaceData.worldBinormal2ndSpecular;\n}\n#endif\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData)\n{\n  lightingResult.ao = surfaceData.ao;\n  lightingResult.emissive = surfaceData.emissive;\n}\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult)\n{\n  lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  lightingResult.directTransmitSpecular = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingResult.directTransmitDiffuse = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  lightingResult.direct2ndSpecular = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  lightingResult.directTT = vec3(0.0);\n#endif\n}\nvoid CCSurfacesAccumulateLightingResult(inout LightingResult lightingResultAccumulated, in LightingResult lightingResult)\n{\n  lightingResultAccumulated.directDiffuse += lightingResult.directDiffuse * lightingResult.shadow;\n  lightingResultAccumulated.directSpecular += lightingResult.directSpecular * lightingResult.shadow;\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    lightingResultAccumulated.directTransmitSpecular += lightingResult.directTransmitSpecular;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    lightingResultAccumulated.directTransmitDiffuse += lightingResult.directTransmitDiffuse;\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    lightingResultAccumulated.direct2ndSpecular += lightingResult.direct2ndSpecular * lightingResult.shadow;\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    lightingResultAccumulated.directTT += lightingResult.directTT * lightingResult.shadow;\n    lightingResultAccumulated.diffuseColorWithLightingTT = lightingResult.diffuseColorWithLightingTT;\n  #endif\n}\n#if CC_PIPELINE_TYPE == 1\n  vec4 CCSurfacesDeferredOutput0(in SurfacesMaterialData surfaceData)\n  {\n    return surfaceData.baseColor;\n  }\n  vec4 CCSurfacesDeferredOutput1(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(float32x3_to_oct(surfaceData.worldNormal), surfaceData.roughness, surfaceData.metallic);\n  }\n  vec4 CCSurfacesDeferredOutput2(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(surfaceData.emissive, surfaceData.ao);\n  }\n#endif\nvec4 CCSurfacesShading(in SurfacesMaterialData surfaceData, in LightingResult lightingResult)\n{\n  vec4 color = vec4(0.0, 0.0, 0.0, surfaceData.baseColor.a);\n#if CC_FORWARD_ADD\n  color.xyz += lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithEnvLighting\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.direct2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    + lightingResult.directTT * lightingResult.diffuseColorWithLightingTT\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.directTransmitDiffuse\n  #endif\n  ;\n#else\n  float fresnel = 1.0;\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    fresnel = lightingResult.fresnel;\n  #endif\n  float invFresnel = 1.0 - fresnel;\n  color.xyz +=\n    ( lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithEnvLighting * invFresnel\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.direct2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    + lightingResult.directTT * lightingResult.diffuseColorWithLightingTT\n  #endif\n    )\n    * lightingResult.shadow\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.directTransmitDiffuse\n  #endif\n  ;\n  #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_ALL_IN_ONE\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting * lightingResult.shadow;\n  #elif CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting;\n  #endif\n  color.xyz +=\n    ( lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.environmentSpecular * lightingResult.specularColorWithEnvLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.environmentTransmitSpecular * lightingResult.specularColorWithEnvLighting * invFresnel\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.environment2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n    )\n    * lightingResult.ao\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.environmentTransmitDiffuse\n  #endif\n  ;\n  color.xyz += lightingResult.emissive;\n#endif\n  return color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\nbool CCSurfacesDebugViewSurfaceData(inout vec4 color, in SurfacesMaterialData surfaceData)\n{\n    bool enableMaterialAlpha = true;\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    float scalar;\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(surfaceData.worldNormal * 0.5 + vec3(0.5), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldBinormal * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSPARENCY)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.baseColor.a;\n        color = vec4(scalar, scalar, scalar, 1.0);\n        enableMaterialAlpha = false;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_BASE_COLOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(surfaceData.baseColor.rgb), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(CCSurfacesGetDiffuseColor(surfaceData)), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(CCSurfacesGetSpecularColor(surfaceData)), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ROUGHNESS)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.roughness;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_METALLIC)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.metallic;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.specularIntensity;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_IOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.ior - 1.0;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    return enableMaterialAlpha;\n}\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD && !CC_ENABLE_CLUSTERED_LIGHT_CULLING\n    void CCSurfacesLighting(inout LightingResult lightingResultAccumulated, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      CCSurfacesInitializeLightingResult(lightingResultAccumulated);\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      LightingResult lightingResult;\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n      lightingResultAccumulated.diffuseColorWithLighting = lightingResult.diffuseColorWithLighting;\n      lightingResultAccumulated.specularColorWithLighting = lightingResult.specularColorWithLighting;\n      lightingResultAccumulated.specularColorWithEnvLighting = lightingResult.specularColorWithEnvLighting;\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        vec3 diff;\n        SurfacesMaterialData surfaceData2ndSpecular;\n        CCSurfacesGetSurfacesMaterialData2ndSpecular(surfaceData2ndSpecular, surfaceData);\n        CCSurfacesLightingInitializeColorWithLighting(diff, lightingResultAccumulated.specularColorWithLighting2ndSpecular, lightingResultAccumulated.specularColorWithEnvLighting2ndSpecular, surfaceData2ndSpecular, lightingData);\n      #endif\n      int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n      for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n        if (i >= numLights) break;\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, cc_lightPos[i].xyz - worldPos);\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n        vec3 diffuseLighting, specularLighting;\n        CCSurfacesLightingCalculateDirect(diffuseLighting, specularLighting, lightingData, cc_lightColor[i]);\n        float fresnel = 1.0;\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        fresnel = lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n        float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowPosWithDepthBias = vec4(0.0);\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n            shadow = CCSpotShadowFactorBase(shadowPosWithDepthBias, shadowPos, worldPos, shadowBias);\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n            vec3 shadowNDCPos;\n            bool isExceedShadowMap = !GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n            lightingData.shadowPosAndDepth.xy = shadowNDCPos.xy;\n            lightingData.shadowPosAndDepth.z = isExceedShadowMap ? 0.0 : GetViewSpaceDepthFromNDCDepth_Perspective(shadowNDCPos.z, shadowPosWithDepthBias.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n            lightingData.shadowPosAndDepth.w = isExceedShadowMap ? lightingData.shadowPosAndDepth.w : GetViewSpaceDepthFromNDCDepth_Perspective(SampleShadowMapSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy), shadowPosWithDepthBias.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n          #endif\n        }\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW) {\n          shadow = 1.0;\n        }\n      #endif\n        lightingResult.shadow = shadow;\n        float distAtt = CCSurfacesLightingCalculateDistanceAttenuation(lightingData, cc_lightSizeRangeAngle[i]);\n        float angleAtt = 1.0;\n        if (cc_lightPos[i].w > 0.0) {\n          angleAtt = CCSurfacesLightingCalculateAngleAttenuation(lightingData, cc_lightSizeRangeAngle[i], -cc_lightDir[i].xyz);\n        }\n        float multiplier = distAtt * angleAtt;\n        lightingData.angleAttenuation = angleAtt;\n        lightingData.distAttenuation = distAtt;\n        lightingResult.directDiffuse = diffuseLighting * multiplier;\n        lightingResult.directSpecular = specularLighting * multiplier * fresnel;\n        vec4 attenuatedLightColorAndIntensity = vec4(cc_lightColor[i].xyz, cc_lightColor[i].w * multiplier);\n        #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n          vec3 transmitSpecularLighting;\n          CCSurfacesLightingCalculateDirectTransmitSpecular(transmitSpecularLighting, lightingData, attenuatedLightColorAndIntensity);\n          lightingResult.directTransmitSpecular = transmitSpecularLighting * multiplier * (1.0 - fresnel);\n        #endif\n        #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n          LightingIntermediateData lightingDataTD;\n          CCSurfacesGetLightingIntermediateDataTransmitDiffuse(lightingDataTD, lightingData, surfaceData);\n          CCSurfacesLightingCalculateIntermediateData_PerLight(lightingDataTD, surfaceData, cc_lightPos[i].xyz - worldPos);\n          CCSurfacesLightingCalculateDirectTransmitDiffuse(lightingResult.directTransmitDiffuse, lightingDataTD, attenuatedLightColorAndIntensity, lightingResult.shadow);\n        #endif\n        #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n          LightingIntermediateData lightingData2ndSpecular;\n          CCSurfacesInitializeLightingIntermediateData(lightingData2ndSpecular, surfaceData2ndSpecular);\n          CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData2ndSpecular, surfaceData, cc_lightPos[i].xyz - worldPos);\n          CCSurfacesLightingCalculateDirect2ndSpecular(lightingResult.direct2ndSpecular, lightingData2ndSpecular, attenuatedLightColorAndIntensity, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.directSpecular);\n          lightingResult.direct2ndSpecular *= multiplier * fresnel;\n        #endif\n        #if CC_SURFACES_LIGHTING_TT\n          CCSurfacesLightingCalculateDirectTT(lightingResult, lightingData, attenuatedLightColorAndIntensity);\n        #endif\n        #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n          LightingMiscData miscData;\n          miscData.lightType = cc_lightPos[i].w;\n          miscData.lightPos = cc_lightPos[i].xyz;\n          miscData.lightDir = cc_lightDir[i].xyz;\n          miscData.lightColorAndIntensity = cc_lightColor[i];\n          miscData.lightSizeRangeAngle = cc_lightSizeRangeAngle[i];\n          SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData, miscData);\n        #endif\n        CCSurfacesAccumulateLightingResult(lightingResultAccumulated, lightingResult);\n      }\n    }\n  #else\n    void CCSurfacesLighting(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      CCSurfacesInitializeLightingResult(lightingResult, surfaceData);\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n      CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, -cc_mainLitDir.xyz);\n      lightingResult.shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_mainLitDir.w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowPosWithDepthBias = vec4(0.0);\n          vec4 shadowProjDepthInfo = vec4(0.0);\n          vec3 shadowNDCPos;\n          bool isExceedShadowMap = true;\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            #if CC_DIR_LIGHT_SHADOW_TYPE == 2\n              lightingResult.shadow = CCCSMFactorBase(worldPos, lightingData.N, shadowBias);\n              #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n                vec4 shadowProjInfo;\n                vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n                isExceedShadowMap = 0 > CCGetCSMLevel(shadowPosWithDepthBias, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n                GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n              #endif\n            #endif\n            #if CC_DIR_LIGHT_SHADOW_TYPE == 1\n              shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n              lightingResult.shadow = CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, lightingData.N, shadowBias);\n              shadowProjDepthInfo = cc_shadowProjDepthInfo;\n              isExceedShadowMap = !GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n            #endif\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n            lightingData.shadowPosAndDepth.xy = shadowNDCPos.xy;\n            lightingData.shadowPosAndDepth.z = isExceedShadowMap ? 0.0 : GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowNDCPos.z, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n            lightingData.shadowPosAndDepth.w = isExceedShadowMap ? lightingData.shadowPosAndDepth.w : GetViewSpaceDepthFromNDCDepth_Orthgraphic(SampleShadowMapSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy), shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n          #endif\n        }\n      #endif\n      lightingResult.lightmapColor = vec3(0.0);\n      #if CC_SURFACES_USE_LIGHT_MAP && !CC_FORWARD_ADD\n\t\t    float lightmapShadow, lightmapAO;\n        GetLightMapColor(lightingResult.lightmapColor, lightmapShadow, lightmapAO, cc_lightingMap, FSInput_lightMapUV.xy, FSInput_lightMapUV.z, surfaceData.worldNormal);\n        #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n          lightingResult.shadow *= lightmapShadow;\n        #endif\n        lightingResult.ao *= lightmapAO;\n      #endif\n      lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n      #if !CC_DISABLE_DIRECTIONAL_LIGHT && !CC_FORWARD_ADD\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n        CCSurfacesLightingCalculateDirect(lightingResult.directDiffuse, lightingResult.directSpecular, lightingData, cc_mainLitColor);\n      #endif\n      CCSurfacesLightingCalculateEnvironment(lightingResult.environmentDiffuse, lightingResult.environmentSpecular, lightingData, cc_ambientSky.w);\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n        CCSurfacesLightingCalculateDirectTransmitSpecular(lightingResult.directTransmitSpecular, lightingData, cc_mainLitColor);\n        CCSurfacesLightingCalculateEnvironmentTransmitSpecular(lightingResult.environmentTransmitSpecular, lightingData, cc_ambientSky.w);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n        LightingIntermediateData lightingDataTD;\n        CCSurfacesGetLightingIntermediateDataTransmitDiffuse(lightingDataTD, lightingData, surfaceData);\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingDataTD, surfaceData, -cc_mainLitDir.xyz);\n        CCSurfacesLightingCalculateDirectTransmitDiffuse(lightingResult.directTransmitDiffuse, lightingDataTD, cc_mainLitColor, lightingResult.shadow);\n        CCSurfacesLightingCalculateEnvironmentTransmitDiffuse(lightingResult.environmentTransmitDiffuse, lightingDataTD, cc_ambientSky.w, lightingResult.ao, -cc_mainLitDir.xyz);\n      #endif\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        SurfacesMaterialData surfaceData2ndSpecular;\n        CCSurfacesGetSurfacesMaterialData2ndSpecular(surfaceData2ndSpecular, surfaceData);\n        LightingIntermediateData lightingData2ndSpecular;\n        CCSurfacesInitializeLightingIntermediateData(lightingData2ndSpecular, surfaceData2ndSpecular);\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData2ndSpecular, surfaceData2ndSpecular, -cc_mainLitDir.xyz);\n        CCSurfacesLightingCalculateDirect2ndSpecular(lightingResult.direct2ndSpecular, lightingData2ndSpecular, cc_mainLitColor, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.directSpecular);\n        CCSurfacesLightingCalculateEnvironment2ndSpecular(lightingResult.environment2ndSpecular, lightingData2ndSpecular, cc_ambientSky.w, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.environmentSpecular);\n        vec3 diff;\n        CCSurfacesLightingInitializeColorWithLighting(diff, lightingResult.specularColorWithLighting2ndSpecular, lightingResult.specularColorWithEnvLighting2ndSpecular, surfaceData2ndSpecular, lightingData2ndSpecular);\n      #endif\n      #if CC_SURFACES_LIGHTING_TT\n        CCSurfacesLightingCalculateDirectTT(lightingResult, lightingData, cc_mainLitColor);\n      #endif\n      #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n        LightingMiscData miscData;\n        miscData.lightType = LIGHT_TYPE_DIRECTIONAL;\n        miscData.lightPos = vec3(0.0);\n        miscData.lightDir = cc_mainLitDir.xyz;\n        miscData.lightColorAndIntensity = cc_mainLitColor;\n        miscData.lightSizeRangeAngle = vec4(0.0, 0.0, 0.0, 0.0);\n        SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData, miscData);\n      #endif\n    }\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING\n    #endif\n  #endif\n#endif\nvec4 CCSurfacesDebugDisplayInvalidNumber(vec4 color)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(color.rgb) || isinfs(color.rgb)) ? error : color;\n}\nvec4 CCSurfacesDebugDisplayInvalidInputData(vec4 color, vec3 data)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(data) || isinfs(data)) ? error : color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && !CC_FORWARD_ADD\n  void CCSurfacesDebugViewMeshData(inout vec4 color)\n  {\n    vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_VERTEX_COLOR\n        color = FSInput_vertexColor;\n      #else\n        color = white;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(FSInput_worldNormal * 0.5 + vec3(0.5), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(FSInput_worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        float sign = FSInput_mirrorNormal * 0.5 + 0.5;\n        color = vec4(sign, sign, sign, 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FACE_SIDE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        float scalar = clamp(FSInput_faceSideSign, 0.0, 1.0);\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UV0)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(FSInput_texcoord.xy, 0.0, 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UV1)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n      color = vec4(FSInput_texcoord1.xy, 0.0, 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n        color = vec4(FSInput_lightMapUV.xy, 0.0, 1.0);\n      #else\n        color = vec4(0.0, 0.0, 0.0, 1.0);\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      vec4 clipPos = cc_matProj * cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = clipPos.z / clipPos.w;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      vec4 viewPos = cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = (-viewPos.z - cc_nearFar.x) / cc_nearFar.y;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_WORLD_POS)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n      color = vec4(FSInput_worldPos.xyz, 1.0);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\n  bool CCSurfacesDebugViewLightingResult(inout vec4 color, in LightingResult lightingResult)\n  {\n    bool isSRGBColor = false;\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentSpecular * lightingResult.specularColorWithEnvLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.environmentSpecular * lightingResult.specularColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_LIGHT_MAP)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.lightmapColor;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_EMISSIVE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.emissive;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_AO)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(lightingResult.ao);\n        isSRGBColor = false;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SHADOW)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(lightingResult.shadow);\n        isSRGBColor = false;\n    }\n    float fresnel = 0.0;\n    vec3 directTransmitSpecular = vec3(0.0), environmentTransmitSpecular = vec3(0.0);\n    vec3 directTransmitDiffuse = vec3(0.0), environmentTransmitDiffuse = vec3(0.0);\n    vec3 diffuseColorWithLightingTT = vec3(0.0), specularColorWithLighting2ndSpecular = vec3(0.0);\n    vec3 direct2ndSpecular = vec3(0.0), environment2ndSpecular = vec3(0.0);\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    fresnel = lightingResult.fresnel;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    directTransmitSpecular = lightingResult.directTransmitSpecular;\n    environmentTransmitSpecular = lightingResult.environmentTransmitSpecular;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    directTransmitDiffuse = lightingResult.directTransmitDiffuse;\n    environmentTransmitDiffuse = lightingResult.environmentTransmitDiffuse;\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    direct2ndSpecular = lightingResult.direct2ndSpecular;\n    environment2ndSpecular = lightingResult.environment2ndSpecular;\n    specularColorWithLighting2ndSpecular = lightingResult.specularColorWithEnvLighting2ndSpecular;\n  #endif\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRESNEL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(fresnel);\n        isSRGBColor = false;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitSpecular;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environmentTransmitSpecular;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environmentTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitSpecular + environmentTransmitSpecular + directTransmitDiffuse + environmentTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = direct2ndSpecular * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environment2ndSpecular * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = (direct2ndSpecular + environment2ndSpecular) * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    return isSRGBColor;\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  void CCSurfacesDebugViewCompositeLightingResult(inout LightingResult lightingResult)\n  {\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE)\n      lightingResult.directDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR)\n      lightingResult.directSpecular = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE)\n      lightingResult.environmentDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR)\n      lightingResult.environmentSpecular = vec3(0.0);\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE)\n      lightingResult.directTransmitDiffuse = lightingResult.environmentTransmitDiffuse = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR)\n      lightingResult.directTransmitSpecular = lightingResult.environmentTransmitSpecular = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR)\n        lightingResult.direct2ndSpecular = lightingResult.environment2ndSpecular = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT)\n        lightingResult.directTT = vec3(0.0);\n  #endif\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE)\n      lightingResult.emissive = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP)\n      lightingResult.lightmapColor = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n      lightingResult.shadow = 1.0;\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO)\n      lightingResult.ao = 1.0;\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL)\n      lightingResult.fresnel = 1.0;\n  #endif\n  }\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main()  {\n  #if CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER\n    float NoL = dot(-cc_mainLitDir.xyz, FSInput_worldNormal.xyz);\n    vec4 color = SurfacesFragmentModifyBaseColorAndTransparency();\n  #else\n    SurfacesMaterialData surfaceData;\n    CCSurfacesFragmentGetMaterialData(surfaceData);\n    vec2 shadowBias = vec2(0.0);\n    vec3 colDebugCSMLayer = vec3(1.0);\n    #if CC_RECEIVE_SHADOW\n      shadowBias = FSInput_shadowBias;\n      #if !CC_FORWARD_ADD\n        #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n          if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION)\n          {\n              vec4 csmPos;\n              vec4 shadowProjDepthInfo, shadowProjInfo;\n              vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n              int csmLayer = -1;\n              csmLayer = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, surfaceData.worldPos);\n              bool OutOfRange = csmLayer < 0;\n              if (OutOfRange)\n                  colDebugCSMLayer = vec3(1.0);\n              else if (csmLayer == 0)\n                  colDebugCSMLayer = vec3(1.0, 0.0, 0.0);\n              else if (csmLayer == 1)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 0.0);\n              else if (csmLayer == 2)\n                  colDebugCSMLayer = vec3(0.0, 0.0, 1.0);\n              else if (csmLayer == 3)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 1.0);\n          }\n        #endif\n      #endif\n    #endif\n    float fogFactor = 1.0;\n    #if !CC_FORWARD_ADD\n      #if CC_USE_FOG != 4\n        #if !CC_USE_ACCURATE_FOG\n          fogFactor = FSInput_fogFactor;\n        #else\n          CC_TRANSFER_FOG_BASE(vec4(FSInput_worldPos, 1.0), fogFactor);\n        #endif\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG) {\n            fogFactor = 1.0;\n        }\n      #endif\n    #endif\n    LightingResult lightingResult;\n    CCSurfacesLighting(lightingResult, surfaceData, shadowBias);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      float materialTransparency = CCSurfacesShading(surfaceData, lightingResult).a;\n      #if !CC_FORWARD_ADD\n        CCSurfacesDebugViewMeshData(debugColor);\n        if (CCSurfacesDebugViewSurfaceData(debugColor, surfaceData))\n        {\n          debugColor.a = materialTransparency;\n        }\n        if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FOG)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        {\n          debugColor.rgb = vec3(1.0 - fogFactor);\n        }\n      #endif\n      #if CC_FORWARD_ADD\n        if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) || ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) || ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) ||\n            ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) || ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) || ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n      #endif\n        {\n            if (CCSurfacesDebugViewLightingResult(debugColor, lightingResult))\n            {\n              debugColor.a = materialTransparency;\n              #if !CC_USE_FLOAT_OUTPUT\n                debugColor.rgb = HDRToLDR(debugColor.rgb);\n                debugColor.rgb = LinearToSRGB(debugColor.rgb);\n              #endif\n            }\n        }\n      if (IS_DEBUG_VIEW_ENABLE_WITH_CAMERA) {\n        fragColorX = debugColor;\n        return;\n      }\n    #elif CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n      CCSurfacesDebugViewCompositeLightingResult(lightingResult);\n    #endif\n    vec4 color = CCSurfacesShading(surfaceData, lightingResult);\n    #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n      if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION) {\n          color.rgb *= colDebugCSMLayer.rgb;\n      }\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = CCSurfacesDebugDisplayInvalidInputData(color, FSInput_worldTangent);\n      #endif\n    #endif\n  #endif\n    #if CC_USE_FOG != 4\n      #if CC_USE_RGBE_OUTPUT || CC_USE_FLOAT_OUTPUT\n        CC_APPLY_FOG_BASE(color, fogFactor);\n      #endif\n    #endif\n    #if CC_USE_RGBE_OUTPUT\n      color = packRGBE(color.rgb);\n    #else\n      color = CCSurfacesDebugDisplayInvalidNumber(color);\n      #if !CC_USE_FLOAT_OUTPUT\n        color.rgb = HDRToLDR(color.rgb);\n        color.rgb = LinearToSRGB(color.rgb);\n      #endif\n    #endif\n    #if !CC_USE_RGBE_OUTPUT && !CC_USE_FLOAT_OUTPUT && !CC_FORWARD_ADD\n      #if CC_USE_FOG != 4\n        CC_APPLY_FOG_BASE(color, fogFactor);\n      #endif\n    #endif\n    fragColorX = color;\n  }\n#elif CC_PIPELINE_TYPE == 1\n    layout(location = 0) out vec4 fragColor0;\n    layout(location = 1) out vec4 fragColor1;\n    layout(location = 2) out vec4 fragColor2;\n    void main () {\n      SurfacesMaterialData surfaceData;\n      CCSurfacesFragmentGetMaterialData(surfaceData);\n      fragColor0 = CCSurfacesDeferredOutput0(surfaceData);\n      fragColor1 = CCSurfacesDeferredOutput1(surfaceData);\n      fragColor2 = CCSurfacesDeferredOutput2(surfaceData);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      CCSurfacesDebugViewMeshData(debugColor);\n      CCSurfacesDebugViewSurfaceData(debugColor, surfaceData);\n      if (IS_DEBUG_VIEW_ENABLE_WITH_CAMERA) {\n        fragColor0 = debugColor;\n      }\n    #endif\n    }\n#endif"},"glsl1":{"vert":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE USE_REFLECTION_DENOISE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING USE_COMPATIBLE_LIGHTING\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  attribute vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  attribute vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    attribute vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n#endif\nvarying highp vec3 v_worldPos;\nvarying mediump vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\nuniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n  uniform highp vec4 cc_localShadowBias;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n    float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n        vec4 wPos = pos;\n        float cam_dis = distance(cameraPos, wPos.xyz);\n        return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n    }\n    float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * fogDensity);\n        return f;\n    }\n    float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n        return f;\n    }\n    float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n        vec4 wPos = pos;\n        vec3 camWorldProj = cameraPos.xyz;\n        camWorldProj.y = 0.;\n        vec3 worldPosProj = wPos.xyz;\n        worldPosProj.y = 0.;\n        float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n        float fDeltaY, fDensityIntegral;\n        if (cameraPos.y > fogTop) {\n            if (wPos.y < fogTop) {\n                fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n                fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n            }\n            else {\n                fDeltaY = 0.;\n                fDensityIntegral = 0.;\n            }\n        }\n        else {\n            if (wPos.y < fogTop) {\n                float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n                float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n                fDeltaY = abs(fDeltaA - fDeltaB);\n                fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n            }\n            else {\n                fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n                fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n            }\n        }\n        float fDensity;\n        if (fDeltaY != 0.) {\n            fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n        }\n        else {\n            fDensity = 0.;\n        }\n        float f = exp(-fDensity);\n        return f;\n    }\n  #endif\n  void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n  {\n  #if CC_USE_FOG == 0\n  \tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n  #elif CC_USE_FOG == 1\n  \tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 2\n  \tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 3\n  \tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n  #else\n  \tfactor = 1.0;\n  #endif\n  }\n#endif\n    uniform vec4 tilingOffset;\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.position.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\nvec3 SurfacesVertexModifyLocalNormal(in SurfacesStandardVertexIntermediate In)\n{\n  return In.normal.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 SurfacesVertexModifyLocalTangent(in SurfacesStandardVertexIntermediate In)\n    {\n      return In.tangent;\n    }\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\nvec3 SurfacesVertexModifyWorldNormal(in SurfacesStandardVertexIntermediate In)\n{\n    vec3 worldNormal = In.worldNormal.xyz;\n  #if CC_SURFACES_USE_TWO_SIDED\n      worldNormal.xyz *= In.worldNormal.w;\n  #endif\n  return worldNormal;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\nvec2 SurfacesVertexModifyShadowBias(in SurfacesStandardVertexIntermediate In, vec2 originShadowBias)\n{\n  return originShadowBias;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferFog(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(vec4(In.worldPos, 1.0), In.fogFactor);\n#endif\n}\nvoid CCSurfacesVertexTransferShadow(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    In.shadowBiasAndProbeId = vec4(0.0);\n  #endif\n  #if CC_RECEIVE_SHADOW\n    In.shadowBiasAndProbeId.xy = vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.xy += a_localShadowBiasAndProbeId.xy;\n    #else\n      In.shadowBiasAndProbeId.xy += cc_localShadowBias.xy;\n    #endif\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.zw = a_localShadowBiasAndProbeId.zw;\n    #else\n      In.shadowBiasAndProbeId.zw = cc_localShadowBias.zw;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferLightMapUV(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #if USE_INSTANCING\n    In.lightmapUV.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    In.lightmapUV.z = a_lightingMapUVParam.w;\n  #else\n    In.lightmapUV.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    In.lightmapUV.z = cc_lightingMapUVParam.w;\n  #endif\n#endif\n}\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  In.normal.xyz = SurfacesVertexModifyLocalNormal(In);\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    In.tangent = SurfacesVertexModifyLocalTangent(In);\n  #endif\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matProj * cc_matView * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  vec3 viewDirect = normalize(cc_cameraPos.xyz - In.worldPos);\n  In.worldNormal.w = dot(In.worldNormal.xyz, viewDirect) < 0.0 ? -1.0 : 1.0;\n  In.worldNormal.xyz = SurfacesVertexModifyWorldNormal(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexTransferFog(In);\n  CCSurfacesVertexTransferLightMapUV(In);\n  CCSurfacesVertexTransferShadow(In);\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    In.shadowBiasAndProbeId.xy = SurfacesVertexModifyShadowBias(In, In.shadowBiasAndProbeId.xy);\n  #endif\n  CCSurfacesVertexOutput(In);\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE USE_REFLECTION_DENOISE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING USE_COMPATIBLE_LIGHTING\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nvarying highp vec3 v_worldPos;\nvarying mediump vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nuniform highp vec4 cc_time;\n  uniform mediump vec4 cc_probeInfo;\n  uniform mediump vec4 cc_debug_view_mode;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_surfaceTransform;\n  uniform mediump vec4 cc_exposure;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n  uniform mediump vec4 cc_nearFar;\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    uniform vec4 cc_sh_linear_const_r;\n  uniform vec4 cc_sh_linear_const_g;\n  uniform vec4 cc_sh_linear_const_b;\n  uniform vec4 cc_sh_quadratic_r;\n  uniform vec4 cc_sh_quadratic_g;\n  uniform vec4 cc_sh_quadratic_b;\n  uniform vec4 cc_sh_quadratic_a;\n  #endif\n#endif\nuniform highp mat4 cc_matLightView;\n  uniform highp mat4 cc_matLightViewProj;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  uniform highp vec4 cc_csmViewDir0[4];\n  uniform highp vec4 cc_csmViewDir1[4];\n  uniform highp vec4 cc_csmViewDir2[4];\n  uniform highp vec4 cc_csmAtlas[4];\n  uniform highp mat4 cc_matCSMViewProj[4];\n  uniform highp vec4 cc_csmProjDepthInfo[4];\n  uniform highp vec4 cc_csmProjInfo[4];\n  uniform highp vec4 cc_csmSplitsInfo;\n#endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return texture2DLodEXT(tex, coord, lod);\n    #else\n      return texture2D(tex, coord, lod);\n    #endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return textureCubeLodEXT(tex, coord, lod);\n    #else\n      return textureCube(tex, coord, lod);\n    #endif\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nvec4 packRGBE (vec3 rgb) {\n  highp float maxComp = max(max(rgb.r, rgb.g), rgb.b);\n  highp float e = 128.0;\n  if (maxComp > 0.0001) {\n    e = log(maxComp) / log(1.1);\n    e = ceil(e);\n    e = clamp(e + 128.0, 0.0, 255.0);\n  }\n  highp float sc = 1.0 / pow(1.1, e - 128.0);\n  vec3 encode = clamp(rgb * sc, vec3(0.0), vec3(1.0)) * 255.0;\n  vec3 encode_rounded = floor(encode) + step(encode - floor(encode), vec3(0.5));\n  return vec4(encode_rounded, e) / 255.0;\n}\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 HDRToLDR(vec3 color)\n{\n  #if CC_USE_HDR\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n      if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING)\n    #endif\n    #if CC_TONE_MAPPING_TYPE == HDR_TONE_MAPPING_ACES\n      color.rgb = ACESToneMap(color.rgb);\n    #endif\n  #endif\n  return color;\n}\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\nbool isnan(float val) {\n  return (val < 0.0 || 0.0 < val || val == 0.0) ? false : true;\n}\nbool isinf(float x) {\n  return x == x * 2.0 && x != 0.0;\n}\nbool isnans(vec2 val) {\n    return isnan(val.x) || isnan(val.y);\n}\nbool isnans(vec3 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z);\n}\nbool isnans(vec4 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z) || isnan(val.w);\n}\nbool isinfs(vec2 val) {\n    return isinf(val.x) || isinf(val.y);\n}\nbool isinfs(vec3 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z);\n}\nbool isinfs(vec4 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z) || isinf(val.w);\n}\nfloat saturate(float value) {\n    return min(max(value, 0.0), 1.0);\n}\nvec2 saturate(vec2 value) { return vec2(saturate(value.x), saturate(value.y)); }\nvec3 saturate(vec3 value) { return vec3(saturate(value.x), saturate(value.y), saturate(value.z)); }\nvec4 saturate(vec4 value) { return vec4(saturate(value.x), saturate(value.y), saturate(value.z), saturate(value.w)); }\nvec2 GetPlanarReflectScreenUV(vec3 worldPos, mat4 matVirtualCameraViewProj, float flipNDCSign, vec3 viewDir, vec3 reflectDir)\n{\n  vec4 clipPos = matVirtualCameraViewProj * vec4(worldPos, 1.0);\n  vec2 screenUV = clipPos.xy / clipPos.w * 0.5 + 0.5;\n  screenUV = vec2(1.0 - screenUV.x, screenUV.y);\n  screenUV = flipNDCSign == 1.0 ? vec2(screenUV.x, 1.0 - screenUV.y) : screenUV;\n  return screenUV;\n}\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nvec3 CalculateBinormal(vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    return cross(normal, tangent) * mirrorNormal;\n}\nvec3 CalculateNormal(vec3 tangent, vec3 binormal)\n{\n    return cross(tangent, binormal);\n}\nvec3 CalculateNormalFromTangentSpace(vec3 normalFromTangentSpace, float normalStrength, vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    vec3 binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n    return (normalFromTangentSpace.x * normalStrength) * normalize(tangent) +\n           (normalFromTangentSpace.y * normalStrength) * normalize(binormal) +\n            normalFromTangentSpace.z * normalize(normal);\n}\nvec3 RotationVecFromAxisY(vec3 v, float cosTheta, float sinTheta)\n{\n    vec3 result;\n    result.x = dot(v, vec3(cosTheta, 0.0, -sinTheta));\n    result.y = v.y;\n    result.z = dot(v, vec3(sinTheta, 0.0,  cosTheta));\n    return result;\n}\nvec3 RotationVecFromAxisY(vec3 v, float rotateAngleArc)\n{\n  return RotationVecFromAxisY(v, cos(rotateAngleArc), sin(rotateAngleArc));\n}\nvoid RotateTangentAndBinormal(inout vec3 tangent, inout vec3 binormal, vec3 normal, float rotationAngle)\n{\n    float cosTheta = cos(rotationAngle), sinTheta = sin(rotationAngle);\n    vec3 B = RotationVecFromAxisY(vec3(1.0, 0.0, 0.0), cosTheta, sinTheta);\n    vec3 T = RotationVecFromAxisY(vec3(0.0, 0.0, 1.0), cosTheta, sinTheta);\n    vec3 tangentNew, binormalNew;\n    binormalNew = B.x * binormal + B.y * normal + B.z * tangent;\n    binormal = normalize(binormalNew);\n    tangentNew = T.x * binormal + T.y * normal + T.z * tangent;\n    tangent = normalize(tangentNew);\n}\nvoid RotateNormalAndBinormal(inout vec3 binormal, inout vec3 normal, in vec3 tangent, float rotationAngle, float mirrorNormal)\n{\n  if(rotationAngle > 0.0)\n  {\n    normal += (binormal - normal) * rotationAngle;\n    normal = normalize(normal);\n    binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n  }\n  else if(rotationAngle < 0.0)\n  {\n    binormal += (binormal - normal) * rotationAngle;\n    binormal = normalize(binormal);\n    normal = CalculateNormal(tangent, binormal);\n  }\n}\nvec2 signNotZero(vec2 v) {\n  return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\nvec2 float32x3_to_oct(in vec3 v) {\n  vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n  return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n}\nbool GetMetallicAlbedoFromDiffuseSpecularWithoutColor(out float metallic, out vec3 albedo, vec3 diffuse, vec3 specular, float f0 )\n{\n\tfloat d = max(max(diffuse.x, diffuse.y), diffuse.z);\n\tvec3 normalizedColor = diffuse / (d + (d < EPSILON_LOWP ? EPSILON_LOWP : 0.0));\n\tnormalizedColor = d < EPSILON_LOWP ? specular : normalizedColor;\n\tfloat s = max(max(specular.x, specular.y), specular.z);\n\tfloat delta = (d + s) * (d + s)  - 4.0 * f0 * d;\n\tfloat deltaSqrt = sqrt(max(0.0, delta));\n\tfloat solverMetallic = (-d - s + 2.0 * f0 + deltaSqrt) / (2.0 * f0);\n\tvec3 solverAlbedo = (d + s) * normalizedColor - vec3(f0 * (1.0 - solverMetallic));\n\tbool isValidSolver = delta >= 0.0;\n\tmetallic = isValidSolver ? clamp(solverMetallic, 0.0, 1.0) : 0.0;\n\talbedo = isValidSolver ? vec3(max(0.0, solverAlbedo.x), max(0.0, solverAlbedo.y), max(0.0, solverAlbedo.z)) : diffuse;\n\treturn isValidSolver;\n}\n  vec3 EnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n      #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n        roughness = pow(roughness, 0.5);\n      #endif\n    \tfloat mip = roughness * (mipCount - 1.0);\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n      vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    \tvec4 biased = fragTextureLod(cc_environment, rotationDir, mip + mipBias);\n     \tvec4 filtered = textureCube(cc_environment, rotationDir);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n  vec3 EnvReflection(samplerCube tex, vec3 R, float roughness, float mipCount) {\n    #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n      roughness = pow(roughness, 0.5);\n    #endif\n    vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    vec4 envmap = fragTextureLod(tex, rotationDir, roughness * (mipCount - 1.0));\n    #if CC_USE_IBL == 2 || CC_USE_REFLECTION_PROBE != REFLECTION_PROBE_TYPE_NONE\n      return unpackRGBE(envmap);\n    #else\n      return SRGBToLinear(envmap.rgb);\n    #endif\n  }\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  float SampleShadowMap (vec3 shadowNDCPos, highp sampler2D shadowMap)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return dot(texture2D(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    #else\n      return texture2D(shadowMap, shadowNDCPos.xy).x;\n    #endif\n  }\n  float SampleShadowMapSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0 = SampleShadowMap(vec3(shadowNDCPos.x, shadowNDCPos.y, shadowNDCPos.z), shadowMap);\n    float block1 = SampleShadowMap(vec3(shadowNDCPos_offset.x, shadowNDCPos.y, shadowNDCPos.z), shadowMap);\n    float block2 = SampleShadowMap(vec3(shadowNDCPos.x, shadowNDCPos_offset.y, shadowNDCPos.z), shadowMap);\n    float block3 = SampleShadowMap(vec3(shadowNDCPos_offset.x, shadowNDCPos_offset.y, shadowNDCPos.z), shadowMap);\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorHard (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return step(shadowNDCPos.z, dot(texture2D(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      return step(shadowNDCPos.z, texture2D(shadowMap, shadowNDCPos.xy).x);\n    #endif\n  }\n  float NativePCFShadowFactorSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n    #endif\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n    float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n    float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n    float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n      block4 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block5 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n      block6 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n      block7 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n      block8 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n    #endif\n    float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float NativePCFShadowFactorSoft5X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 twoTap = oneTap * 2.0;\n    vec2 offset1 = shadowNDCPos.xy + vec2(-twoTap.x, -twoTap.y);\n    vec2 offset2 = shadowNDCPos.xy + vec2(-oneTap.x, -twoTap.y);\n    vec2 offset3 = shadowNDCPos.xy + vec2(0.0, -twoTap.y);\n    vec2 offset4 = shadowNDCPos.xy + vec2(oneTap.x, -twoTap.y);\n    vec2 offset5 = shadowNDCPos.xy + vec2(twoTap.x, -twoTap.y);\n    vec2 offset6 = shadowNDCPos.xy + vec2(-twoTap.x, -oneTap.y);\n    vec2 offset7 = shadowNDCPos.xy + vec2(-oneTap.x, -oneTap.y);\n    vec2 offset8 = shadowNDCPos.xy + vec2(0.0, -oneTap.y);\n    vec2 offset9 = shadowNDCPos.xy + vec2(oneTap.x, -oneTap.y);\n    vec2 offset10 = shadowNDCPos.xy + vec2(twoTap.x, -oneTap.y);\n    vec2 offset11 = shadowNDCPos.xy + vec2(-twoTap.x, 0.0);\n    vec2 offset12 = shadowNDCPos.xy + vec2(-oneTap.x, 0.0);\n    vec2 offset13 = shadowNDCPos.xy + vec2(0.0, 0.0);\n    vec2 offset14 = shadowNDCPos.xy + vec2(oneTap.x, 0.0);\n    vec2 offset15 = shadowNDCPos.xy + vec2(twoTap.x, 0.0);\n    vec2 offset16 = shadowNDCPos.xy + vec2(-twoTap.x, oneTap.y);\n    vec2 offset17 = shadowNDCPos.xy + vec2(-oneTap.x, oneTap.y);\n    vec2 offset18 = shadowNDCPos.xy + vec2(0.0, oneTap.y);\n    vec2 offset19 = shadowNDCPos.xy + vec2(oneTap.x, oneTap.y);\n    vec2 offset20 = shadowNDCPos.xy + vec2(twoTap.x, oneTap.y);\n    vec2 offset21 = shadowNDCPos.xy + vec2(-twoTap.x, twoTap.y);\n    vec2 offset22 = shadowNDCPos.xy + vec2(-oneTap.x, twoTap.y);\n    vec2 offset23 = shadowNDCPos.xy + vec2(0.0, twoTap.y);\n    vec2 offset24 = shadowNDCPos.xy + vec2(oneTap.x, twoTap.y);\n    vec2 offset25 = shadowNDCPos.xy + vec2(twoTap.x, twoTap.y);\n    float block1, block2, block3, block4, block5, block6, block7, block8, block9, block10, block11, block12, block13, block14, block15, block16, block17, block18, block19, block20, block21, block22, block23, block24, block25;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset1), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset2), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset3), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset4), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset5), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset6), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset7), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset8), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block9 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset9), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block10 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset10), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block11 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset11), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block12 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset12), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block13 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset13), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block14 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset14), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block15 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset15), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block16 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset16), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block17 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset17), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block18 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset18), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block19 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset19), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block20 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset20), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block21 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset21), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block22 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset22), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block23 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset23), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block24 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset24), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block25 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset25), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, offset1).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, offset2).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, offset3).x);\n      block4 = step(shadowNDCPos.z, texture2D(shadowMap, offset4).x);\n      block5 = step(shadowNDCPos.z, texture2D(shadowMap, offset5).x);\n      block6 = step(shadowNDCPos.z, texture2D(shadowMap, offset6).x);\n      block7 = step(shadowNDCPos.z, texture2D(shadowMap, offset7).x);\n      block8 = step(shadowNDCPos.z, texture2D(shadowMap, offset8).x);\n      block9 = step(shadowNDCPos.z, texture2D(shadowMap, offset9).x);\n      block10 = step(shadowNDCPos.z, texture2D(shadowMap, offset10).x);\n      block11 = step(shadowNDCPos.z, texture2D(shadowMap, offset11).x);\n      block12 = step(shadowNDCPos.z, texture2D(shadowMap, offset12).x);\n      block13 = step(shadowNDCPos.z, texture2D(shadowMap, offset13).x);\n      block14 = step(shadowNDCPos.z, texture2D(shadowMap, offset14).x);\n      block15 = step(shadowNDCPos.z, texture2D(shadowMap, offset15).x);\n      block16 = step(shadowNDCPos.z, texture2D(shadowMap, offset16).x);\n      block17 = step(shadowNDCPos.z, texture2D(shadowMap, offset17).x);\n      block18 = step(shadowNDCPos.z, texture2D(shadowMap, offset18).x);\n      block19 = step(shadowNDCPos.z, texture2D(shadowMap, offset19).x);\n      block20 = step(shadowNDCPos.z, texture2D(shadowMap, offset20).x);\n      block21 = step(shadowNDCPos.z, texture2D(shadowMap, offset21).x);\n      block22 = step(shadowNDCPos.z, texture2D(shadowMap, offset22).x);\n      block23 = step(shadowNDCPos.z, texture2D(shadowMap, offset23).x);\n      block24 = step(shadowNDCPos.z, texture2D(shadowMap, offset24).x);\n      block25 = step(shadowNDCPos.z, texture2D(shadowMap, offset25).x);\n    #endif\n    vec2 coef = fract(shadowNDCPos.xy * shadowMapResolution);\n    vec2 v1X1 = mix(vec2(block1, block6), vec2(block2, block7), coef.xx);\n    vec2 v1X2 = mix(vec2(block2, block7), vec2(block3, block8), coef.xx);\n    vec2 v1X3 = mix(vec2(block3, block8), vec2(block4, block9), coef.xx);\n    vec2 v1X4 = mix(vec2(block4, block9), vec2(block5, block10), coef.xx);\n    float v1 = mix(v1X1.x, v1X1.y, coef.y) + mix(v1X2.x, v1X2.y, coef.y) + mix(v1X3.x, v1X3.y, coef.y) + mix(v1X4.x, v1X4.y, coef.y);\n    vec2 v2X1 = mix(vec2(block6, block11), vec2(block7, block12), coef.xx);\n    vec2 v2X2 = mix(vec2(block7, block12), vec2(block8, block13), coef.xx);\n    vec2 v2X3 = mix(vec2(block8, block13), vec2(block9, block14), coef.xx);\n    vec2 v2X4 = mix(vec2(block9, block14), vec2(block10, block15), coef.xx);\n    float v2 = mix(v2X1.x, v2X1.y, coef.y) + mix(v2X2.x, v2X2.y, coef.y) + mix(v2X3.x, v2X3.y, coef.y) + mix(v2X4.x, v2X4.y, coef.y);\n    vec2 v3X1 = mix(vec2(block11, block16), vec2(block12, block17), coef.xx);\n    vec2 v3X2 = mix(vec2(block12, block17), vec2(block13, block18), coef.xx);\n    vec2 v3X3 = mix(vec2(block13, block18), vec2(block14, block19), coef.xx);\n    vec2 v3X4 = mix(vec2(block14, block19), vec2(block15, block20), coef.xx);\n    float v3 = mix(v3X1.x, v3X1.y, coef.y) + mix(v3X2.x, v3X2.y, coef.y) + mix(v3X3.x, v3X3.y, coef.y) + mix(v3X4.x, v3X4.y, coef.y);\n    vec2 v4X1 = mix(vec2(block16, block21), vec2(block17, block22), coef.xx);\n    vec2 v4X2 = mix(vec2(block17, block22), vec2(block18, block23), coef.xx);\n    vec2 v4X3 = mix(vec2(block18, block23), vec2(block19, block24), coef.xx);\n    vec2 v4X4 = mix(vec2(block19, block24), vec2(block20, block25), coef.xx);\n    float v4 = mix(v4X1.x, v4X1.y, coef.y) + mix(v4X2.x, v4X2.y, coef.y) + mix(v4X3.x, v4X3.y, coef.y) + mix(v4X4.x, v4X4.y, coef.y);\n    float fAvg = (v1 + v2 + v3 + v4) * 0.0625;\n    return fAvg;\n  }\n  bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n  {\n  \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n  \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n  \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n  \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n  \t\treturn false;\n  \t}\n  \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n  \treturn true;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n  {\n    vec4 newShadowPos = shadowPos;\n    if (normalBias > EPSILON_LOWP)\n    {\n      vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n      if (viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n  {\n  \tvec4 newShadowPos = shadowPos;\n  \tif (normalBias > EPSILON_LOWP)\n  \t{\n  \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n  \t\tif (viewNormal.z < 0.1)\n  \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n  \t}\n  \treturn newShadowPos;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Orthgraphic(float NDCDepth, float projScaleZ, float projBiasZ)\n  {\n  \treturn (NDCDepth - projBiasZ) / projScaleZ;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Perspective(float NDCDepth, float homogenousDividW, float invProjScaleZ, float invProjBiasZ)\n  {\n  \treturn NDCDepth * invProjScaleZ + homogenousDividW * invProjBiasZ;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n  \tvec3 viewSpacePos;\n  \tviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n  \tviewSpacePos.z = GetViewSpaceDepthFromNDCDepth_Perspective(shadowPos.z, shadowPos.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n  \tviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n  \tvec4 clipSpacePos;\n  \tclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n  \tclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n  \t#if CC_SHADOWMAP_USE_LINEAR_DEPTH\n  \t\tclipSpacePos.z = GetLinearDepthFromViewSpace(viewSpacePos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n  \t\tclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n  \t#endif\n  \treturn clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n  {\n  \tfloat coeffA = projScaleZ;\n  \tfloat coeffB = projBiasZ;\n  \tfloat viewSpacePos_z = GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowPos.z, projScaleZ, projBiasZ);\n  \tviewSpacePos_z += viewspaceDepthBias;\n  \tvec4 result = shadowPos;\n  \tresult.z = viewSpacePos_z * coeffA + coeffB;\n  \treturn result;\n  }\n  vec4 ApplyShadowDepthBias_PerspectiveLinearDepth(vec4 shadowPos, float viewspaceDepthBias, vec3 worldPos)\n  {\n    shadowPos.z = CCGetLinearDepth(worldPos, viewspaceDepthBias) * 2.0 - 1.0;\n    shadowPos.z *= shadowPos.w;\n    return shadowPos;\n  }\n  float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCSpotShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    vec4 pos = vec4(1.0);\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      pos = ApplyShadowDepthBias_PerspectiveLinearDepth(shadowPos, shadowBias.x, worldPos);\n    #else\n      pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);\n    #endif\n    float realtimeShadow = 1.0;\n    if (pcf > 2.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft5X(pos, worldPos);\n    }else if (pcf > 1.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft3X(pos, worldPos);\n    }else if (pcf > 0.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft(pos, worldPos);\n    }else {\n      realtimeShadow = CCGetSpotLightShadowFactorHard(pos, worldPos);\n    }\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  float CCShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n    float realtimeShadow = 1.0;\n    #if CC_DIR_SHADOW_PCF_TYPE == 3\n      realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 2\n      realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 1\n      realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 0\n      realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n    #endif\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    bool CCGetCSMLevelWithTransition(out highp float ratio, vec3 clipPos) {\n      highp float maxRange = 1.0 - cc_csmSplitsInfo.x;\n      highp float minRange = cc_csmSplitsInfo.x;\n      highp float thresholdInvert = 1.0 / cc_csmSplitsInfo.x;\n      ratio = 0.0;\n      if (clipPos.x <= minRange) {\n        ratio = clipPos.x * thresholdInvert;\n        return true;\n      }\n      if (clipPos.x >= maxRange) {\n        ratio = 1.0 - (clipPos.x - maxRange) * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y <= minRange) {\n        ratio = clipPos.y  * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y >= maxRange) {\n        ratio = 1.0 - (clipPos.y - maxRange) * thresholdInvert;\n        return true;\n      }\n      return false;\n    }\n    bool CCHasCSMLevel(int level, vec3 worldPos) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      bool hasLevel = false;\n      for (int i = 0; i < 4; i++) {\n        if (i == level) {\n          vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n          if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n              clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n              clipPos.z >= 0.0 && clipPos.z <= 1.0) {\n            hasLevel = true;\n          }\n        }\n      }\n      return hasLevel;\n    }\n    void CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos, int level) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && i == level) {\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n        }\n      }\n    }\n    int CCGetCSMLevel(out bool isTransitionArea, out highp float transitionRatio, out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      int level = -1;\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && level < 0) {\n          #if CC_CASCADED_LAYERS_TRANSITION\n            isTransitionArea = CCGetCSMLevelWithTransition(transitionRatio, clipPos);\n          #endif\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n          level = i;\n        }\n      }\n      return level;\n    }\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      bool isTransitionArea = false;\n      highp float transitionRatio = 0.0;\n      return CCGetCSMLevel(isTransitionArea, transitionRatio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias)\n    {\n      bool isTransitionArea = false;\n      highp float ratio = 0.0;\n      csmPos = vec4(1.0);\n      vec4 shadowProjDepthInfo, shadowProjInfo;\n      vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n      int level = -1;\n      #if CC_CASCADED_LAYERS_TRANSITION\n        level = CCGetCSMLevel(isTransitionArea, ratio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #else\n        level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #endif\n      if (level < 0) { return 1.0; }\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n      csmPosWithBias = pos;\n      float realtimeShadow = 1.0;\n      #if CC_DIR_SHADOW_PCF_TYPE == 3\n        realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 2\n        realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 1\n        realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 0\n        realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n      #endif\n      #if CC_CASCADED_LAYERS_TRANSITION\n        vec4 nextCSMPos = vec4(1.0);\n        vec4 nextShadowProjDepthInfo, nextShadowProjInfo;\n        vec3 nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2;\n        float nextRealtimeShadow = 1.0;\n        CCGetCSMLevel(nextCSMPos, nextShadowProjDepthInfo, nextShadowProjInfo, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, worldPos, level + 1);\n        bool hasNextLevel = CCHasCSMLevel(level + 1, worldPos);\n        if (hasNextLevel && isTransitionArea) {\n          vec4 nexPos = ApplyShadowDepthBias_FaceNormal(nextCSMPos, N, shadowBias.y, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, nextShadowProjInfo.xy);\n          nexPos = ApplyShadowDepthBias_Orthographic(nexPos, shadowBias.x, nextShadowProjDepthInfo.x, nextShadowProjDepthInfo.y);\n          #if CC_DIR_SHADOW_PCF_TYPE == 3\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft5X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 2\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft3X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 1\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 0\n            nextRealtimeShadow = CCGetDirLightShadowFactorHard(nexPos);\n          #endif\n          return mix(mix(nextRealtimeShadow, realtimeShadow, ratio), 1.0, cc_shadowNFLSInfo.w);\n        }\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #else\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #endif\n    }\n  #else\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      return -1;\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias) {\n      csmPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n      return CCShadowFactorBase(csmPosWithBias, csmPos, N, shadowBias);\n    }\n  #endif\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias) {\n    vec4 shadowPosWithDepthBias;\n    return CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, N, shadowBias);\n  }\n  float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n    vec4 csmPos, csmPosWithBias;\n    return CCCSMFactorBase(csmPos, csmPosWithBias, worldPos, N, shadowBias);\n  }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    vec4 shadowPosWithDepthBias;\n    return CCSpotShadowFactorBase(shadowPosWithDepthBias, shadowPos, worldPos, shadowBias);\n  }\n#endif\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n\tcolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  vec3 SHEvaluate(vec3 normal)\n  {\n      vec3 result;\n  #if USE_INSTANCING\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(v_sh_linear_const_r, normal4);\n      result.g = dot(v_sh_linear_const_g, normal4);\n      result.b = dot(v_sh_linear_const_b, normal4);\n  #else\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(cc_sh_linear_const_r, normal4);\n      result.g = dot(cc_sh_linear_const_g, normal4);\n      result.b = dot(cc_sh_linear_const_b, normal4);\n      vec4 n14 = normal.xyzz * normal.yzzx;\n      float n5 = normal.x * normal.x - normal.y * normal.y;\n      result.r += dot(cc_sh_quadratic_r, n14);\n      result.g += dot(cc_sh_quadratic_g, n14);\n      result.b += dot(cc_sh_quadratic_b, n14);\n      result += (cc_sh_quadratic_a.rgb * n5);\n  #endif\n    #if CC_USE_HDR\n      result *= cc_exposure.w * cc_exposure.x;\n    #endif\n    return result;\n  }\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform highp vec4 cc_reflectionProbeData1;\n  uniform highp vec4 cc_reflectionProbeData2;\n  vec4 GetTexData(sampler2D dataMap, float dataMapWidth, float x, float uv_y)\n  {\n    return vec4(\n        decode32(texture2D(dataMap, vec2(((x + 0.5)/dataMapWidth), uv_y))),\n        decode32(texture2D(dataMap, vec2(((x + 1.5)/dataMapWidth), uv_y))),\n        decode32(texture2D(dataMap, vec2(((x + 2.5)/dataMapWidth), uv_y))),\n        decode32(texture2D(dataMap, vec2(((x + 3.5)/dataMapWidth), uv_y)))\n      );\n  }\n  void GetPlanarReflectionProbeData(out vec4 plane, out float planarReflectionDepthScale, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        plane.xyz = texData1.xyz;\n        plane.w = texData2.x;\n        planarReflectionDepthScale = texData2.y;\n        mipCount = texData2.z;\n      #else\n        plane = cc_reflectionProbeData1;\n        planarReflectionDepthScale = cc_reflectionProbeData2.x;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n  }\n  void GetCubeReflectionProbeData(out vec3 centerPos, out vec3 boxHalfSize, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        centerPos = texData1.xyz;\n        boxHalfSize = texData2.xyz;\n        mipCount = texData3.x;\n      #else\n        centerPos = cc_reflectionProbeData1.xyz;\n        boxHalfSize = cc_reflectionProbeData2.xyz;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n  }\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n  void SampleAndDecodeLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  #if CC_LIGHT_MAP_VERSION > 2\n  #elif CC_LIGHT_MAP_VERSION > 1\n  \tvec4 dataLow = texture2D(lightingMap, luv);\n  \tvec4 dataHigh = texture2D(lightingMap, luv + vec2(0.5, 0.0));\n  \tlightmapColor.xyz = dataLow.xyz + dataHigh.xyz * 0.00392156862745098;\n      lightmapColor.rgb *= lum;\n  \tdirShadow = dataLow.a;\n  \tao = dataHigh.a;\n  #else\n      vec4 lightmap = texture2D(lightingMap, luv);\n      lightmapColor = lightmap.rgb * lum;\n  \tdirShadow = lightmap.a;\n  \tao = 1.0;\n  #endif\n  }\n  void GetLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  \tvec4 lightmap;\n  \tvec2 occlusion;\n  \tSampleAndDecodeLightMapColor(lightmapColor, dirShadow, ao, lightingMap, luv, lum, worldNormal);\n  #if CC_USE_HDR\n      lightmapColor.rgb *= cc_exposure.w * cc_exposure.x;\n  #endif\n  }\n#endif\n    uniform vec4 diffuseColor;\n    uniform vec4 specularColor;\n    uniform vec4 emissive;\n    uniform float emissiveScale;\n    uniform float alphaThreshold;\n    uniform float shininessExponent;\n    uniform float glossiness;\n    uniform float metallic;\n    uniform float normalScale;\n    uniform float transparencyFactor;\n    uniform float diffuseFactor;\n    uniform float specularFactor;\n#define DCC_APP_OTHERS 0\n#define DCC_APP_MAX 1\n#define DCC_APP_BLENDER 2\n#define DCC_APP_CINEMA4D 3\n#define DCC_APP_GLTF 4\n#define DCC_APP_MAYA 5\n#if USE_SHININESS_MAP\n  uniform sampler2D shininessExponentMap;\n#endif\n#if USE_SPECULAR_GLOSSINESS_MAP\n  uniform sampler2D specularGlossinessMap;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n #if USE_METALLIC_MAP\n  uniform sampler2D metallicMap;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_EMISSIVESCALE_MAP\n  uniform sampler2D emissiveScaleMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\nfloat discolor(vec3 srcColor)\n{\n  return dot(GRAY_VECTOR, srcColor);\n}\nfloat convertShininessExponent(float shininessExp)\n{\n  #if DCC_APP_NAME == DCC_APP_BLENDER\n    float glossiness = clamp(sqrt(shininessExp) * 0.1, 0.0, 0.95);\n  #elif DCC_APP_NAME == DCC_APP_MAX || DCC_APP_NAME == DCC_APP_MAYA\n    float l2 = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n    float glossiness = pow(l2, 0.5);\n  #else\n    float glossiness = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n  #endif\n    return glossiness;\n}\nfloat getSpecularIntensityFromRoughness(float roughness)\n{\n  #if DCC_APP_NAME == DCC_APP_BLENDER\n    float specularIntensityMultiplier = mix(1.0, 5.0, roughness);\n  #elif DCC_APP_NAME == DCC_APP_CINEMA4D\n    float specularIntensityMultiplier = mix(1.0, 50.0, roughness);\n  #elif DCC_APP_NAME == DCC_APP_MAX || DCC_APP_NAME == DCC_APP_MAYA\n    float specularIntensityMultiplier = mix(1.0, 20.0, roughness);\n  #else\n    float specularIntensityMultiplier = 1.0;\n  #endif\n    return specularIntensityMultiplier;\n}\nvec4 getSpecularColorAndFactor()\n{\n  vec3 inSpecular = specularColor.rgb * specularFactor;\n  float inFactor = 1.0;\n  #if USE_SPECULAR_GLOSSINESS_MAP\n    inSpecular = SRGBToLinear(texture2D(specularGlossinessMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_SPECULAR_MAP\n      vec4 specularTex = texture2D(specularMap, TEXTURE_UV);\n      specularTex.rgb = SRGBToLinear(specularTex.rgb);\n      inSpecular = specularTex.rgb;\n  #endif\n  return vec4(inSpecular, inFactor);\n}\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n  vec3 normal = FSInput_worldNormal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    normal = CalculateNormalFromTangentSpace(nmmp, normalScale, normalize(normal.xyz), normalize(FSInput_worldTangent), FSInput_mirrorNormal);\n  #endif\n  return normalize(normal);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n  vec3 emissiveColor = emissive.rgb;\n  #if USE_EMISSIVE_MAP\n      emissiveColor.rgb = SRGBToLinear(texture2D(emissiveMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_EMISSIVESCALE_MAP\n      vec4 emissiveScaleColor = texture2D(emissiveScaleMap, TEXTURE_UV);\n      emissiveScaleColor.rgb = SRGBToLinear(emissiveScaleColor.rgb);\n      emissiveColor.rgb *= emissiveScaleColor.rgb;\n  #else\n      emissiveColor.rgb *= emissiveScale;\n  #endif\n  return emissiveColor;\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nstruct SurfacesMaterialData\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPos, worldPos_fract_part;\n  #else\n  vec3 worldPos;\n  #endif\n  vec4 baseColor;\n  vec3 worldNormal;\n  vec3 emissive;\n  float specularIntensity;\n  float roughness;\n  float metallic;\n  float ao;\n  vec3 worldTangent, worldBinormal;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 outScatteringColor, inScatteringColor;\n  vec4 transmitScatteringParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 baseColor2ndSpecular, color2ndSpecular;\n  float intensity2ndSpecular, roughness2ndSpecular;\n  vec3 worldNormal2ndSpecular, worldTangent2ndSpecular, worldBinormal2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  vec4 sssParams;\n#endif\n};\nvoid SurfacesFragmentModifySharedData(inout SurfacesMaterialData surfaceData)\n{\n    vec4 baseColor = vec4(1.0);\n    #if USE_VERTEX_COLOR\n      baseColor.rgb *= SRGBToLinear(FSInput_vertexColor.rgb);\n      baseColor.a *= FSInput_vertexColor.a;\n    #endif\n    #if USE_ALBEDO_MAP\n      vec4 texColor = texture2D(albedoMap, TEXTURE_UV);\n      texColor.rgb = SRGBToLinear(texColor.rgb);\n      texColor.a *= transparencyFactor;\n      baseColor *= texColor;\n    #else\n      baseColor *= diffuseColor;\n    #endif\n    baseColor.rgb *= diffuseFactor;\n    #if USE_TRANSPARENCY_MAP\n      baseColor.a = texture2D(transparencyMap, TEXTURE_UV).TRANSPARENCY_MAP_CHANNEL;\n      #if DCC_APP_NAME == DCC_APP_MAYA\n        baseColor.a = 1.0 - baseColor.a;\n      #endif\n    #endif\n    #if USE_ALPHA_TEST\n      if (baseColor.a < alphaThreshold) discard;\n    #endif\n    vec4 specularColorAndFactor = getSpecularColorAndFactor();\n    float inGlossiness = 0.0, inSpecularIntensity = 1.0;\n    #if HAS_EXPORTED_GLOSSINESS\n      #if USE_SPECULAR_GLOSSINESS_MAP\n        inGlossiness = 1.0 - texture2D(specularGlossinessMap, TEXTURE_UV).a;\n      #else\n        inGlossiness = glossiness;\n      #endif\n    #else\n      #if USE_SHININESS_MAP\n        #if GLOSSINESS_MAP_USE_SINGLE_CHANNEL\n          inGlossiness = 1.0 - texture2D(shininessExponentMap, TEXTURE_UV).GLOSSINESS_MAP_CHANNEL;\n        #else\n          inGlossiness = 1.0 - discolor(texture2D(shininessExponentMap, TEXTURE_UV).rgb);\n        #endif\n      #else\n        inGlossiness = convertShininessExponent(shininessExponent);\n      #endif\n      inSpecularIntensity *= getSpecularIntensityFromRoughness(1.0 - inGlossiness);\n    #endif\n    float inMetallic = 0.0;\n    vec3 albedo = baseColor.rgb;\n    #if HAS_EXPORTED_METALLIC\n      inMetallic = metallic;\n      float spec = specularFactor;\n      #if USE_SPECULAR_MAP\n        spec = dot(GRAY_VECTOR, texture2D(specularMap, TEXTURE_UV).rgb);\n      #endif\n      inSpecularIntensity *= spec * 0.5;\n    #else\n      GetMetallicAlbedoFromDiffuseSpecularWithoutColor(inMetallic, albedo.rgb, baseColor.rgb, specularColorAndFactor.rgb, 0.04);\n      inSpecularIntensity *= inMetallic;\n    #endif\n    baseColor.rgb = albedo;\n    surfaceData.baseColor = baseColor;\n    surfaceData.specularIntensity = inSpecularIntensity * 0.5;\n    surfaceData.roughness = 1.0 - inGlossiness;\n    surfaceData.metallic = inMetallic;\n    surfaceData.ao = 1.0;\n    #if USE_OCCLUSION_MAP\n      surfaceData.ao = texture2D(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;\n    #endif\n}\nstruct LightingIntermediateData\n{\n  vec3 N, H, L, V;\n  float distToLight, distToLightSqr;\n  float distToCamera, distToCameraSqr;\n  float angleAttenuation, distAttenuation;\n  float NoL, NoV, NoH;\n  float NoLSat, NoVSat, NoHSat;\n  float NoVAbsSat;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPosition, worldPosition_fract_part;\n  #else\n  vec3 worldPosition;\n  #endif\n  vec3 T, B;\n  float specularParam;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 shadowPosAndDepth;\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitScatteringParams;\n  vec3 outScatteringColor, inScatteringColor;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n};\nvoid CCSurfacesLightingGetIntermediateData_PerPixel(inout LightingIntermediateData data, vec3 worldNormal, vec3 worldPos, vec3 worldTangent, vec3 worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n    , float anisotropyShape\n#endif\n)\n{\n  data.N = worldNormal;\n  data.V = cc_cameraPos.xyz - worldPos;\n  data.distToCameraSqr = dot(data.V, data.V);\n  data.distToCamera = sqrt(data.distToCameraSqr);\n  data.V /= data.distToCamera;\n  data.angleAttenuation = data.distAttenuation = 1.0;\n  data.NoV = dot(data.N, data.V);\n  data.NoVSat = max(data.NoV, 0.0);\n  data.NoVAbsSat = max(abs(data.NoV), 0.0);\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(data.worldPosition, data.worldPosition_fract_part, worldPos);\n  #else\n  data.worldPosition = worldPos;\n  #endif\n  data.T = worldTangent;\n  data.B = worldBinormal;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  data.anisotropyShape = anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  data.outScatteringColor = vec3(1.0);\n  data.inScatteringColor = vec3(0.0);\n  data.transmitScatteringParams = vec4(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  data.shadowPosAndDepth = vec4(0.0, 0.0, SURFACES_MAX_TRANSMIT_DEPTH_VALUE, SURFACES_MAX_TRANSMIT_DEPTH_VALUE);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  data.baseColorTT = vec3(0.0);\n  data.ttIntensity = data.ttScatterCoef = 0.0;\n#endif\n}\nvoid CCSurfacesLightingGetIntermediateData_PerLight(inout LightingIntermediateData data, vec3 lightDirWithDist)\n{\n  data.L = lightDirWithDist;\n  data.distToLightSqr = dot(data.L, data.L);\n  data.distToLight = sqrt(data.distToLightSqr);\n  data.L /= data.distToLight;\n  data.H = normalize(data.L + data.V);\n  data.NoL = dot(data.N, data.L);\n  data.NoH = dot(data.N, data.H);\n  data.NoLSat = max(data.NoL, 0.0);\n  data.NoHSat = max(data.NoH, 0.0);\n}\nstruct LightingResult\n{\n  vec3 diffuseColorWithLighting, specularColorWithLighting, specularColorWithEnvLighting;\n  vec3 directDiffuse, directSpecular;\n  vec3 environmentDiffuse, environmentSpecular;\n  float shadow, ao;\n  vec3 lightmapColor;\n  vec3 emissive;\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float fresnel;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  vec3 directTransmitSpecular, environmentTransmitSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 directTransmitDiffuse, environmentTransmitDiffuse;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 direct2ndSpecular, environment2ndSpecular;\n  vec3 specularColorWithLighting2ndSpecular, specularColorWithEnvLighting2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 directTT;\n  vec3 diffuseColorWithLightingTT;\n#endif\n};\nstruct LightingMiscData\n{\n  float lightType;\n  vec3 lightPos, lightDir;\n  vec4 lightColorAndIntensity;\n  vec4 lightSizeRangeAngle;\n};\nfloat D_GGX(float roughness, float NoH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float d = (NoH * m2 - NoH) * NoH + 1.0;\n    return m2 / max(EPSILON, d * d);\n}\nfloat D_GGXMobile(float roughness, float NoH) {\n  float OneMinusNoHSqr = 1.0 - NoH * NoH;\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / max(EPSILON, OneMinusNoHSqr + n * n);\n  return p * p;\n}\nvoid GetAnisotropicRoughness(float roughness, float anisotropyShape, out float roughnessX, out float roughnessY)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    float r1 = roughness, r2 = roughness;\n    float lerpedRoughness = mix(1.0, 10.0, anisotropyShape);\n    r2 *= shapeSign < 0.0 ? lerpedRoughness : 1.0;\n    r1 *= shapeSign > 0.0 ? lerpedRoughness : 1.0;\n    roughnessX = saturate(r1);\n    roughnessY = saturate(r2);\n}\nfloat D_GGXAniso(float RoughnessX, float RoughnessY, float NoH, vec3 H, vec3 X, vec3 Y)\n{\n    float mx = max(EPSILON_LOWP, RoughnessX * RoughnessX);\n    float my = max(EPSILON_LOWP, RoughnessY * RoughnessY);\n    float XoH = dot(X, H);\n    float YoH = dot(Y, H);\n    float d = XoH * XoH / (mx * mx) + YoH * YoH / (my * my) + NoH * NoH;\n    return 1.0 / max(EPSILON_LOWP, mx * my * d * d);\n}\nvec3 GetAnisotropicReflect(float roughness, float anisotropyShape, vec3 V, vec3 N, vec3 X, vec3 Y)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    anisotropyShape = min(anisotropyShape, 0.4);\n    anisotropyShape *= smoothstep(0.0, 0.03, roughness);\n    vec3 reflectTarget = shapeSign < 0.0 ? mix(N, -Y, anisotropyShape) :\n                         shapeSign > 0.0 ? mix(N, -X, anisotropyShape) : N;\n    return reflect(-V, reflectTarget);\n}\nvec3 IntegratedGFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return max(vec3(0.0), specular * AB.x + AB.y);\n}\n#define DiffuseCoefficient_EnergyConservation INV_PI\nfloat CalculateFresnelCoefficient(float ior, float NoVSat)\n{\n\tfloat g, c, n, prev, next;\n\tn = ior;\n\tc = ior * NoVSat;\n\tg = sqrt(1.0 + c * c - c);\n\tprev = (g - c) / (g + c);\n\tnext = (c * (g+c) - n*n) / (c * (g-c) + n*n);\n\tprev *= prev;\n\tnext *= next;\n\treturn 0.5 * prev * (1.0 + next);\n}\nvec3 CalculateScattering(vec3 unscatteredColor, float distance, float outScatterExtinctCoef, float inScatterExtinctCoef, float inScatterCoef, vec3 inScatterColor, vec3 outScatterColor)\n{\n    vec2 e = vec2(outScatterExtinctCoef, inScatterExtinctCoef * inScatterCoef);\n    vec2 extinction = exp(-e * distance);\n    vec3 inScattered = (1.0 - extinction.y) * inScatterColor;\n\tvec3 outScattered = unscatteredColor * extinction.x * outScatterColor;\n    return outScattered + inScattered;\n}\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat CalculateDistanceAttenuation(float distToLightSqr, float lightRadius, float lightRange)\n{\n  float litRadiusSqr = lightRadius * lightRadius;\n  float attRadiusSqrInv = 1.0 / max(lightRange, 0.01);\n  attRadiusSqrInv *= attRadiusSqrInv;\n  float edgeAttenuation = litRadiusSqr / max(litRadiusSqr, distToLightSqr);\n  return GetDistAtt(distToLightSqr, attRadiusSqrInv) * edgeAttenuation;\n}\nfloat CalculateAngleAttenuation(vec3 spotLightDir, vec3 L, float cosAngleOuter)\n{\n  float cosInner = max(dot(spotLightDir, L), 0.01);\n  float litAngleScale = 1.0 / max(0.001, cosInner - cosAngleOuter);\n  float litAngleOffset = -cosAngleOuter * litAngleScale;\n  return GetAngleAtt(L, spotLightDir, litAngleScale, litAngleOffset);\n}\nvec3 CalculateRefractDirection(vec3 N, vec3 V, float NoV, float ior)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  float cosA = abs(NoV);\n  float sinA = sqrt(1.0 - cosA * cosA);\n  float sinB = saturate(sinA / ior);\n  float cosB = sqrt(1.0 - sinB * sinB);\n  vec3 edgeA = -V + N * cosA;\n  vec3 edgeB = normalize(edgeA) * sinB;\n  vec3 R = edgeB - N * cosB;\n  return R;\n}\nvec3 CalculateReflectDirection(vec3 N, vec3 V, float NoV)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  return reflect(-V, N);\n}\nvec3 CalculatePlanarReflectPositionOnPlane(vec3 N, vec3 V, vec3 worldPos, vec4 plane, vec3 cameraPos, float probeReflectedDepth)\n{\n  float distPixelToPlane = -dot(plane, vec4(worldPos, 1.0));\n  plane.w += distPixelToPlane;\n  float distCameraToPlane = abs(-dot(plane, vec4(cameraPos, 1.0)));\n  vec3 planeN = plane.xyz;\n  vec3 virtualCameraPos = cameraPos - 2.0 * distCameraToPlane * planeN;\n  vec3 bumpedR = normalize(reflect(-V, N));\n  vec3 reflectedPointPos = worldPos + probeReflectedDepth * bumpedR;\n  vec3 virtualCameraToReflectedPoint = normalize(reflectedPointPos - virtualCameraPos);\n  float y = distCameraToPlane / max(EPSILON_LOWP, dot(planeN, virtualCameraToReflectedPoint));\n  return virtualCameraPos + y * virtualCameraToReflectedPoint;\n}\nvec4 CalculateBoxProjectedDirection(vec3 R, vec3 worldPos, vec3 cubeCenterPos, vec3 cubeBoxHalfSize)\n{\n  vec3 W = worldPos - cubeCenterPos;\n  vec3 projectedLength = (sign(R) * cubeBoxHalfSize - W) / (R + vec3(EPSILON));\n  float len = min(min(projectedLength.x, projectedLength.y), projectedLength.z);\n  vec3 P = W + len * R;\n  float weight = len < 0.0 ? 0.0 : 1.0;\n  return vec4(P, weight);\n}\nvec3 CalculateDirectDiffuse(in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    return irradiance * DiffuseCoefficient_EnergyConservation;\n}\nvec3 CalculateDirectSpecular(in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    float roughness = lightingData.specularParam;\n  #if CC_SURFACES_LIGHTING_ANISOTROPIC\n      float rT, rB;\n      GetAnisotropicRoughness(roughness, lightingData.anisotropyShape, rT, rB);\n      float calcSpec = D_GGXAniso(rT, rB, lightingData.NoHSat, lightingData.H, lightingData.T, lightingData.B);\n  #else\n    #if CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n      float calcSpec = (roughness * 0.25 + 0.25) * D_GGXMobile(roughness, lightingData.NoHSat);\n    #else\n      float calcSpec = D_GGX(roughness, lightingData.NoHSat);\n    #endif\n  #endif\n    return irradiance * calcSpec;\n}\n#if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  vec3 EnvAnisotropicReflection(samplerCube tex, vec3 R, float roughness, float mipCount, float anisotropyShape, vec3 V, vec3 N, vec3 T, vec3 B) {\n      R = normalize(R);\n      float integratedBRDF = 0.0;\n      vec3 envSpec = vec3(0.0);\n      const int SAMPLE_STEP_COUNT = CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT;\n      float sampleAngleRange = PI * abs(anisotropyShape);\n      vec3 anisoDirection = anisotropyShape < 0.0 ? T : B;\n      vec3 ROnNormalPlane = normalize(R - anisoDirection * dot(R, anisoDirection));\n      vec3 stepOffset = normalize(ROnNormalPlane - N) * (sampleAngleRange / float(SAMPLE_STEP_COUNT * 2));\n      for (int i = -SAMPLE_STEP_COUNT; i <= SAMPLE_STEP_COUNT; ++i)\n      {\n          float rT, rB;\n          GetAnisotropicRoughness(roughness, anisotropyShape, rT, rB);\n          #if CC_IBL_CONVOLUTED\n            float coef = abs(float(i)) / float(SAMPLE_STEP_COUNT) * float(SAMPLE_STEP_COUNT);\n          #else\n            float coef = pow(abs(float(i)) / float(SAMPLE_STEP_COUNT), 1.3) * float(SAMPLE_STEP_COUNT);\n          #endif\n          vec3 H = normalize(N + stepOffset * sign(float(i)) * coef);\n          vec3 L = reflect(-V, H);\n          float NoHSat = saturate(dot(N, H));\n          float calcSpec = D_GGXAniso(rT, rB, NoHSat, H, T, B);\n          envSpec += calcSpec * EnvReflection(tex, L, roughness, mipCount);\n          integratedBRDF += calcSpec;\n      }\n      envSpec /= integratedBRDF;\n      return envSpec;\n  }\n#endif\nvec3 SampleEnvironmentSpecular(samplerCube tex, in LightingIntermediateData lightingData, float mipCount)\n{\n    vec3 envSpec = vec3(0.0);\n    float roughness = lightingData.specularParam;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV);\n    #endif\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(tex, R, roughness, mipCount, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, mipCount, 0.6);\n      #else\n        envSpec = EnvReflection(tex, R, roughness, mipCount);\n      #endif\n    #endif\n    return envSpec;\n}\nvec3 SampleEnvironmentSpecular(samplerCube tex, in LightingIntermediateData lightingData, float mipCount, vec3 worldPos, vec3 cubeCenterPos, vec3 boxHalfSize)\n{\n    vec3 envSpec = vec3(0.0);\n    float roughness = lightingData.specularParam;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV);\n    #endif\n    vec4 fixedR = CalculateBoxProjectedDirection(R, worldPos, cubeCenterPos, boxHalfSize);\n    R = fixedR.xyz;\n    vec3 envmap = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w).xyz;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(tex, fixedR.xyz, roughness, mipCount, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n      envSpec = mix(envmap, envSpec, fixedR.w);\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, mipCount, 0.6);\n      #else\n        envSpec = mix(envmap, EnvReflection(tex, R, roughness, mipCount), fixedR.w);\n      #endif\n    #endif\n    return envSpec;\n}\nvec3 CalculateEnvironmentDiffuse(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  float fAmb = max(EPSILON, 0.5 - lightingData.N.y * 0.5);\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP && !CC_USE_LIGHT_PROBE\n      vec3 rotationDir = RotationVecFromAxisY(lightingData.N, cc_surfaceTransform.z, cc_surfaceTransform.w);\n      vec4 diffuseMap = textureCube(cc_diffuseMap, rotationDir);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n  #endif\n  ambDiff.rgb *= lightIntensity;\n  #if CC_USE_LIGHT_PROBE\n    ambDiff.rgb += SHEvaluate(lightingData.N);\n  #endif\n  return ambDiff.rgb;\n}\nvec3 CalculateEnvironmentSpecular(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  vec3 envSpec = vec3(0.0);\n#if CC_USE_REFLECTION_PROBE\n    vec3 worldPos;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    worldPos = unpackHighpData(lightingData.worldPosition, lightingData.worldPosition_fract_part);\n    #else\n    worldPos = lightingData.worldPosition;\n    #endif\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n    if(FSInput_reflectionProbeId < 0.0){\n        envSpec = SampleEnvironmentSpecular(cc_reflectionProbeCubemap, lightingData, cc_ambientGround.w);\n    }else{\n      vec3 centerPos, boxHalfSize;\n      float mipCount;\n      GetCubeReflectionProbeData(centerPos, boxHalfSize, mipCount, FSInput_reflectionProbeId);\n      envSpec = SampleEnvironmentSpecular(cc_reflectionProbeCubemap, lightingData, mipCount, worldPos, centerPos, boxHalfSize);\n    }\n  #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_PLANAR\n    vec3 R = normalize(CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV));\n    if(FSInput_reflectionProbeId < 0.0){\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPos, cc_matViewProj, cc_cameraPos.w, lightingData.V, R);\n        envSpec = unpackRGBE(fragTextureLod(cc_reflectionProbePlanarMap, screenUV, 1.0)).xyz;\n    }else{\n        vec4 plane;\n        float planarReflectionDepthScale, mipCount;\n        GetPlanarReflectionProbeData(plane, planarReflectionDepthScale, mipCount, FSInput_reflectionProbeId);\n        vec3 worldPosOffset = CalculatePlanarReflectPositionOnPlane(lightingData.N, lightingData.V, worldPos, plane, cc_cameraPos.xyz, planarReflectionDepthScale);\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPosOffset, cc_matViewProj, cc_cameraPos.w, lightingData.V, R);\n        envSpec = unpackRGBE(fragTextureLod(cc_reflectionProbePlanarMap, screenUV, mipCount)).xyz;\n    }\n  #endif\n#elif CC_USE_IBL\n    envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n#endif\n  return envSpec * lightIntensity;\n}\nbool CCSurfacesLightingEnableShadow(in float NoL)\n{\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  return true;\n#elif CC_SURFACES_LIGHTING_SSS\n  return true;\n#else\n  return NoL > 0.0;\n#endif\n}\nfloat CCSurfacesLightingCalculateDistanceAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle)\n{\n  return CalculateDistanceAttenuation(lightingData.distToLightSqr, lightSizeRangeAngle.x, lightSizeRangeAngle.y);\n}\nfloat CCSurfacesLightingCalculateAngleAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle, in vec3 spotLightDir)\n{\n  return CalculateAngleAttenuation(spotLightDir, lightingData.L, lightSizeRangeAngle.z);\n}\nvoid CCSurfacesLightingCalculateDirect(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n#if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n  lightingDiffuse = CalculateDirectDiffuse(lightingData, lightSourceColorAndIntensity);\n#else\n  lightingDiffuse = vec3(0.0);\n#endif\n#if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n  lightingSpecular = CalculateDirectSpecular(lightingData, lightSourceColorAndIntensity);\n#else\n  lightingSpecular = vec3(0.0);\n#endif\n}\nvoid CCSurfacesLightingCalculateEnvironment(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n{\n#if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n  lightingDiffuse = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n#else\n  lightingDiffuse = vec3(0.0);\n#endif\n#if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n  lightingSpecular = CalculateEnvironmentSpecular(lightingData, lightIntensity);\n#else\n  lightingSpecular = vec3(0.0);\n#endif\n}\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float CCSurfaceLightingCalculateFresnel(in LightingIntermediateData lightingData)\n  {\n    return CalculateFresnelCoefficient(lightingData.ior, abs(lightingData.NoV));\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  void CCSurfacesLightingCalculateDirectTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    float roughness = lightingData.specularParam;\n    float NoLSat = saturate(dot(lightingData.N, -lightingData.L));\n    vec3 irradiance = NoLSat * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float RoL = dot(lightingData.L, normalize(R));\n    float calcSpec = D_GGX(roughness, saturate(RoL));\n    lightingSpecular = irradiance * calcSpec;\n  }\n  void CCSurfacesLightingCalculateEnvironmentTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n  {\n    vec3 envSpec = vec3(0.0);\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float roughness = lightingData.specularParam;\n  #if CC_USE_REFLECTION_PROBE\n    #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n      envSpec = EnvReflection(cc_reflectionProbeCubemap, R, roughness, cc_ambientGround.w);\n    #endif\n  #endif\n  #if CC_USE_IBL && CC_USE_REFLECTION_PROBE != REFLECTION_PROBE_TYPE_CUBE\n    envSpec = EnvReflection(cc_environment, R, roughness, cc_ambientGround.w);\n  #endif\n    lightingSpecular = CalculateScattering(envSpec * lightIntensity, lightingData.transmitScatteringParams.w, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define objectThickness lightingData.transmitDiffuseParams.x\n  #define transmitMask lightingData.transmitDiffuseParams.y\n  #define envTransmitScale lightingData.transmitDiffuseParams.z\n  #define envFixedDistanceScale lightingData.transmitScatteringParams.w\n  #define transmitDistanceScale lightingData.transmitDiffuseParams.w\n  #define DONOT_USE_SHADOWMAP_DISTANCE ((abs(float(lightingData.shadowPosAndDepth.z) - float(lightingData.shadowPosAndDepth.w)) < EPSILON) && (abs(float(lightingData.shadowPosAndDepth.z) - float(SURFACES_MAX_TRANSMIT_DEPTH_VALUE)) < EPSILON))\n  #define SHADOWMAP_DISTANCE max(lightingData.shadowPosAndDepth.w - lightingData.shadowPosAndDepth.z, 0.0)\n  void CCSurfacesLightingCalculateDirectTransmitDiffuse(out vec3 transmitDiffuse, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity, float shadow)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n    float distance = lightingData.transmitScatteringParams.w;\n    if (!DONOT_USE_SHADOWMAP_DISTANCE)\n    {\n      distance = transmitDistanceScale * SHADOWMAP_DISTANCE;\n      shadow = step(SHADOWMAP_DISTANCE, objectThickness) > 0.0 ? 1.0 : shadow;\n    }\n    vec3 backIrradiance = CalculateDirectDiffuse(lightingData, lightSourceColorAndIntensity);\n    backIrradiance *= shadow * transmitMask;\n    transmitDiffuse = CalculateScattering(backIrradiance, distance, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n  #else\n    transmitDiffuse = vec3(0.0);\n  #endif\n  }\n  void CCSurfacesLightingCalculateEnvironmentTransmitDiffuse(out vec3 transmitDiffuse, in LightingIntermediateData lightingData, float lightIntensity, float ao, vec3 shadowLightDirection)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n    float distance = lightingData.transmitScatteringParams.w;\n    if (!DONOT_USE_SHADOWMAP_DISTANCE)\n    {\n      float shadowMapDistance = transmitDistanceScale * SHADOWMAP_DISTANCE;\n      float fixedDistance = transmitDistanceScale * envFixedDistanceScale;\n      float lerpCoef = saturate(dot(lightingData.N, shadowLightDirection));\n      distance = mix(fixedDistance, shadowMapDistance, lerpCoef);\n    }\n    vec3 backIrradiance = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n    backIrradiance *= ao * transmitMask;\n    transmitDiffuse = CalculateScattering(backIrradiance, distance, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n    transmitDiffuse *= envTransmitScale;\n  #else\n    transmitDiffuse = vec3(0.0);\n  #endif\n  }\n  #undef objectThickness\n  #undef transmitMask\n  #undef envTransmitScale\n  #undef envFixedDistanceScale\n  #undef DONOT_USE_SHADOWMAP_DISTANCE\n  #undef SHADOWMAP_DISTANCE\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #ifndef CC_SURFACES_FRAGMENT_MODIFY_2ND_SPECULAR_COLOR\n  #endif\n  void CCSurfacesLightingCalculateDirect2ndSpecular(out vec3 specularLighting, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity, float intensitySpecular, in vec3 originalSpecular)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n    vec3 unused;\n    CCSurfacesLightingCalculateDirect(unused, specularLighting, lightingData, lightSourceColorAndIntensity);\n    specularLighting *= intensitySpecular;\n  #else\n    specularLighting = vec3(0.0);\n  #endif\n  }\n  void CCSurfacesLightingCalculateEnvironment2ndSpecular(out vec3 specularLighting, in LightingIntermediateData lightingData, float lightIntensity, float intensitySpecular, in vec3 originalSpecular)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n    vec3 unused;\n    specularLighting = CalculateEnvironmentSpecular(lightingData, lightIntensity);\n    specularLighting *= intensitySpecular;\n  #else\n    specularLighting = vec3(0.0);\n  #endif\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  void CCSurfacesLightingCalculateDirectTT(inout LightingResult lightingResult, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    lightingResult.diffuseColorWithLightingTT = lightingResult.diffuseColorWithLighting;\n    float w = lightingData.ttIntensity;\n    vec3 scatteredLighting = pow(saturate(lightingData.baseColorTT * w + lightingData.NoLSat) * lightingData.NoLSat, vec3(mix(0.5, 0.5 + lightingData.ttScatterCoef, w)));\n    vec3 ttLighting = scatteredLighting - lightingData.NoLSat;\n    lightingResult.directTT = ttLighting * DiffuseCoefficient_EnergyConservation * lightSourceColorAndIntensity.xyz* lightSourceColorAndIntensity.w;\n  }\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n    return FSInput_vertexColor;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n    return normalize(FSInput_worldNormal);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_TANGENT_AND_BINORMAL\nvoid SurfacesFragmentModifyWorldTangentAndBinormal(inout vec3 worldTangent, inout vec3 worldBinormal, vec3 worldNormal)\n{\n    vec3 tangent = normalize(FSInput_worldTangent);\n#if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 binormal = normalize(CalculateBinormal(worldNormal.xyz, tangent, FSInput_mirrorNormal));\n    tangent = normalize(cross(binormal, worldNormal));\n#else\n    vec3 binormal = vec3(0.0, 0.0, 0.0);\n#endif\n    worldTangent = tangent;\n    worldBinormal = binormal;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_IOR\nfloat SurfacesFragmentModifyIOR()\n{\n    return 1.0;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\nvec4 SurfacesFragmentModifyAnisotropyParams(out float isRotation)\n{\n    isRotation = 1.0;\n    return vec4(1.0, 0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvec4 SurfacesFragmentModifyPBRParams()\n{\n    return vec4(1.0, 0.5, 0.0, 0.5);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_SCATTERING_PARAMS\nvec4 SurfacesFragmentModifyTransmitScatteringParams()\n{\n    return vec4(1.0, 1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_IN_SCATTERING_COLOR\nvec3 SurfacesFragmentModifyTransmitInScatteringColor()\n{\n    return vec3(0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_OUT_SCATTERING_COLOR\nvec3 SurfacesFragmentModifyTransmitOutScatteringColor()\n{\n    return vec3(1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_DIFFUSE_PARAMS\nvec4 SurfacesFragmentModifyTransmitDiffuseParams()\n{\n    return vec4(1.0, 1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_PARAMS\nvec4 SurfacesFragmentModifyTRTParams()\n{\n    return vec4(0.2, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_COLOR\nvec3 SurfacesFragmentModifyTRTColor()\n{\n    return vec3(1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TT_PARAMS\nvec4 SurfacesFragmentModifyTTParams()\n{\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TT_COLOR\nvec3 SurfacesFragmentModifyTTColor(in vec3 baseColor)\n{\n    return vec3(1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_DUAL_LOBE_SPECULAR_PARAMS\nvec4 SurfacesFragmentModifyDualLobeSpecularParams(float roughness)\n{\n    return vec4(0.2, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SSS_PARAMS\nvec4 SurfacesFragmentModifySSSParams()\n{\n    return vec4(1.0, 0.1, 1.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nvoid SurfacesFragmentModifySharedData(inout SurfacesMaterialData surfaceData)\n{\n}\n#endif\nvoid CCSurfacesFragmentGetMaterialData(inout SurfacesMaterialData surfaceData)\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part, FSInput_worldPos);\n  #else\n  surfaceData.worldPos = FSInput_worldPos;\n  #endif\n  surfaceData.baseColor = SurfacesFragmentModifyBaseColorAndTransparency();\n  surfaceData.worldNormal = SurfacesFragmentModifyWorldNormal();\n  SurfacesFragmentModifyWorldTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal);\n  surfaceData.ior = SurfacesFragmentModifyIOR();\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float isRotation;\n  vec4 anisotropyParams = SurfacesFragmentModifyAnisotropyParams(isRotation);\n  surfaceData.anisotropyShape = anisotropyParams.x;\n  if (isRotation > 0.0) {\n    RotateTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal, anisotropyParams.y);\n  } else {\n    vec3 anisoDirTS = anisotropyParams.yzw;\n    vec3 tangentWS = anisoDirTS.x * surfaceData.worldTangent + anisoDirTS.y * surfaceData.worldBinormal + anisoDirTS.z * surfaceData.worldNormal;\n    surfaceData.worldTangent = normalize(tangentWS);\n    surfaceData.worldBinormal = cross(surfaceData.worldNormal, tangentWS);\n  }\n#endif\n  surfaceData.emissive = SurfacesFragmentModifyEmissive();\n  vec4 pbr = SurfacesFragmentModifyPBRParams();\n  surfaceData.ao = pbr.x;\n  surfaceData.roughness = pbr.y;\n  surfaceData.metallic = pbr.z;\n  surfaceData.specularIntensity = pbr.w;\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  surfaceData.transmitScatteringParams = SurfacesFragmentModifyTransmitScatteringParams();\n  surfaceData.inScatteringColor = SurfacesFragmentModifyTransmitInScatteringColor();\n  surfaceData.outScatteringColor = SurfacesFragmentModifyTransmitOutScatteringColor();\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  surfaceData.transmitDiffuseParams = SurfacesFragmentModifyTransmitDiffuseParams();\n#endif\n#if CC_SURFACES_LIGHTING_TRT\n  vec4 trtParams = SurfacesFragmentModifyTRTParams();\n  surfaceData.roughness2ndSpecular = saturate(surfaceData.roughness + trtParams.x);\n  surfaceData.intensity2ndSpecular = trtParams.w;\n  surfaceData.baseColor2ndSpecular = vec3(1.0);\n  surfaceData.color2ndSpecular = SurfacesFragmentModifyTRTColor();\n  surfaceData.worldNormal2ndSpecular = surfaceData.worldNormal;\n  surfaceData.worldTangent2ndSpecular = surfaceData.worldTangent;\n  surfaceData.worldBinormal2ndSpecular = surfaceData.worldBinormal;\n  RotateNormalAndBinormal(surfaceData.worldBinormal2ndSpecular, surfaceData.worldNormal2ndSpecular, surfaceData.worldTangent2ndSpecular, trtParams.y, FSInput_mirrorNormal);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec4 ttParams = SurfacesFragmentModifyTTParams();\n  surfaceData.ttScatterCoef = ttParams.x;\n  surfaceData.ttIntensity = ttParams.w;\n  surfaceData.baseColorTT = SurfacesFragmentModifyTTColor(surfaceData.baseColor.rgb);\n#endif\n#if CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  vec4 dualLobeParams = SurfacesFragmentModifyDualLobeSpecularParams(surfaceData.roughness);\n  surfaceData.roughness2ndSpecular = saturate(dualLobeParams.x);\n  surfaceData.intensity2ndSpecular = dualLobeParams.w;\n  surfaceData.baseColor2ndSpecular = surfaceData.baseColor.rgb;\n  surfaceData.color2ndSpecular = vec3(1.0);\n  surfaceData.worldNormal2ndSpecular = surfaceData.worldNormal;\n  surfaceData.worldTangent2ndSpecular = surfaceData.worldTangent;\n  surfaceData.worldBinormal2ndSpecular = surfaceData.worldBinormal;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  surfaceData.sssParams = SurfacesFragmentModifySSSParams();\n#endif\n  SurfacesFragmentModifySharedData(surfaceData);\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP) {\n      surfaceData.worldNormal = normalize(FSInput_worldNormal);\n      surfaceData.worldTangent = normalize(FSInput_worldTangent);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW\n  if (!IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO)\n  {\n      surfaceData.baseColor.rgb = vec3(1.0);\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        surfaceData.baseColor2ndSpecular.rgb = vec3(1.0);\n      #endif\n      #if CC_SURFACES_LIGHTING_TT\n        surfaceData.baseColorTT.rgb = vec3(1.0);\n      #endif\n  }\n#endif\n}\nvec3 CCSurfacesGetDiffuseColor(in SurfacesMaterialData surfaceData)\n{\n  return surfaceData.baseColor.rgb * (1.0 - surfaceData.metallic);\n}\nvec3 CCSurfacesGetSpecularColor(in SurfacesMaterialData surfaceData)\n{\n  float F0 = surfaceData.specularIntensity * 0.08;\n  return mix(vec3(F0), surfaceData.baseColor.rgb, surfaceData.metallic);\n}\nvoid CCSurfacesLightingInitializeColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, inout vec3 specularColorWithEnvLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n  diffuseColorWithLighting = CCSurfacesGetDiffuseColor(surfaceData);\n  specularColorWithLighting = CCSurfacesGetSpecularColor(surfaceData).xyz;\n  specularColorWithEnvLighting = IntegratedGFApprox(specularColorWithLighting, surfaceData.roughness, lightingData.NoVAbsSat);\n}\nvoid CCSurfacesLightingCalculateColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, inout vec3 specularColorWithEnvLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n}\nvoid CCSurfacesInitializeLightingIntermediateData(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  vec3 worldPos;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n  #else\n  worldPos = surfaceData.worldPos;\n  #endif\n  CCSurfacesLightingGetIntermediateData_PerPixel(lightingData, surfaceData.worldNormal, worldPos, surfaceData.worldTangent, surfaceData.worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n      , surfaceData.anisotropyShape\n#endif\n  );\n  lightingData.specularParam = surfaceData.roughness;\n  lightingData.ior = surfaceData.ior;\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingData.transmitScatteringParams = surfaceData.transmitScatteringParams;\n  lightingData.inScatteringColor = surfaceData.inScatteringColor;\n  lightingData.outScatteringColor = surfaceData.outScatteringColor;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingData.transmitDiffuseParams = surfaceData.transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  lightingData.baseColorTT = surfaceData.baseColorTT;\n  lightingData.ttIntensity = surfaceData.ttIntensity;\n  lightingData.ttScatterCoef = surfaceData.ttScatterCoef;\n#endif\n}\nvoid CCSurfacesLightingCalculateIntermediateData_PerLight(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData, vec3 lightDirWithDist)\n{\n  CCSurfacesLightingGetIntermediateData_PerLight(lightingData, lightDirWithDist);\n}\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\nvoid CCSurfacesGetLightingIntermediateDataTransmitDiffuse(inout LightingIntermediateData lightingDataTD, in LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  lightingDataTD = lightingData;\n  lightingDataTD.N = lightingData.transmitScatteringParams.z > 0.0 ? -FSInput_worldNormal : -(normalize(FSInput_worldNormal)+lightingData.V);\n  lightingDataTD.N = normalize(lightingDataTD.N);\n}\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\nvoid CCSurfacesGetSurfacesMaterialData2ndSpecular(inout SurfacesMaterialData surfaceData2ndSpecular, in SurfacesMaterialData surfaceData)\n{\n  surfaceData2ndSpecular = surfaceData;\n  surfaceData2ndSpecular.baseColor = vec4(surfaceData.baseColor2ndSpecular, 1.0);\n  surfaceData2ndSpecular.roughness = surfaceData.roughness2ndSpecular;\n  surfaceData2ndSpecular.worldNormal = surfaceData.worldNormal2ndSpecular;\n  surfaceData2ndSpecular.worldTangent = surfaceData.worldTangent2ndSpecular;\n  surfaceData2ndSpecular.worldBinormal = surfaceData.worldBinormal2ndSpecular;\n}\n#endif\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData)\n{\n  lightingResult.ao = surfaceData.ao;\n  lightingResult.emissive = surfaceData.emissive;\n}\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult)\n{\n  lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  lightingResult.directTransmitSpecular = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingResult.directTransmitDiffuse = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  lightingResult.direct2ndSpecular = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  lightingResult.directTT = vec3(0.0);\n#endif\n}\nvoid CCSurfacesAccumulateLightingResult(inout LightingResult lightingResultAccumulated, in LightingResult lightingResult)\n{\n  lightingResultAccumulated.directDiffuse += lightingResult.directDiffuse * lightingResult.shadow;\n  lightingResultAccumulated.directSpecular += lightingResult.directSpecular * lightingResult.shadow;\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    lightingResultAccumulated.directTransmitSpecular += lightingResult.directTransmitSpecular;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    lightingResultAccumulated.directTransmitDiffuse += lightingResult.directTransmitDiffuse;\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    lightingResultAccumulated.direct2ndSpecular += lightingResult.direct2ndSpecular * lightingResult.shadow;\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    lightingResultAccumulated.directTT += lightingResult.directTT * lightingResult.shadow;\n    lightingResultAccumulated.diffuseColorWithLightingTT = lightingResult.diffuseColorWithLightingTT;\n  #endif\n}\n#if CC_PIPELINE_TYPE == 1\n  vec4 CCSurfacesDeferredOutput0(in SurfacesMaterialData surfaceData)\n  {\n    return surfaceData.baseColor;\n  }\n  vec4 CCSurfacesDeferredOutput1(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(float32x3_to_oct(surfaceData.worldNormal), surfaceData.roughness, surfaceData.metallic);\n  }\n  vec4 CCSurfacesDeferredOutput2(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(surfaceData.emissive, surfaceData.ao);\n  }\n#endif\nvec4 CCSurfacesShading(in SurfacesMaterialData surfaceData, in LightingResult lightingResult)\n{\n  vec4 color = vec4(0.0, 0.0, 0.0, surfaceData.baseColor.a);\n#if CC_FORWARD_ADD\n  color.xyz += lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithEnvLighting\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.direct2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    + lightingResult.directTT * lightingResult.diffuseColorWithLightingTT\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.directTransmitDiffuse\n  #endif\n  ;\n#else\n  float fresnel = 1.0;\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    fresnel = lightingResult.fresnel;\n  #endif\n  float invFresnel = 1.0 - fresnel;\n  color.xyz +=\n    ( lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithEnvLighting * invFresnel\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.direct2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    + lightingResult.directTT * lightingResult.diffuseColorWithLightingTT\n  #endif\n    )\n    * lightingResult.shadow\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.directTransmitDiffuse\n  #endif\n  ;\n  #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_ALL_IN_ONE\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting * lightingResult.shadow;\n  #elif CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting;\n  #endif\n  color.xyz +=\n    ( lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.environmentSpecular * lightingResult.specularColorWithEnvLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.environmentTransmitSpecular * lightingResult.specularColorWithEnvLighting * invFresnel\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.environment2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n    )\n    * lightingResult.ao\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.environmentTransmitDiffuse\n  #endif\n  ;\n  color.xyz += lightingResult.emissive;\n#endif\n  return color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\nbool CCSurfacesDebugViewSurfaceData(inout vec4 color, in SurfacesMaterialData surfaceData)\n{\n    bool enableMaterialAlpha = true;\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    float scalar;\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(surfaceData.worldNormal * 0.5 + vec3(0.5), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldBinormal * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSPARENCY)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.baseColor.a;\n        color = vec4(scalar, scalar, scalar, 1.0);\n        enableMaterialAlpha = false;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_BASE_COLOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(surfaceData.baseColor.rgb), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(CCSurfacesGetDiffuseColor(surfaceData)), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(CCSurfacesGetSpecularColor(surfaceData)), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ROUGHNESS)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.roughness;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_METALLIC)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.metallic;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.specularIntensity;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_IOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.ior - 1.0;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    return enableMaterialAlpha;\n}\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD && !CC_ENABLE_CLUSTERED_LIGHT_CULLING\n    void CCSurfacesLighting(inout LightingResult lightingResultAccumulated, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      CCSurfacesInitializeLightingResult(lightingResultAccumulated);\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      LightingResult lightingResult;\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n      lightingResultAccumulated.diffuseColorWithLighting = lightingResult.diffuseColorWithLighting;\n      lightingResultAccumulated.specularColorWithLighting = lightingResult.specularColorWithLighting;\n      lightingResultAccumulated.specularColorWithEnvLighting = lightingResult.specularColorWithEnvLighting;\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        vec3 diff;\n        SurfacesMaterialData surfaceData2ndSpecular;\n        CCSurfacesGetSurfacesMaterialData2ndSpecular(surfaceData2ndSpecular, surfaceData);\n        CCSurfacesLightingInitializeColorWithLighting(diff, lightingResultAccumulated.specularColorWithLighting2ndSpecular, lightingResultAccumulated.specularColorWithEnvLighting2ndSpecular, surfaceData2ndSpecular, lightingData);\n      #endif\n      int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n      for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n        if (i >= numLights) break;\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, cc_lightPos[i].xyz - worldPos);\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n        vec3 diffuseLighting, specularLighting;\n        CCSurfacesLightingCalculateDirect(diffuseLighting, specularLighting, lightingData, cc_lightColor[i]);\n        float fresnel = 1.0;\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        fresnel = lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n        float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowPosWithDepthBias = vec4(0.0);\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n            shadow = CCSpotShadowFactorBase(shadowPosWithDepthBias, shadowPos, worldPos, shadowBias);\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n            vec3 shadowNDCPos;\n            bool isExceedShadowMap = !GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n            lightingData.shadowPosAndDepth.xy = shadowNDCPos.xy;\n            lightingData.shadowPosAndDepth.z = isExceedShadowMap ? 0.0 : GetViewSpaceDepthFromNDCDepth_Perspective(shadowNDCPos.z, shadowPosWithDepthBias.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n            lightingData.shadowPosAndDepth.w = isExceedShadowMap ? lightingData.shadowPosAndDepth.w : GetViewSpaceDepthFromNDCDepth_Perspective(SampleShadowMapSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy), shadowPosWithDepthBias.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n          #endif\n        }\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW) {\n          shadow = 1.0;\n        }\n      #endif\n        lightingResult.shadow = shadow;\n        float distAtt = CCSurfacesLightingCalculateDistanceAttenuation(lightingData, cc_lightSizeRangeAngle[i]);\n        float angleAtt = 1.0;\n        if (cc_lightPos[i].w > 0.0) {\n          angleAtt = CCSurfacesLightingCalculateAngleAttenuation(lightingData, cc_lightSizeRangeAngle[i], -cc_lightDir[i].xyz);\n        }\n        float multiplier = distAtt * angleAtt;\n        lightingData.angleAttenuation = angleAtt;\n        lightingData.distAttenuation = distAtt;\n        lightingResult.directDiffuse = diffuseLighting * multiplier;\n        lightingResult.directSpecular = specularLighting * multiplier * fresnel;\n        vec4 attenuatedLightColorAndIntensity = vec4(cc_lightColor[i].xyz, cc_lightColor[i].w * multiplier);\n        #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n          vec3 transmitSpecularLighting;\n          CCSurfacesLightingCalculateDirectTransmitSpecular(transmitSpecularLighting, lightingData, attenuatedLightColorAndIntensity);\n          lightingResult.directTransmitSpecular = transmitSpecularLighting * multiplier * (1.0 - fresnel);\n        #endif\n        #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n          LightingIntermediateData lightingDataTD;\n          CCSurfacesGetLightingIntermediateDataTransmitDiffuse(lightingDataTD, lightingData, surfaceData);\n          CCSurfacesLightingCalculateIntermediateData_PerLight(lightingDataTD, surfaceData, cc_lightPos[i].xyz - worldPos);\n          CCSurfacesLightingCalculateDirectTransmitDiffuse(lightingResult.directTransmitDiffuse, lightingDataTD, attenuatedLightColorAndIntensity, lightingResult.shadow);\n        #endif\n        #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n          LightingIntermediateData lightingData2ndSpecular;\n          CCSurfacesInitializeLightingIntermediateData(lightingData2ndSpecular, surfaceData2ndSpecular);\n          CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData2ndSpecular, surfaceData, cc_lightPos[i].xyz - worldPos);\n          CCSurfacesLightingCalculateDirect2ndSpecular(lightingResult.direct2ndSpecular, lightingData2ndSpecular, attenuatedLightColorAndIntensity, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.directSpecular);\n          lightingResult.direct2ndSpecular *= multiplier * fresnel;\n        #endif\n        #if CC_SURFACES_LIGHTING_TT\n          CCSurfacesLightingCalculateDirectTT(lightingResult, lightingData, attenuatedLightColorAndIntensity);\n        #endif\n        #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n          LightingMiscData miscData;\n          miscData.lightType = cc_lightPos[i].w;\n          miscData.lightPos = cc_lightPos[i].xyz;\n          miscData.lightDir = cc_lightDir[i].xyz;\n          miscData.lightColorAndIntensity = cc_lightColor[i];\n          miscData.lightSizeRangeAngle = cc_lightSizeRangeAngle[i];\n          SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData, miscData);\n        #endif\n        CCSurfacesAccumulateLightingResult(lightingResultAccumulated, lightingResult);\n      }\n    }\n  #else\n    void CCSurfacesLighting(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      CCSurfacesInitializeLightingResult(lightingResult, surfaceData);\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n      CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, -cc_mainLitDir.xyz);\n      lightingResult.shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_mainLitDir.w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowPosWithDepthBias = vec4(0.0);\n          vec4 shadowProjDepthInfo = vec4(0.0);\n          vec3 shadowNDCPos;\n          bool isExceedShadowMap = true;\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            #if CC_DIR_LIGHT_SHADOW_TYPE == 2\n              lightingResult.shadow = CCCSMFactorBase(worldPos, lightingData.N, shadowBias);\n              #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n                vec4 shadowProjInfo;\n                vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n                isExceedShadowMap = 0 > CCGetCSMLevel(shadowPosWithDepthBias, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n                GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n              #endif\n            #endif\n            #if CC_DIR_LIGHT_SHADOW_TYPE == 1\n              shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n              lightingResult.shadow = CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, lightingData.N, shadowBias);\n              shadowProjDepthInfo = cc_shadowProjDepthInfo;\n              isExceedShadowMap = !GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n            #endif\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n            lightingData.shadowPosAndDepth.xy = shadowNDCPos.xy;\n            lightingData.shadowPosAndDepth.z = isExceedShadowMap ? 0.0 : GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowNDCPos.z, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n            lightingData.shadowPosAndDepth.w = isExceedShadowMap ? lightingData.shadowPosAndDepth.w : GetViewSpaceDepthFromNDCDepth_Orthgraphic(SampleShadowMapSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy), shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n          #endif\n        }\n      #endif\n      lightingResult.lightmapColor = vec3(0.0);\n      #if CC_SURFACES_USE_LIGHT_MAP && !CC_FORWARD_ADD\n\t\t    float lightmapShadow, lightmapAO;\n        GetLightMapColor(lightingResult.lightmapColor, lightmapShadow, lightmapAO, cc_lightingMap, FSInput_lightMapUV.xy, FSInput_lightMapUV.z, surfaceData.worldNormal);\n        #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n          lightingResult.shadow *= lightmapShadow;\n        #endif\n        lightingResult.ao *= lightmapAO;\n      #endif\n      lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n      #if !CC_DISABLE_DIRECTIONAL_LIGHT && !CC_FORWARD_ADD\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n        CCSurfacesLightingCalculateDirect(lightingResult.directDiffuse, lightingResult.directSpecular, lightingData, cc_mainLitColor);\n      #endif\n      CCSurfacesLightingCalculateEnvironment(lightingResult.environmentDiffuse, lightingResult.environmentSpecular, lightingData, cc_ambientSky.w);\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n        CCSurfacesLightingCalculateDirectTransmitSpecular(lightingResult.directTransmitSpecular, lightingData, cc_mainLitColor);\n        CCSurfacesLightingCalculateEnvironmentTransmitSpecular(lightingResult.environmentTransmitSpecular, lightingData, cc_ambientSky.w);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n        LightingIntermediateData lightingDataTD;\n        CCSurfacesGetLightingIntermediateDataTransmitDiffuse(lightingDataTD, lightingData, surfaceData);\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingDataTD, surfaceData, -cc_mainLitDir.xyz);\n        CCSurfacesLightingCalculateDirectTransmitDiffuse(lightingResult.directTransmitDiffuse, lightingDataTD, cc_mainLitColor, lightingResult.shadow);\n        CCSurfacesLightingCalculateEnvironmentTransmitDiffuse(lightingResult.environmentTransmitDiffuse, lightingDataTD, cc_ambientSky.w, lightingResult.ao, -cc_mainLitDir.xyz);\n      #endif\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        SurfacesMaterialData surfaceData2ndSpecular;\n        CCSurfacesGetSurfacesMaterialData2ndSpecular(surfaceData2ndSpecular, surfaceData);\n        LightingIntermediateData lightingData2ndSpecular;\n        CCSurfacesInitializeLightingIntermediateData(lightingData2ndSpecular, surfaceData2ndSpecular);\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData2ndSpecular, surfaceData2ndSpecular, -cc_mainLitDir.xyz);\n        CCSurfacesLightingCalculateDirect2ndSpecular(lightingResult.direct2ndSpecular, lightingData2ndSpecular, cc_mainLitColor, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.directSpecular);\n        CCSurfacesLightingCalculateEnvironment2ndSpecular(lightingResult.environment2ndSpecular, lightingData2ndSpecular, cc_ambientSky.w, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.environmentSpecular);\n        vec3 diff;\n        CCSurfacesLightingInitializeColorWithLighting(diff, lightingResult.specularColorWithLighting2ndSpecular, lightingResult.specularColorWithEnvLighting2ndSpecular, surfaceData2ndSpecular, lightingData2ndSpecular);\n      #endif\n      #if CC_SURFACES_LIGHTING_TT\n        CCSurfacesLightingCalculateDirectTT(lightingResult, lightingData, cc_mainLitColor);\n      #endif\n      #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n        LightingMiscData miscData;\n        miscData.lightType = LIGHT_TYPE_DIRECTIONAL;\n        miscData.lightPos = vec3(0.0);\n        miscData.lightDir = cc_mainLitDir.xyz;\n        miscData.lightColorAndIntensity = cc_mainLitColor;\n        miscData.lightSizeRangeAngle = vec4(0.0, 0.0, 0.0, 0.0);\n        SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData, miscData);\n      #endif\n    }\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING\n    #endif\n  #endif\n#endif\nvec4 CCSurfacesDebugDisplayInvalidNumber(vec4 color)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(color.rgb) || isinfs(color.rgb)) ? error : color;\n}\nvec4 CCSurfacesDebugDisplayInvalidInputData(vec4 color, vec3 data)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(data) || isinfs(data)) ? error : color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && !CC_FORWARD_ADD\n  void CCSurfacesDebugViewMeshData(inout vec4 color)\n  {\n    vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_VERTEX_COLOR\n        color = FSInput_vertexColor;\n      #else\n        color = white;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(FSInput_worldNormal * 0.5 + vec3(0.5), 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(FSInput_worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        float sign = FSInput_mirrorNormal * 0.5 + 0.5;\n        color = vec4(sign, sign, sign, 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FACE_SIDE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        float scalar = clamp(FSInput_faceSideSign, 0.0, 1.0);\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UV0)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(FSInput_texcoord.xy, 0.0, 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UV1)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n      color = vec4(FSInput_texcoord1.xy, 0.0, 1.0);\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n        color = vec4(FSInput_lightMapUV.xy, 0.0, 1.0);\n      #else\n        color = vec4(0.0, 0.0, 0.0, 1.0);\n      #endif\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      vec4 clipPos = cc_matProj * cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = clipPos.z / clipPos.w;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n      vec4 viewPos = cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = (-viewPos.z - cc_nearFar.x) / cc_nearFar.y;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_WORLD_POS)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n      color = vec4(FSInput_worldPos.xyz, 1.0);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\n  bool CCSurfacesDebugViewLightingResult(inout vec4 color, in LightingResult lightingResult)\n  {\n    bool isSRGBColor = false;\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentSpecular * lightingResult.specularColorWithEnvLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENV_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.environmentSpecular * lightingResult.specularColorWithLighting;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_LIGHT_MAP)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.lightmapColor;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_EMISSIVE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.emissive;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_AO)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(lightingResult.ao);\n        isSRGBColor = false;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_SHADOW)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(lightingResult.shadow);\n        isSRGBColor = false;\n    }\n    float fresnel = 0.0;\n    vec3 directTransmitSpecular = vec3(0.0), environmentTransmitSpecular = vec3(0.0);\n    vec3 directTransmitDiffuse = vec3(0.0), environmentTransmitDiffuse = vec3(0.0);\n    vec3 diffuseColorWithLightingTT = vec3(0.0), specularColorWithLighting2ndSpecular = vec3(0.0);\n    vec3 direct2ndSpecular = vec3(0.0), environment2ndSpecular = vec3(0.0);\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    fresnel = lightingResult.fresnel;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    directTransmitSpecular = lightingResult.directTransmitSpecular;\n    environmentTransmitSpecular = lightingResult.environmentTransmitSpecular;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    directTransmitDiffuse = lightingResult.directTransmitDiffuse;\n    environmentTransmitDiffuse = lightingResult.environmentTransmitDiffuse;\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    direct2ndSpecular = lightingResult.direct2ndSpecular;\n    environment2ndSpecular = lightingResult.environment2ndSpecular;\n    specularColorWithLighting2ndSpecular = lightingResult.specularColorWithEnvLighting2ndSpecular;\n  #endif\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FRESNEL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(fresnel);\n        isSRGBColor = false;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitSpecular;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environmentTransmitSpecular;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environmentTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitSpecular + environmentTransmitSpecular + directTransmitDiffuse + environmentTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = direct2ndSpecular * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environment2ndSpecular * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = (direct2ndSpecular + environment2ndSpecular) * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    return isSRGBColor;\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  void CCSurfacesDebugViewCompositeLightingResult(inout LightingResult lightingResult)\n  {\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE)\n      lightingResult.directDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR)\n      lightingResult.directSpecular = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE)\n      lightingResult.environmentDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR)\n      lightingResult.environmentSpecular = vec3(0.0);\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE)\n      lightingResult.directTransmitDiffuse = lightingResult.environmentTransmitDiffuse = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR)\n      lightingResult.directTransmitSpecular = lightingResult.environmentTransmitSpecular = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR)\n        lightingResult.direct2ndSpecular = lightingResult.environment2ndSpecular = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT)\n        lightingResult.directTT = vec3(0.0);\n  #endif\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE)\n      lightingResult.emissive = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP)\n      lightingResult.lightmapColor = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n      lightingResult.shadow = 1.0;\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO)\n      lightingResult.ao = 1.0;\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL)\n      lightingResult.fresnel = 1.0;\n  #endif\n  }\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  void main()  {\n  #if CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER\n    float NoL = dot(-cc_mainLitDir.xyz, FSInput_worldNormal.xyz);\n    vec4 color = SurfacesFragmentModifyBaseColorAndTransparency();\n  #else\n    SurfacesMaterialData surfaceData;\n    CCSurfacesFragmentGetMaterialData(surfaceData);\n    vec2 shadowBias = vec2(0.0);\n    vec3 colDebugCSMLayer = vec3(1.0);\n    #if CC_RECEIVE_SHADOW\n      shadowBias = FSInput_shadowBias;\n      #if !CC_FORWARD_ADD\n        #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n          if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION)\n          {\n              vec4 csmPos;\n              vec4 shadowProjDepthInfo, shadowProjInfo;\n              vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n              int csmLayer = -1;\n              csmLayer = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, surfaceData.worldPos);\n              bool OutOfRange = csmLayer < 0;\n              if (OutOfRange)\n                  colDebugCSMLayer = vec3(1.0);\n              else if (csmLayer == 0)\n                  colDebugCSMLayer = vec3(1.0, 0.0, 0.0);\n              else if (csmLayer == 1)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 0.0);\n              else if (csmLayer == 2)\n                  colDebugCSMLayer = vec3(0.0, 0.0, 1.0);\n              else if (csmLayer == 3)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 1.0);\n          }\n        #endif\n      #endif\n    #endif\n    float fogFactor = 1.0;\n    #if !CC_FORWARD_ADD\n      #if CC_USE_FOG != 4\n        #if !CC_USE_ACCURATE_FOG\n          fogFactor = FSInput_fogFactor;\n        #else\n          CC_TRANSFER_FOG_BASE(vec4(FSInput_worldPos, 1.0), fogFactor);\n        #endif\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG) {\n            fogFactor = 1.0;\n        }\n      #endif\n    #endif\n    LightingResult lightingResult;\n    CCSurfacesLighting(lightingResult, surfaceData, shadowBias);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      float materialTransparency = CCSurfacesShading(surfaceData, lightingResult).a;\n      #if !CC_FORWARD_ADD\n        CCSurfacesDebugViewMeshData(debugColor);\n        if (CCSurfacesDebugViewSurfaceData(debugColor, surfaceData))\n        {\n          debugColor.a = materialTransparency;\n        }\n        if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_FOG)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n        {\n          debugColor.rgb = vec3(1.0 - fogFactor);\n        }\n      #endif\n      #if CC_FORWARD_ADD\n        if (((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) || ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) || ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) ||\n            ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) || ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)) || ((abs(float(cc_debug_view_mode.x) - float(CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR)) < EPSILON_LOWP) && (cc_surfaceTransform.y != 3.0)))\n      #endif\n        {\n            if (CCSurfacesDebugViewLightingResult(debugColor, lightingResult))\n            {\n              debugColor.a = materialTransparency;\n              #if !CC_USE_FLOAT_OUTPUT\n                debugColor.rgb = HDRToLDR(debugColor.rgb);\n                debugColor.rgb = LinearToSRGB(debugColor.rgb);\n              #endif\n            }\n        }\n      if (IS_DEBUG_VIEW_ENABLE_WITH_CAMERA) {\n        gl_FragData[0] = debugColor;\n        return;\n      }\n    #elif CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n      CCSurfacesDebugViewCompositeLightingResult(lightingResult);\n    #endif\n    vec4 color = CCSurfacesShading(surfaceData, lightingResult);\n    #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n      if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION) {\n          color.rgb *= colDebugCSMLayer.rgb;\n      }\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = CCSurfacesDebugDisplayInvalidInputData(color, FSInput_worldTangent);\n      #endif\n    #endif\n  #endif\n    #if CC_USE_FOG != 4\n      #if CC_USE_RGBE_OUTPUT || CC_USE_FLOAT_OUTPUT\n        CC_APPLY_FOG_BASE(color, fogFactor);\n      #endif\n    #endif\n    #if CC_USE_RGBE_OUTPUT\n      color = packRGBE(color.rgb);\n    #else\n      color = CCSurfacesDebugDisplayInvalidNumber(color);\n      #if !CC_USE_FLOAT_OUTPUT\n        color.rgb = HDRToLDR(color.rgb);\n        color.rgb = LinearToSRGB(color.rgb);\n      #endif\n    #endif\n    #if !CC_USE_RGBE_OUTPUT && !CC_USE_FLOAT_OUTPUT && !CC_FORWARD_ADD\n      #if CC_USE_FOG != 4\n        CC_APPLY_FOG_BASE(color, fogFactor);\n      #endif\n    #endif\n    gl_FragData[0] = color;\n  }\n#elif CC_PIPELINE_TYPE == 1\n    void main () {\n      SurfacesMaterialData surfaceData;\n      CCSurfacesFragmentGetMaterialData(surfaceData);\n      gl_FragData[0] = CCSurfacesDeferredOutput0(surfaceData);\n      gl_FragData[1] = CCSurfacesDeferredOutput1(surfaceData);\n      gl_FragData[2] = CCSurfacesDeferredOutput2(surfaceData);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      CCSurfacesDebugViewMeshData(debugColor);\n      CCSurfacesDebugViewSurfaceData(debugColor, surfaceData);\n      if (IS_DEBUG_VIEW_ENABLE_WITH_CAMERA) {\n        gl_FragData[0] = debugColor;\n      }\n    #endif\n    }\n#endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","defines":[]},{"name":"cc_diffuseMap","defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["!USE_INSTANCING"]},{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":101,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":131}},"defines":[{"name":"HAS_SECOND_UV","type":"boolean"},{"name":"USE_TWOSIDE","type":"boolean"},{"name":"USE_REFLECTION_DENOISE","type":"boolean"},{"name":"IS_ANISOTROPY","type":"boolean"},{"name":"USE_VERTEX_COLOR","type":"boolean"},{"name":"USE_COMPATIBLE_LIGHTING","type":"boolean"},{"name":"USE_NORMAL_MAP","type":"boolean"},{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_REFLECTION_PROBE","type":"number","range":[0,3]},{"name":"CC_USE_LIGHT_PROBE","type":"boolean","default":0},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_FORWARD_ADD","type":"boolean"},{"name":"CC_USE_FOG","type":"number","range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER","type":"number","range":[0,1]},{"name":"CC_PIPELINE_TYPE","type":"number","range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean"},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"CC_USE_IBL","type":"number","range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","range":[0,2]},{"name":"CC_USE_HDR","type":"boolean"},{"name":"CC_USE_DEBUG_VIEW","type":"number","range":[0,3]},{"name":"CC_TONE_MAPPING_TYPE","type":"number","range":[0,3]},{"name":"HDR_TONE_MAPPING_ACES","type":"boolean"},{"name":"CC_IBL_CONVOLUTED","type":"boolean"},{"name":"CC_SHADOWMAP_FORMAT","type":"number","range":[0,3]},{"name":"CC_SHADOWMAP_USE_LINEAR_DEPTH","type":"boolean"},{"name":"CC_DIR_SHADOW_PCF_TYPE","type":"number","range":[0,3]},{"name":"CC_CASCADED_LAYERS_TRANSITION","type":"boolean"},{"name":"CC_LIGHT_MAP_VERSION","type":"number","range":[0,3]},{"name":"TEXTURE_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"DCC_APP_NAME","type":"number","range":[0,5]},{"name":"USE_SHININESS_MAP","type":"boolean"},{"name":"GLOSSINESS_MAP_CHANNEL","type":"string","options":["r","g","b","a"]},{"name":"USE_SPECULAR_GLOSSINESS_MAP","type":"boolean"},{"name":"USE_SPECULAR_MAP","type":"boolean"},{"name":"USE_METALLIC_MAP","type":"boolean"},{"name":"USE_ALBEDO_MAP","type":"boolean"},{"name":"USE_TRANSPARENCY_MAP","type":"boolean"},{"name":"TRANSPARENCY_MAP_CHANNEL","type":"string","options":["a","r","g","b"]},{"name":"USE_EMISSIVE_MAP","type":"boolean"},{"name":"USE_EMISSIVESCALE_MAP","type":"boolean"},{"name":"NORMAL_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_OCCLUSION_MAP","type":"boolean"},{"name":"OCCLUSION_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"OCCLUSION_CHANNEL","type":"string","options":["r","g","b","a"]},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"HAS_EXPORTED_GLOSSINESS","type":"boolean"},{"name":"GLOSSINESS_MAP_USE_SINGLE_CHANNEL","type":"boolean"},{"name":"HAS_EXPORTED_METALLIC","type":"boolean"},{"name":"CC_SURFACES_LIGHTING_DISABLE_DIFFUSE","type":"boolean"},{"name":"CC_SURFACES_LIGHTING_DISABLE_SPECULAR","type":"boolean"},{"name":"CC_SHADOW_TYPE","type":"number","range":[0,3]},{"name":"CC_DIR_LIGHT_SHADOW_TYPE","type":"number","range":[0,3]},{"name":"CC_DISABLE_DIRECTIONAL_LIGHT","type":"boolean"},{"name":"CC_USE_FLOAT_OUTPUT","type":"boolean"},{"name":"CC_USE_RGBE_OUTPUT","type":"boolean"}]},{"hash":3337831580,"name":"util/dcc/imported-specular-glossiness|shadow-caster-vs|shadow-caster-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"diffuseColor","type":16,"count":1},{"name":"specularColor","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScale","type":13,"count":1},{"name":"alphaThreshold","type":13,"count":1},{"name":"shininessExponent","type":13,"count":1},{"name":"glossiness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalScale","type":13,"count":1},{"name":"transparencyFactor","type":13,"count":1},{"name":"diffuseFactor","type":13,"count":1},{"name":"specularFactor","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"shininessExponentMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_SHININESS_MAP"]},{"name":"specularGlossinessMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_SPECULAR_GLOSSINESS_MAP"]},{"name":"specularMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_SPECULAR_MAP"]},{"name":"metallicMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_MAP"]},{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_ALBEDO_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_TRANSPARENCY_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_EMISSIVE_MAP"]},{"name":"emissiveScaleMap","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["USE_EMISSIVESCALE_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["USE_NORMAL_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":10,"defines":["USE_OCCLUSION_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_color","format":44,"location":6,"defines":["CC_SURFACES_USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":7,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":15,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":16,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":17,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCLocal","stageFlags":17,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]},{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_lightPos","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true},{"name":"cc_lightColor","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightSizeRangeAngle","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightDir","typename":"vec4","type":16,"count":0,"isArray":true}],"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_sh_linear_const_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_a","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"diffuseColor","type":16,"count":1},{"name":"specularColor","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScale","type":13,"count":1},{"name":"alphaThreshold","type":13,"count":1},{"name":"shininessExponent","type":13,"count":1},{"name":"glossiness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalScale","type":13,"count":1},{"name":"transparencyFactor","type":13,"count":1},{"name":"diffuseFactor","type":13,"count":1},{"name":"specularFactor","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"shininessExponentMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_SHININESS_MAP"]},{"name":"specularGlossinessMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_SPECULAR_GLOSSINESS_MAP"]},{"name":"specularMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_SPECULAR_MAP"]},{"name":"metallicMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_MAP"]},{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_ALBEDO_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_TRANSPARENCY_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_EMISSIVE_MAP"]},{"name":"emissiveScaleMap","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["USE_EMISSIVESCALE_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["USE_NORMAL_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":10,"defines":["USE_OCCLUSION_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCSM","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_csmViewDir0","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir1","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir2","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmAtlas","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_matCSMViewProj","typename":"mat4","type":25,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjDepthInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmSplitsInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":[]},{"name":"cc_diffuseMap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\n#define CC_SURFACES_USE_TANGENT_SPACE 0\n#define CC_SURFACES_USE_VERTEX_COLOR 0\n#define CC_SURFACES_USE_SECOND_UV 0\n#define CC_SURFACES_USE_LIGHT_MAP 0\n#define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    in vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    in vec4 a_sh_linear_const_r;\n    in vec4 a_sh_linear_const_g;\n    in vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n#endif\nout highp vec3 v_worldPos;\nout mediump vec4 v_normal;\nout vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  out lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  out mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  out mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  out mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  out mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  out mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  out highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  out highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    out mediump vec4 v_sh_linear_const_r;\n    out mediump vec4 v_sh_linear_const_g;\n    out mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n  #endif\n#endif\nlayout(std140) uniform Constants {\n  vec4  tilingOffset;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float emissiveScale;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.position.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nout highp vec2 v_clip_depth;\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matLightViewProj * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexOutput(In);\n  v_clip_depth = In.clipPos.zw;\n}","frag":"\nprecision highp float;\n#define CC_SURFACES_USE_TANGENT_SPACE 0\n#define CC_SURFACES_USE_VERTEX_COLOR 0\n#define CC_SURFACES_USE_SECOND_UV 0\n#define CC_SURFACES_USE_LIGHT_MAP 0\n#define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nin highp vec3 v_worldPos;\nin mediump vec4 v_normal;\nin vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  in mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  in mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  in mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  in mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  in highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  in highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    in mediump vec4 v_sh_linear_const_r;\n    in mediump vec4 v_sh_linear_const_g;\n    in mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    layout(std140) uniform CCForwardLight {\n      highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n      vec4 cc_lightColor[LIGHTS_PER_PASS];\n      vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n      vec4 cc_lightDir[LIGHTS_PER_PASS];\n    };\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    layout(std140) uniform CCSH {\n      vec4 cc_sh_linear_const_r;\n      vec4 cc_sh_linear_const_g;\n      vec4 cc_sh_linear_const_b;\n      vec4 cc_sh_quadratic_r;\n      vec4 cc_sh_quadratic_g;\n      vec4 cc_sh_quadratic_b;\n      vec4 cc_sh_quadratic_a;\n    };\n  #endif\n#endif\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_USE_FOG != 4\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n  };\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n#endif\nlayout(std140) uniform Constants {\n  vec4  tilingOffset;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float emissiveScale;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\n#define DCC_APP_OTHERS 0\n#define DCC_APP_MAX 1\n#define DCC_APP_BLENDER 2\n#define DCC_APP_CINEMA4D 3\n#define DCC_APP_GLTF 4\n#define DCC_APP_MAYA 5\n#if USE_SHININESS_MAP\n  uniform sampler2D shininessExponentMap;\n#endif\n#if USE_SPECULAR_GLOSSINESS_MAP\n  uniform sampler2D specularGlossinessMap;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n #if USE_METALLIC_MAP\n  uniform sampler2D metallicMap;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_EMISSIVESCALE_MAP\n  uniform sampler2D emissiveScaleMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\nvoid SurfacesFragmentAlphaClipOnly()\n{\n    #if USE_ALPHA_TEST\n      float alpha = diffuseColor.a;\n      #if USE_VERTEX_COLOR\n        alpha *= FSInput_vertexColor.a;\n      #endif\n      #if USE_ALBEDO_MAP\n        alpha *= texture(albedoMap, TEXTURE_UV).a * transparencyFactor;\n      #endif\n      #if USE_TRANSPARENCY_MAP\n        alpha = texture(transparencyMap, TEXTURE_UV).TRANSPARENCY_MAP_CHANNEL;\n        #if DCC_APP_NAME == DCC_APP_MAYA\n          alpha = 1.0 - alpha;\n        #endif\n      #endif\n      if (alpha < alphaThreshold) discard;\n    #endif\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\n#define CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nstruct SurfacesMaterialData\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPos, worldPos_fract_part;\n  #else\n  vec3 worldPos;\n  #endif\n  vec4 baseColor;\n  vec3 worldNormal;\n  vec3 emissive;\n  float specularIntensity;\n  float roughness;\n  float metallic;\n  float ao;\n  vec3 worldTangent, worldBinormal;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 outScatteringColor, inScatteringColor;\n  vec4 transmitScatteringParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 baseColor2ndSpecular, color2ndSpecular;\n  float intensity2ndSpecular, roughness2ndSpecular;\n  vec3 worldNormal2ndSpecular, worldTangent2ndSpecular, worldBinormal2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  vec4 sssParams;\n#endif\n};\nin highp vec2 v_clip_depth;\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\n#ifdef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n  SurfacesFragmentAlphaClipOnly();\n#endif\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  if(cc_shadowLPNNInfo.x > EPSILON && cc_shadowLPNNInfo.x < 1.999999) {\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      clipDepth = CCGetLinearDepth(FSInput_worldPos.xyz);\n    #endif\n  }\n  #if CC_SHADOWMAP_FORMAT == 1\n    fragColorX = packDepthToRGBA(clipDepth);\n  #else\n    fragColorX = vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}"},"glsl1":{"vert":"\nprecision highp float;\n#define CC_SURFACES_USE_TANGENT_SPACE 0\n#define CC_SURFACES_USE_VERTEX_COLOR 0\n#define CC_SURFACES_USE_SECOND_UV 0\n#define CC_SURFACES_USE_LIGHT_MAP 0\n#define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  attribute vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  attribute vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    attribute vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n#endif\nvarying highp vec3 v_worldPos;\nvarying mediump vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matLightViewProj;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n  #endif\n#endif\n    uniform vec4 tilingOffset;\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.position.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvarying highp vec2 v_clip_depth;\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matLightViewProj * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexOutput(In);\n  v_clip_depth = In.clipPos.zw;\n}","frag":"\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\n#define CC_SURFACES_USE_TANGENT_SPACE 0\n#define CC_SURFACES_USE_VERTEX_COLOR 0\n#define CC_SURFACES_USE_SECOND_UV 0\n#define CC_SURFACES_USE_LIGHT_MAP 0\n#define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nvarying highp vec3 v_worldPos;\nvarying mediump vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nuniform mediump vec4 cc_debug_view_mode;\nuniform mediump vec4 cc_surfaceTransform;\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    #endif\n#endif\nuniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_USE_FOG != 4\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n#endif\n    uniform vec4 diffuseColor;\n    uniform vec4 emissive;\n    uniform float alphaThreshold;\n    uniform float metallic;\n    uniform float transparencyFactor;\n#define DCC_APP_OTHERS 0\n#define DCC_APP_MAX 1\n#define DCC_APP_BLENDER 2\n#define DCC_APP_CINEMA4D 3\n#define DCC_APP_GLTF 4\n#define DCC_APP_MAYA 5\n#if USE_SHININESS_MAP\n  uniform sampler2D shininessExponentMap;\n#endif\n#if USE_SPECULAR_GLOSSINESS_MAP\n  uniform sampler2D specularGlossinessMap;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n #if USE_METALLIC_MAP\n  uniform sampler2D metallicMap;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_EMISSIVESCALE_MAP\n  uniform sampler2D emissiveScaleMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\nvoid SurfacesFragmentAlphaClipOnly()\n{\n    #if USE_ALPHA_TEST\n      float alpha = diffuseColor.a;\n      #if USE_VERTEX_COLOR\n        alpha *= FSInput_vertexColor.a;\n      #endif\n      #if USE_ALBEDO_MAP\n        alpha *= texture2D(albedoMap, TEXTURE_UV).a * transparencyFactor;\n      #endif\n      #if USE_TRANSPARENCY_MAP\n        alpha = texture2D(transparencyMap, TEXTURE_UV).TRANSPARENCY_MAP_CHANNEL;\n        #if DCC_APP_NAME == DCC_APP_MAYA\n          alpha = 1.0 - alpha;\n        #endif\n      #endif\n      if (alpha < alphaThreshold) discard;\n    #endif\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\n#define CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nstruct SurfacesMaterialData\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPos, worldPos_fract_part;\n  #else\n  vec3 worldPos;\n  #endif\n  vec4 baseColor;\n  vec3 worldNormal;\n  vec3 emissive;\n  float specularIntensity;\n  float roughness;\n  float metallic;\n  float ao;\n  vec3 worldTangent, worldBinormal;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 outScatteringColor, inScatteringColor;\n  vec4 transmitScatteringParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 baseColor2ndSpecular, color2ndSpecular;\n  float intensity2ndSpecular, roughness2ndSpecular;\n  vec3 worldNormal2ndSpecular, worldTangent2ndSpecular, worldBinormal2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  vec4 sssParams;\n#endif\n};\nvarying highp vec2 v_clip_depth;\nvoid main () {\n#ifdef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n  SurfacesFragmentAlphaClipOnly();\n#endif\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  if(cc_shadowLPNNInfo.x > EPSILON && cc_shadowLPNNInfo.x < 1.999999) {\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      clipDepth = CCGetLinearDepth(FSInput_worldPos.xyz);\n    #endif\n  }\n  #if CC_SHADOWMAP_FORMAT == 1\n    gl_FragColor = packDepthToRGBA(clipDepth);\n  #else\n    gl_FragColor = vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","defines":[]},{"name":"cc_diffuseMap","defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["!USE_INSTANCING"]},{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":101,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":131}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_REFLECTION_PROBE","type":"boolean"},{"name":"CC_USE_LIGHT_PROBE","type":"boolean","default":0},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_FORWARD_ADD","type":"boolean"},{"name":"CC_USE_FOG","type":"number","range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER","type":"number","range":[0,1]},{"name":"CC_PIPELINE_TYPE","type":"number","range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean"},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"CC_USE_IBL","type":"number","range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","range":[0,2]},{"name":"TEXTURE_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"DCC_APP_NAME","type":"number","range":[0,5]},{"name":"USE_SHININESS_MAP","type":"boolean"},{"name":"GLOSSINESS_MAP_CHANNEL","type":"string","options":["r","g","b","a"]},{"name":"USE_SPECULAR_GLOSSINESS_MAP","type":"boolean"},{"name":"USE_SPECULAR_MAP","type":"boolean"},{"name":"USE_METALLIC_MAP","type":"boolean"},{"name":"USE_ALBEDO_MAP","type":"boolean"},{"name":"USE_TRANSPARENCY_MAP","type":"boolean"},{"name":"TRANSPARENCY_MAP_CHANNEL","type":"string","options":["a","r","g","b"]},{"name":"USE_EMISSIVE_MAP","type":"boolean"},{"name":"USE_EMISSIVESCALE_MAP","type":"boolean"},{"name":"USE_NORMAL_MAP","type":"boolean"},{"name":"NORMAL_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_OCCLUSION_MAP","type":"boolean"},{"name":"OCCLUSION_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"OCCLUSION_CHANNEL","type":"string","options":["r","g","b","a"]},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"USE_VERTEX_COLOR","type":"boolean"},{"name":"CC_SHADOWMAP_USE_LINEAR_DEPTH","type":"boolean"},{"name":"CC_SHADOWMAP_FORMAT","type":"number","range":[0,3]}]}],[{"name":"opaque","passes":[{"program":"util/dcc/imported-specular-glossiness|standard-vs|standard-fs","properties":{"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"handleInfo":["diffuseColor",0,16]},"albedoScale":{"type":13,"value":[1],"handleInfo":["diffuseFactor",0,13]},"alphaThreshold":{"type":13,"value":[0.5]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1]},"emissiveMap":{"value":"grey","type":28},"emissiveScale":{"type":13,"value":[1]},"emissiveScaleMap":{"value":"grey","type":28},"shininessExponentMap":{"value":"grey","type":28},"shininessExponent":{"type":13,"value":[100]},"specularGlossinessMap":{"value":"grey","type":28},"specularColor":{"linear":true,"type":16,"value":[0,0,0,0]},"specularMap":{"value":"grey","type":28},"specularFactor":{"type":13,"value":[1]},"transparencyMap":{"value":"grey","type":28},"transparencyFactor":{"type":13,"value":[1]},"tilingOffset":{"type":16,"value":[1,1,0,0]},"normalStrength":{"type":13,"value":[1],"handleInfo":["normalScale",0,13]},"normalMap":{"value":"normal","type":28},"glossiness":{"type":13,"value":[0]},"metallic":{"type":13,"value":[0]},"metallicMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"albedoMap":{"type":28,"value":"grey"},"diffuseColor":{"type":16,"value":[1,1,1,1]},"diffuseFactor":{"type":13,"value":[1]},"normalScale":{"type":13,"value":[1]}}},{"phase":"forward-add","propertyIndex":0,"program":"util/dcc/imported-specular-glossiness|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"util/dcc/imported-specular-glossiness|shadow-caster-vs|shadow-caster-fs","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"handleInfo":["diffuseColor",0,16]},"albedoScale":{"type":13,"value":[1],"handleInfo":["diffuseFactor",0,13]},"alphaThreshold":{"type":13,"value":[0.5]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"transparencyMap":{"value":"grey","type":28},"transparencyFactor":{"type":13,"value":[1]},"diffuseColor":{"type":16,"value":[1,1,1,1]},"diffuseFactor":{"type":13,"value":[1]},"albedoMap":{"type":28,"value":"grey"}}}]},{"name":"transparent","passes":[{"program":"util/dcc/imported-specular-glossiness|standard-vs|standard-fs","embeddedMacros":{"CC_FORCE_FORWARD_SHADING":true},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"handleInfo":["diffuseColor",0,16]},"albedoScale":{"type":13,"value":[1],"handleInfo":["diffuseFactor",0,13]},"alphaThreshold":{"type":13,"value":[0.5]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1]},"emissiveMap":{"value":"grey","type":28},"emissiveScale":{"type":13,"value":[1]},"emissiveScaleMap":{"value":"grey","type":28},"shininessExponentMap":{"value":"grey","type":28},"shininessExponent":{"type":13,"value":[100]},"specularGlossinessMap":{"value":"grey","type":28},"specularColor":{"linear":true,"type":16,"value":[0,0,0,0]},"specularMap":{"value":"grey","type":28},"specularFactor":{"type":13,"value":[1]},"transparencyMap":{"value":"grey","type":28},"transparencyFactor":{"type":13,"value":[1]},"tilingOffset":{"type":16,"value":[1,1,0,0]},"normalStrength":{"type":13,"value":[1],"handleInfo":["normalScale",0,13]},"normalMap":{"value":"normal","type":28},"glossiness":{"type":13,"value":[0]},"metallic":{"type":13,"value":[0]},"metallicMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"albedoMap":{"type":28,"value":"grey"},"diffuseColor":{"type":16,"value":[1,1,1,1]},"diffuseFactor":{"type":13,"value":[1]},"normalScale":{"type":13,"value":[1]}}},{"phase":"forward-add","propertyIndex":0,"program":"util/dcc/imported-specular-glossiness|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"util/dcc/imported-specular-glossiness|shadow-caster-vs|shadow-caster-fs","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"handleInfo":["diffuseColor",0,16]},"albedoScale":{"type":13,"value":[1],"handleInfo":["diffuseFactor",0,13]},"alphaThreshold":{"type":13,"value":[0.5]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"transparencyMap":{"value":"grey","type":28},"transparencyFactor":{"type":13,"value":[1]},"diffuseColor":{"type":16,"value":[1,1,1,1]},"diffuseFactor":{"type":13,"value":[1]},"albedoMap":{"type":28,"value":"grey"}}}]}]]],0,0,[],[],[]]]]
